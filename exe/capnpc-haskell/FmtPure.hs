{-# LANGUAGE NamedFieldPuns    #-}
{-# LANGUAGE OverloadedLists   #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards   #-}
-- Generate idiomatic haskell data types from the types in IR.
module FmtPure
    ( fmtModule
    ) where

import IR

import Data.Capnp.Core.Schema (Id)
import Data.Monoid            (mconcat, (<>))
import GHC.Exts               (IsList(..))
import Text.Printf            (printf)
import Util                   (mintercalate)

import qualified Data.Text              as T
import qualified Data.Text.Lazy.Builder as TB

fmtName :: Id -> Name -> TB.Builder
fmtName thisMod Name{..} = modPrefix <> localName
  where
    localName = mintercalate "'" $
        map TB.fromText $ fromList $ toList nameLocalNS ++ [nameUnqualified]
    modPrefix
        | null nsParts || modRefToNS (ByCapnpId thisMod) == ns = ""
        | otherwise = fmtModRef nameModule <> "."
    ns@(Namespace nsParts) = modRefToNS nameModule

modRefToNS :: ModuleRef -> Namespace
modRefToNS (FullyQualified ns) = ns
modRefToNS (ByCapnpId id) = Namespace
    ["Data", "Capnp", "ById", T.pack (printf "X%x" id), "Pure"]

fmtModule :: Module -> TB.Builder
fmtModule Module{..} = mintercalate "\n"
    [ "{-# LANGUAGE DuplicateRecordFields #-}"
    , "{-# OPTIONS_GHC -Wno-unused-imports #-}"
    , "module "
        <> fmtModRef (ByCapnpId modId)
        <> " where"
    , ""
    , "-- Code generated by capnpc-haskell. DO NOT EDIT."
    , "-- Generated from schema file: " <> TB.fromText modFile
    , ""
    , "import Data.Int"
    , "import Data.Word"
    , ""
    , "import Data.Capnp.Untyped.Pure (List)"
    , "import Data.Capnp.BuiltinTypes.Pure (Data, Text)"
    , ""
    , "import qualified Data.Capnp.Untyped.Pure"
    , "import qualified Codec.Capnp"
    , ""
    , mintercalate "\n" $ map fmtImport modImports
    , ""
    , mconcat $ map (fmtDataDef modId) modDefs
    ]

fmtImport :: Import -> TB.Builder
fmtImport (Import ref) = "import qualified " <> fmtModRef ref

fmtModRef :: ModuleRef -> TB.Builder
fmtModRef ref = mintercalate "." (map TB.fromText $ toList $ modRefToNS ref)

fmtType :: Id -> Type -> TB.Builder
fmtType thisMod (Type name params) =
    fmtName thisMod name
    <> mconcat [" (" <> fmtType thisMod ty <> ")" | ty <- params]
fmtType thisMod (ListOf eltType) = "List (" <> fmtType thisMod eltType <> ")"
fmtType thisMod (PrimType prim)  = fmtPrimType prim
fmtType thisMod (Untyped ty)     = "Maybe (" <> fmtUntyped ty <> ")"

fmtPrimType :: PrimType -> TB.Builder
fmtPrimType PrimInt{isSigned=True,size}  = "Int" <> TB.fromString (show size)
fmtPrimType PrimInt{isSigned=False,size} = "Word" <> TB.fromString (show size)
fmtPrimType PrimFloat32                  = "Float"
fmtPrimType PrimFloat64                  = "Double"
fmtPrimType PrimBool                     = "Bool"
fmtPrimType PrimText                     = "Text"
fmtPrimType PrimData                     = "Data"
fmtPrimType PrimVoid                     = "()"

fmtUntyped :: Untyped -> TB.Builder
fmtUntyped Struct = "Data.Capnp.Untyped.Pure.Struct"
fmtUntyped List   = "Data.Capnp.Untyped.Pure.List'"
fmtUntyped Cap    = "Data.Capnp.Untyped.Pure.Cap"
fmtUntyped Ptr    = "Data.Capnp.Untyped.Pure.PtrType"

fmtVariant :: Id -> Variant -> TB.Builder
fmtVariant thisMod Variant{variantName,variantParams} =
    fmtName thisMod variantName
    <> case variantParams of
        NoParams -> ""
        Unnamed ty _ -> " (" <> fmtType thisMod ty <> ")"
        Record [] -> ""
        Record fields -> mconcat
            [ "\n        { "
            , mintercalate "\n        , " $ map (fmtField thisMod) fields
            ,  "\n        }"
            ]

fmtField :: Id -> Field -> TB.Builder
fmtField thisMod Field{fieldName,fieldType} =
    TB.fromText fieldName <> " :: " <> fmtType thisMod fieldType

fmtDataDef ::  Id -> DataDef -> TB.Builder
fmtDataDef thisMod DataDef{dataName,dataVariants} = mconcat
    [ "data ", fmtName thisMod dataName, "\n    = "
    , mintercalate "\n    | " $ map (fmtVariant thisMod) dataVariants
    , "\n    deriving(Show, Read, Eq)\n\n"
    ]
