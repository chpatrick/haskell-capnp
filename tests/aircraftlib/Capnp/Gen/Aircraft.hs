{-# OPTIONS_GHC -Wno-unused-imports #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE DeriveGeneric #-}
{- |
Module: Capnp.Gen.Aircraft
Description: Low-level generated module for aircraft.capnp
This module is the generated code for aircraft.capnp, for the
low-level api.
-}
module Capnp.Gen.Aircraft where
-- Code generated by capnpc-haskell. DO NOT EDIT.
-- Generated from schema file: aircraft.capnp
import Data.Int
import Data.Word
import GHC.Generics (Generic)
import Capnp.Bits (Word1)
import qualified Data.Bits
import qualified Data.Maybe
import qualified Data.ByteString
import qualified Capnp.Classes as C'
import qualified Capnp.Basics as B'
import qualified Capnp.GenHelpers as H'
import qualified Capnp.TraversalLimit as TL'
import qualified Capnp.Untyped as U'
import qualified Capnp.Message as M'
newtype A320 msg = A320_newtype_ (U'.Struct msg)
instance U'.TraverseMsg A320 where
    tMsg f (A320_newtype_ s) = A320_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (A320 msg) where
    fromStruct = pure . A320_newtype_
instance C'.ToStruct msg (A320 msg) where
    toStruct (A320_newtype_ struct) = struct
instance U'.HasMessage (A320 msg) where
    type InMessage (A320 msg) = msg
    message (A320_newtype_ struct) = U'.message struct
instance U'.MessageDefault (A320 msg) where
    messageDefault = A320_newtype_ . U'.messageDefault
instance B'.ListElem msg (A320 msg) where
    newtype List msg (A320 msg) = List_A320 (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_A320 <$> C'.fromPtr msg ptr
    toUntypedList (List_A320 l) = U'.ListStruct l
    length (List_A320 l) = U'.length l
    index i (List_A320 l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (A320 msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (A320 msg) where
    fromPtr msg ptr = A320_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (A320_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (A320 (M'.MutMsg s)) where
    setIndex (A320_newtype_ elt) i (List_A320 l) = U'.setIndex elt i l
    newList msg len = List_A320 <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (A320 (M'.MutMsg s)) where
    new msg = A320_newtype_ <$> U'.allocStruct msg 0 1
get_A320'base :: U'.ReadCtx m msg => A320 msg -> m (PlaneBase msg)
get_A320'base (A320_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_A320'base :: U'.ReadCtx m msg => A320 msg -> m Bool
has_A320'base(A320_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_A320'base :: U'.RWCtx m s => A320 (M'.MutMsg s) -> (PlaneBase (M'.MutMsg s)) -> m ()
set_A320'base (A320_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_A320'base :: U'.RWCtx m s => A320 (M'.MutMsg s) -> m ((PlaneBase (M'.MutMsg s)))
new_A320'base struct = do
    result <- C'.new (U'.message struct)
    set_A320'base struct result
    pure result
newtype Aircraft msg = Aircraft_newtype_ (U'.Struct msg)
instance U'.TraverseMsg Aircraft where
    tMsg f (Aircraft_newtype_ s) = Aircraft_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (Aircraft msg) where
    fromStruct = pure . Aircraft_newtype_
instance C'.ToStruct msg (Aircraft msg) where
    toStruct (Aircraft_newtype_ struct) = struct
instance U'.HasMessage (Aircraft msg) where
    type InMessage (Aircraft msg) = msg
    message (Aircraft_newtype_ struct) = U'.message struct
instance U'.MessageDefault (Aircraft msg) where
    messageDefault = Aircraft_newtype_ . U'.messageDefault
instance B'.ListElem msg (Aircraft msg) where
    newtype List msg (Aircraft msg) = List_Aircraft (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_Aircraft <$> C'.fromPtr msg ptr
    toUntypedList (List_Aircraft l) = U'.ListStruct l
    length (List_Aircraft l) = U'.length l
    index i (List_Aircraft l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Aircraft msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (Aircraft msg) where
    fromPtr msg ptr = Aircraft_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (Aircraft_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (Aircraft (M'.MutMsg s)) where
    setIndex (Aircraft_newtype_ elt) i (List_Aircraft l) = U'.setIndex elt i l
    newList msg len = List_Aircraft <$> U'.allocCompositeList msg 1 1 len
instance C'.Allocate s (Aircraft (M'.MutMsg s)) where
    new msg = Aircraft_newtype_ <$> U'.allocStruct msg 1 1
data Aircraft' msg
    = Aircraft'void
    | Aircraft'b737 (B737 msg)
    | Aircraft'a320 (A320 msg)
    | Aircraft'f16 (F16 msg)
    | Aircraft'unknown' Word16
get_Aircraft' :: U'.ReadCtx m msg => Aircraft msg -> m (Aircraft' msg)
get_Aircraft' (Aircraft_newtype_ struct) = C'.fromStruct struct
set_Aircraft'void :: U'.RWCtx m s => Aircraft (M'.MutMsg s) -> m ()
set_Aircraft'void (Aircraft_newtype_ struct) = H'.setWordField struct (0 :: Word16) 0 0 0
set_Aircraft'b737 :: U'.RWCtx m s => Aircraft (M'.MutMsg s) -> (B737 (M'.MutMsg s)) -> m ()
set_Aircraft'b737(Aircraft_newtype_ struct) value = do
    H'.setWordField struct (1 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Aircraft'b737 :: U'.RWCtx m s => Aircraft (M'.MutMsg s) -> m ((B737 (M'.MutMsg s)))
new_Aircraft'b737 struct = do
    result <- C'.new (U'.message struct)
    set_Aircraft'b737 struct result
    pure result
set_Aircraft'a320 :: U'.RWCtx m s => Aircraft (M'.MutMsg s) -> (A320 (M'.MutMsg s)) -> m ()
set_Aircraft'a320(Aircraft_newtype_ struct) value = do
    H'.setWordField struct (2 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Aircraft'a320 :: U'.RWCtx m s => Aircraft (M'.MutMsg s) -> m ((A320 (M'.MutMsg s)))
new_Aircraft'a320 struct = do
    result <- C'.new (U'.message struct)
    set_Aircraft'a320 struct result
    pure result
set_Aircraft'f16 :: U'.RWCtx m s => Aircraft (M'.MutMsg s) -> (F16 (M'.MutMsg s)) -> m ()
set_Aircraft'f16(Aircraft_newtype_ struct) value = do
    H'.setWordField struct (3 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Aircraft'f16 :: U'.RWCtx m s => Aircraft (M'.MutMsg s) -> m ((F16 (M'.MutMsg s)))
new_Aircraft'f16 struct = do
    result <- C'.new (U'.message struct)
    set_Aircraft'f16 struct result
    pure result
set_Aircraft'unknown' :: U'.RWCtx m s => Aircraft (M'.MutMsg s) -> Word16 -> m ()
set_Aircraft'unknown'(Aircraft_newtype_ struct) tagValue = H'.setWordField struct (tagValue :: Word16) 0 0 0
instance C'.FromStruct msg (Aircraft' msg) where
    fromStruct struct = do
        tag <-  H'.getWordField struct 0 0 0
        case tag of
            3 -> Aircraft'f16 <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            2 -> Aircraft'a320 <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            1 -> Aircraft'b737 <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            0 -> pure Aircraft'void
            _ -> pure $ Aircraft'unknown' tag
data Airport
    = Airport'none
    | Airport'jfk
    | Airport'lax
    | Airport'sfo
    | Airport'luv
    | Airport'dfw
    | Airport'test
    | Airport'unknown' Word16
    deriving(Show,Read,Eq,Generic)
instance Enum Airport where
    toEnum = C'.fromWord . fromIntegral
    fromEnum = fromIntegral . C'.toWord
instance C'.IsWord Airport where
    fromWord n = go (fromIntegral n :: Word16) where
        go 0 = Airport'none
        go 1 = Airport'jfk
        go 2 = Airport'lax
        go 3 = Airport'sfo
        go 4 = Airport'luv
        go 5 = Airport'dfw
        go 6 = Airport'test
        go tag = Airport'unknown' (fromIntegral tag)
    toWord Airport'none = 0
    toWord Airport'jfk = 1
    toWord Airport'lax = 2
    toWord Airport'sfo = 3
    toWord Airport'luv = 4
    toWord Airport'dfw = 5
    toWord Airport'test = 6
    toWord (Airport'unknown' tag) = fromIntegral tag
instance B'.ListElem msg Airport where
    newtype List msg Airport = List_Airport (U'.ListOf msg Word16)
    listFromPtr msg ptr = List_Airport <$> C'.fromPtr msg ptr
    toUntypedList (List_Airport l) = U'.List16 l
    length (List_Airport l) = U'.length l
    index i (List_Airport l) = (C'.fromWord . fromIntegral) <$> U'.index i l
instance B'.MutListElem s Airport where
    setIndex elt i (List_Airport l) = U'.setIndex (fromIntegral $ C'.toWord elt) i l
    newList msg size = List_Airport <$> U'.allocList16 msg size
newtype B737 msg = B737_newtype_ (U'.Struct msg)
instance U'.TraverseMsg B737 where
    tMsg f (B737_newtype_ s) = B737_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (B737 msg) where
    fromStruct = pure . B737_newtype_
instance C'.ToStruct msg (B737 msg) where
    toStruct (B737_newtype_ struct) = struct
instance U'.HasMessage (B737 msg) where
    type InMessage (B737 msg) = msg
    message (B737_newtype_ struct) = U'.message struct
instance U'.MessageDefault (B737 msg) where
    messageDefault = B737_newtype_ . U'.messageDefault
instance B'.ListElem msg (B737 msg) where
    newtype List msg (B737 msg) = List_B737 (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_B737 <$> C'.fromPtr msg ptr
    toUntypedList (List_B737 l) = U'.ListStruct l
    length (List_B737 l) = U'.length l
    index i (List_B737 l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (B737 msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (B737 msg) where
    fromPtr msg ptr = B737_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (B737_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (B737 (M'.MutMsg s)) where
    setIndex (B737_newtype_ elt) i (List_B737 l) = U'.setIndex elt i l
    newList msg len = List_B737 <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (B737 (M'.MutMsg s)) where
    new msg = B737_newtype_ <$> U'.allocStruct msg 0 1
get_B737'base :: U'.ReadCtx m msg => B737 msg -> m (PlaneBase msg)
get_B737'base (B737_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_B737'base :: U'.ReadCtx m msg => B737 msg -> m Bool
has_B737'base(B737_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_B737'base :: U'.RWCtx m s => B737 (M'.MutMsg s) -> (PlaneBase (M'.MutMsg s)) -> m ()
set_B737'base (B737_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_B737'base :: U'.RWCtx m s => B737 (M'.MutMsg s) -> m ((PlaneBase (M'.MutMsg s)))
new_B737'base struct = do
    result <- C'.new (U'.message struct)
    set_B737'base struct result
    pure result
newtype Bag msg = Bag_newtype_ (U'.Struct msg)
instance U'.TraverseMsg Bag where
    tMsg f (Bag_newtype_ s) = Bag_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (Bag msg) where
    fromStruct = pure . Bag_newtype_
instance C'.ToStruct msg (Bag msg) where
    toStruct (Bag_newtype_ struct) = struct
instance U'.HasMessage (Bag msg) where
    type InMessage (Bag msg) = msg
    message (Bag_newtype_ struct) = U'.message struct
instance U'.MessageDefault (Bag msg) where
    messageDefault = Bag_newtype_ . U'.messageDefault
instance B'.ListElem msg (Bag msg) where
    newtype List msg (Bag msg) = List_Bag (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_Bag <$> C'.fromPtr msg ptr
    toUntypedList (List_Bag l) = U'.ListStruct l
    length (List_Bag l) = U'.length l
    index i (List_Bag l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Bag msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (Bag msg) where
    fromPtr msg ptr = Bag_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (Bag_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (Bag (M'.MutMsg s)) where
    setIndex (Bag_newtype_ elt) i (List_Bag l) = U'.setIndex elt i l
    newList msg len = List_Bag <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (Bag (M'.MutMsg s)) where
    new msg = Bag_newtype_ <$> U'.allocStruct msg 0 1
get_Bag'counter :: U'.ReadCtx m msg => Bag msg -> m (Counter msg)
get_Bag'counter (Bag_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_Bag'counter :: U'.ReadCtx m msg => Bag msg -> m Bool
has_Bag'counter(Bag_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_Bag'counter :: U'.RWCtx m s => Bag (M'.MutMsg s) -> (Counter (M'.MutMsg s)) -> m ()
set_Bag'counter (Bag_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Bag'counter :: U'.RWCtx m s => Bag (M'.MutMsg s) -> m ((Counter (M'.MutMsg s)))
new_Bag'counter struct = do
    result <- C'.new (U'.message struct)
    set_Bag'counter struct result
    pure result
newtype BenchmarkA msg = BenchmarkA_newtype_ (U'.Struct msg)
instance U'.TraverseMsg BenchmarkA where
    tMsg f (BenchmarkA_newtype_ s) = BenchmarkA_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (BenchmarkA msg) where
    fromStruct = pure . BenchmarkA_newtype_
instance C'.ToStruct msg (BenchmarkA msg) where
    toStruct (BenchmarkA_newtype_ struct) = struct
instance U'.HasMessage (BenchmarkA msg) where
    type InMessage (BenchmarkA msg) = msg
    message (BenchmarkA_newtype_ struct) = U'.message struct
instance U'.MessageDefault (BenchmarkA msg) where
    messageDefault = BenchmarkA_newtype_ . U'.messageDefault
instance B'.ListElem msg (BenchmarkA msg) where
    newtype List msg (BenchmarkA msg) = List_BenchmarkA (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_BenchmarkA <$> C'.fromPtr msg ptr
    toUntypedList (List_BenchmarkA l) = U'.ListStruct l
    length (List_BenchmarkA l) = U'.length l
    index i (List_BenchmarkA l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (BenchmarkA msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (BenchmarkA msg) where
    fromPtr msg ptr = BenchmarkA_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (BenchmarkA_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (BenchmarkA (M'.MutMsg s)) where
    setIndex (BenchmarkA_newtype_ elt) i (List_BenchmarkA l) = U'.setIndex elt i l
    newList msg len = List_BenchmarkA <$> U'.allocCompositeList msg 3 2 len
instance C'.Allocate s (BenchmarkA (M'.MutMsg s)) where
    new msg = BenchmarkA_newtype_ <$> U'.allocStruct msg 3 2
get_BenchmarkA'name :: U'.ReadCtx m msg => BenchmarkA msg -> m (B'.Text msg)
get_BenchmarkA'name (BenchmarkA_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_BenchmarkA'name :: U'.ReadCtx m msg => BenchmarkA msg -> m Bool
has_BenchmarkA'name(BenchmarkA_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_BenchmarkA'name :: U'.RWCtx m s => BenchmarkA (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_BenchmarkA'name (BenchmarkA_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_BenchmarkA'name :: U'.RWCtx m s => Int -> BenchmarkA (M'.MutMsg s) -> m ((B'.Text (M'.MutMsg s)))
new_BenchmarkA'name len struct = do
    result <- B'.newText (U'.message struct) len
    set_BenchmarkA'name struct result
    pure result
get_BenchmarkA'birthDay :: U'.ReadCtx m msg => BenchmarkA msg -> m Int64
get_BenchmarkA'birthDay (BenchmarkA_newtype_ struct) = H'.getWordField struct 0 0 0
set_BenchmarkA'birthDay :: U'.RWCtx m s => BenchmarkA (M'.MutMsg s) -> Int64 -> m ()
set_BenchmarkA'birthDay (BenchmarkA_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 0 0 0
get_BenchmarkA'phone :: U'.ReadCtx m msg => BenchmarkA msg -> m (B'.Text msg)
get_BenchmarkA'phone (BenchmarkA_newtype_ struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)
has_BenchmarkA'phone :: U'.ReadCtx m msg => BenchmarkA msg -> m Bool
has_BenchmarkA'phone(BenchmarkA_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
set_BenchmarkA'phone :: U'.RWCtx m s => BenchmarkA (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_BenchmarkA'phone (BenchmarkA_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 1 struct
new_BenchmarkA'phone :: U'.RWCtx m s => Int -> BenchmarkA (M'.MutMsg s) -> m ((B'.Text (M'.MutMsg s)))
new_BenchmarkA'phone len struct = do
    result <- B'.newText (U'.message struct) len
    set_BenchmarkA'phone struct result
    pure result
get_BenchmarkA'siblings :: U'.ReadCtx m msg => BenchmarkA msg -> m Int32
get_BenchmarkA'siblings (BenchmarkA_newtype_ struct) = H'.getWordField struct 1 0 0
set_BenchmarkA'siblings :: U'.RWCtx m s => BenchmarkA (M'.MutMsg s) -> Int32 -> m ()
set_BenchmarkA'siblings (BenchmarkA_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 1 0 0
get_BenchmarkA'spouse :: U'.ReadCtx m msg => BenchmarkA msg -> m Bool
get_BenchmarkA'spouse (BenchmarkA_newtype_ struct) = H'.getWordField struct 1 32 0
set_BenchmarkA'spouse :: U'.RWCtx m s => BenchmarkA (M'.MutMsg s) -> Bool -> m ()
set_BenchmarkA'spouse (BenchmarkA_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word1) 1 32 0
get_BenchmarkA'money :: U'.ReadCtx m msg => BenchmarkA msg -> m Double
get_BenchmarkA'money (BenchmarkA_newtype_ struct) = H'.getWordField struct 2 0 0
set_BenchmarkA'money :: U'.RWCtx m s => BenchmarkA (M'.MutMsg s) -> Double -> m ()
set_BenchmarkA'money (BenchmarkA_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 2 0 0
newtype CallSequence msg = CallSequence (Maybe (U'.Cap msg))
instance C'.IsPtr msg (CallSequence msg) where
    fromPtr msg cap = CallSequence <$> C'.fromPtr msg cap
    toPtr msg (CallSequence Nothing) = pure Nothing
    toPtr msg (CallSequence (Just cap)) = pure $ Just $ U'.PtrCap cap
newtype Counter msg = Counter_newtype_ (U'.Struct msg)
instance U'.TraverseMsg Counter where
    tMsg f (Counter_newtype_ s) = Counter_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (Counter msg) where
    fromStruct = pure . Counter_newtype_
instance C'.ToStruct msg (Counter msg) where
    toStruct (Counter_newtype_ struct) = struct
instance U'.HasMessage (Counter msg) where
    type InMessage (Counter msg) = msg
    message (Counter_newtype_ struct) = U'.message struct
instance U'.MessageDefault (Counter msg) where
    messageDefault = Counter_newtype_ . U'.messageDefault
instance B'.ListElem msg (Counter msg) where
    newtype List msg (Counter msg) = List_Counter (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_Counter <$> C'.fromPtr msg ptr
    toUntypedList (List_Counter l) = U'.ListStruct l
    length (List_Counter l) = U'.length l
    index i (List_Counter l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Counter msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (Counter msg) where
    fromPtr msg ptr = Counter_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (Counter_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (Counter (M'.MutMsg s)) where
    setIndex (Counter_newtype_ elt) i (List_Counter l) = U'.setIndex elt i l
    newList msg len = List_Counter <$> U'.allocCompositeList msg 1 2 len
instance C'.Allocate s (Counter (M'.MutMsg s)) where
    new msg = Counter_newtype_ <$> U'.allocStruct msg 1 2
get_Counter'size :: U'.ReadCtx m msg => Counter msg -> m Int64
get_Counter'size (Counter_newtype_ struct) = H'.getWordField struct 0 0 0
set_Counter'size :: U'.RWCtx m s => Counter (M'.MutMsg s) -> Int64 -> m ()
set_Counter'size (Counter_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 0 0 0
get_Counter'words :: U'.ReadCtx m msg => Counter msg -> m (B'.Text msg)
get_Counter'words (Counter_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_Counter'words :: U'.ReadCtx m msg => Counter msg -> m Bool
has_Counter'words(Counter_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_Counter'words :: U'.RWCtx m s => Counter (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_Counter'words (Counter_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Counter'words :: U'.RWCtx m s => Int -> Counter (M'.MutMsg s) -> m ((B'.Text (M'.MutMsg s)))
new_Counter'words len struct = do
    result <- B'.newText (U'.message struct) len
    set_Counter'words struct result
    pure result
get_Counter'wordlist :: U'.ReadCtx m msg => Counter msg -> m (B'.List msg (B'.Text msg))
get_Counter'wordlist (Counter_newtype_ struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)
has_Counter'wordlist :: U'.ReadCtx m msg => Counter msg -> m Bool
has_Counter'wordlist(Counter_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
set_Counter'wordlist :: U'.RWCtx m s => Counter (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (B'.Text (M'.MutMsg s))) -> m ()
set_Counter'wordlist (Counter_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 1 struct
new_Counter'wordlist :: U'.RWCtx m s => Int -> Counter (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (B'.Text (M'.MutMsg s))))
new_Counter'wordlist len struct = do
    result <- C'.newList (U'.message struct) len
    set_Counter'wordlist struct result
    pure result
newtype CounterAcceptor msg = CounterAcceptor (Maybe (U'.Cap msg))
instance C'.IsPtr msg (CounterAcceptor msg) where
    fromPtr msg cap = CounterAcceptor <$> C'.fromPtr msg cap
    toPtr msg (CounterAcceptor Nothing) = pure Nothing
    toPtr msg (CounterAcceptor (Just cap)) = pure $ Just $ U'.PtrCap cap
newtype CounterFactory msg = CounterFactory (Maybe (U'.Cap msg))
instance C'.IsPtr msg (CounterFactory msg) where
    fromPtr msg cap = CounterFactory <$> C'.fromPtr msg cap
    toPtr msg (CounterFactory Nothing) = pure Nothing
    toPtr msg (CounterFactory (Just cap)) = pure $ Just $ U'.PtrCap cap
newtype Defaults msg = Defaults_newtype_ (U'.Struct msg)
instance U'.TraverseMsg Defaults where
    tMsg f (Defaults_newtype_ s) = Defaults_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (Defaults msg) where
    fromStruct = pure . Defaults_newtype_
instance C'.ToStruct msg (Defaults msg) where
    toStruct (Defaults_newtype_ struct) = struct
instance U'.HasMessage (Defaults msg) where
    type InMessage (Defaults msg) = msg
    message (Defaults_newtype_ struct) = U'.message struct
instance U'.MessageDefault (Defaults msg) where
    messageDefault = Defaults_newtype_ . U'.messageDefault
instance B'.ListElem msg (Defaults msg) where
    newtype List msg (Defaults msg) = List_Defaults (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_Defaults <$> C'.fromPtr msg ptr
    toUntypedList (List_Defaults l) = U'.ListStruct l
    length (List_Defaults l) = U'.length l
    index i (List_Defaults l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Defaults msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (Defaults msg) where
    fromPtr msg ptr = Defaults_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (Defaults_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (Defaults (M'.MutMsg s)) where
    setIndex (Defaults_newtype_ elt) i (List_Defaults l) = U'.setIndex elt i l
    newList msg len = List_Defaults <$> U'.allocCompositeList msg 2 2 len
instance C'.Allocate s (Defaults (M'.MutMsg s)) where
    new msg = Defaults_newtype_ <$> U'.allocStruct msg 2 2
get_Defaults'text :: U'.ReadCtx m msg => Defaults msg -> m (B'.Text msg)
get_Defaults'text (Defaults_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_Defaults'text :: U'.ReadCtx m msg => Defaults msg -> m Bool
has_Defaults'text(Defaults_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_Defaults'text :: U'.RWCtx m s => Defaults (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_Defaults'text (Defaults_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Defaults'text :: U'.RWCtx m s => Int -> Defaults (M'.MutMsg s) -> m ((B'.Text (M'.MutMsg s)))
new_Defaults'text len struct = do
    result <- B'.newText (U'.message struct) len
    set_Defaults'text struct result
    pure result
get_Defaults'data_ :: U'.ReadCtx m msg => Defaults msg -> m (B'.Data msg)
get_Defaults'data_ (Defaults_newtype_ struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)
has_Defaults'data_ :: U'.ReadCtx m msg => Defaults msg -> m Bool
has_Defaults'data_(Defaults_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
set_Defaults'data_ :: U'.RWCtx m s => Defaults (M'.MutMsg s) -> (B'.Data (M'.MutMsg s)) -> m ()
set_Defaults'data_ (Defaults_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 1 struct
new_Defaults'data_ :: U'.RWCtx m s => Int -> Defaults (M'.MutMsg s) -> m ((B'.Data (M'.MutMsg s)))
new_Defaults'data_ len struct = do
    result <- B'.newData (U'.message struct) len
    set_Defaults'data_ struct result
    pure result
get_Defaults'float :: U'.ReadCtx m msg => Defaults msg -> m Float
get_Defaults'float (Defaults_newtype_ struct) = H'.getWordField struct 0 0 1078523331
set_Defaults'float :: U'.RWCtx m s => Defaults (M'.MutMsg s) -> Float -> m ()
set_Defaults'float (Defaults_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 1078523331
get_Defaults'int :: U'.ReadCtx m msg => Defaults msg -> m Int32
get_Defaults'int (Defaults_newtype_ struct) = H'.getWordField struct 0 32 18446744073709551493
set_Defaults'int :: U'.RWCtx m s => Defaults (M'.MutMsg s) -> Int32 -> m ()
set_Defaults'int (Defaults_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 32 18446744073709551493
get_Defaults'uint :: U'.ReadCtx m msg => Defaults msg -> m Word32
get_Defaults'uint (Defaults_newtype_ struct) = H'.getWordField struct 1 0 42
set_Defaults'uint :: U'.RWCtx m s => Defaults (M'.MutMsg s) -> Word32 -> m ()
set_Defaults'uint (Defaults_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 1 0 42
newtype Echo msg = Echo (Maybe (U'.Cap msg))
instance C'.IsPtr msg (Echo msg) where
    fromPtr msg cap = Echo <$> C'.fromPtr msg cap
    toPtr msg (Echo Nothing) = pure Nothing
    toPtr msg (Echo (Just cap)) = pure $ Just $ U'.PtrCap cap
newtype EchoBase msg = EchoBase_newtype_ (U'.Struct msg)
instance U'.TraverseMsg EchoBase where
    tMsg f (EchoBase_newtype_ s) = EchoBase_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (EchoBase msg) where
    fromStruct = pure . EchoBase_newtype_
instance C'.ToStruct msg (EchoBase msg) where
    toStruct (EchoBase_newtype_ struct) = struct
instance U'.HasMessage (EchoBase msg) where
    type InMessage (EchoBase msg) = msg
    message (EchoBase_newtype_ struct) = U'.message struct
instance U'.MessageDefault (EchoBase msg) where
    messageDefault = EchoBase_newtype_ . U'.messageDefault
instance B'.ListElem msg (EchoBase msg) where
    newtype List msg (EchoBase msg) = List_EchoBase (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_EchoBase <$> C'.fromPtr msg ptr
    toUntypedList (List_EchoBase l) = U'.ListStruct l
    length (List_EchoBase l) = U'.length l
    index i (List_EchoBase l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (EchoBase msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (EchoBase msg) where
    fromPtr msg ptr = EchoBase_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (EchoBase_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (EchoBase (M'.MutMsg s)) where
    setIndex (EchoBase_newtype_ elt) i (List_EchoBase l) = U'.setIndex elt i l
    newList msg len = List_EchoBase <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (EchoBase (M'.MutMsg s)) where
    new msg = EchoBase_newtype_ <$> U'.allocStruct msg 0 1
get_EchoBase'echo :: U'.ReadCtx m msg => EchoBase msg -> m (Echo msg)
get_EchoBase'echo (EchoBase_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_EchoBase'echo :: U'.ReadCtx m msg => EchoBase msg -> m Bool
has_EchoBase'echo(EchoBase_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_EchoBase'echo :: U'.RWCtx m s => EchoBase (M'.MutMsg s) -> (Echo (M'.MutMsg s)) -> m ()
set_EchoBase'echo (EchoBase_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
newtype EchoBases msg = EchoBases_newtype_ (U'.Struct msg)
instance U'.TraverseMsg EchoBases where
    tMsg f (EchoBases_newtype_ s) = EchoBases_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (EchoBases msg) where
    fromStruct = pure . EchoBases_newtype_
instance C'.ToStruct msg (EchoBases msg) where
    toStruct (EchoBases_newtype_ struct) = struct
instance U'.HasMessage (EchoBases msg) where
    type InMessage (EchoBases msg) = msg
    message (EchoBases_newtype_ struct) = U'.message struct
instance U'.MessageDefault (EchoBases msg) where
    messageDefault = EchoBases_newtype_ . U'.messageDefault
instance B'.ListElem msg (EchoBases msg) where
    newtype List msg (EchoBases msg) = List_EchoBases (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_EchoBases <$> C'.fromPtr msg ptr
    toUntypedList (List_EchoBases l) = U'.ListStruct l
    length (List_EchoBases l) = U'.length l
    index i (List_EchoBases l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (EchoBases msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (EchoBases msg) where
    fromPtr msg ptr = EchoBases_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (EchoBases_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (EchoBases (M'.MutMsg s)) where
    setIndex (EchoBases_newtype_ elt) i (List_EchoBases l) = U'.setIndex elt i l
    newList msg len = List_EchoBases <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (EchoBases (M'.MutMsg s)) where
    new msg = EchoBases_newtype_ <$> U'.allocStruct msg 0 1
get_EchoBases'bases :: U'.ReadCtx m msg => EchoBases msg -> m (B'.List msg (EchoBase msg))
get_EchoBases'bases (EchoBases_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_EchoBases'bases :: U'.ReadCtx m msg => EchoBases msg -> m Bool
has_EchoBases'bases(EchoBases_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_EchoBases'bases :: U'.RWCtx m s => EchoBases (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (EchoBase (M'.MutMsg s))) -> m ()
set_EchoBases'bases (EchoBases_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_EchoBases'bases :: U'.RWCtx m s => Int -> EchoBases (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (EchoBase (M'.MutMsg s))))
new_EchoBases'bases len struct = do
    result <- C'.newList (U'.message struct) len
    set_EchoBases'bases struct result
    pure result
newtype F16 msg = F16_newtype_ (U'.Struct msg)
instance U'.TraverseMsg F16 where
    tMsg f (F16_newtype_ s) = F16_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (F16 msg) where
    fromStruct = pure . F16_newtype_
instance C'.ToStruct msg (F16 msg) where
    toStruct (F16_newtype_ struct) = struct
instance U'.HasMessage (F16 msg) where
    type InMessage (F16 msg) = msg
    message (F16_newtype_ struct) = U'.message struct
instance U'.MessageDefault (F16 msg) where
    messageDefault = F16_newtype_ . U'.messageDefault
instance B'.ListElem msg (F16 msg) where
    newtype List msg (F16 msg) = List_F16 (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_F16 <$> C'.fromPtr msg ptr
    toUntypedList (List_F16 l) = U'.ListStruct l
    length (List_F16 l) = U'.length l
    index i (List_F16 l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (F16 msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (F16 msg) where
    fromPtr msg ptr = F16_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (F16_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (F16 (M'.MutMsg s)) where
    setIndex (F16_newtype_ elt) i (List_F16 l) = U'.setIndex elt i l
    newList msg len = List_F16 <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (F16 (M'.MutMsg s)) where
    new msg = F16_newtype_ <$> U'.allocStruct msg 0 1
get_F16'base :: U'.ReadCtx m msg => F16 msg -> m (PlaneBase msg)
get_F16'base (F16_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_F16'base :: U'.ReadCtx m msg => F16 msg -> m Bool
has_F16'base(F16_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_F16'base :: U'.RWCtx m s => F16 (M'.MutMsg s) -> (PlaneBase (M'.MutMsg s)) -> m ()
set_F16'base (F16_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_F16'base :: U'.RWCtx m s => F16 (M'.MutMsg s) -> m ((PlaneBase (M'.MutMsg s)))
new_F16'base struct = do
    result <- C'.new (U'.message struct)
    set_F16'base struct result
    pure result
newtype HoldsText msg = HoldsText_newtype_ (U'.Struct msg)
instance U'.TraverseMsg HoldsText where
    tMsg f (HoldsText_newtype_ s) = HoldsText_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (HoldsText msg) where
    fromStruct = pure . HoldsText_newtype_
instance C'.ToStruct msg (HoldsText msg) where
    toStruct (HoldsText_newtype_ struct) = struct
instance U'.HasMessage (HoldsText msg) where
    type InMessage (HoldsText msg) = msg
    message (HoldsText_newtype_ struct) = U'.message struct
instance U'.MessageDefault (HoldsText msg) where
    messageDefault = HoldsText_newtype_ . U'.messageDefault
instance B'.ListElem msg (HoldsText msg) where
    newtype List msg (HoldsText msg) = List_HoldsText (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_HoldsText <$> C'.fromPtr msg ptr
    toUntypedList (List_HoldsText l) = U'.ListStruct l
    length (List_HoldsText l) = U'.length l
    index i (List_HoldsText l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (HoldsText msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (HoldsText msg) where
    fromPtr msg ptr = HoldsText_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (HoldsText_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (HoldsText (M'.MutMsg s)) where
    setIndex (HoldsText_newtype_ elt) i (List_HoldsText l) = U'.setIndex elt i l
    newList msg len = List_HoldsText <$> U'.allocCompositeList msg 0 3 len
instance C'.Allocate s (HoldsText (M'.MutMsg s)) where
    new msg = HoldsText_newtype_ <$> U'.allocStruct msg 0 3
get_HoldsText'txt :: U'.ReadCtx m msg => HoldsText msg -> m (B'.Text msg)
get_HoldsText'txt (HoldsText_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_HoldsText'txt :: U'.ReadCtx m msg => HoldsText msg -> m Bool
has_HoldsText'txt(HoldsText_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_HoldsText'txt :: U'.RWCtx m s => HoldsText (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_HoldsText'txt (HoldsText_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_HoldsText'txt :: U'.RWCtx m s => Int -> HoldsText (M'.MutMsg s) -> m ((B'.Text (M'.MutMsg s)))
new_HoldsText'txt len struct = do
    result <- B'.newText (U'.message struct) len
    set_HoldsText'txt struct result
    pure result
get_HoldsText'lst :: U'.ReadCtx m msg => HoldsText msg -> m (B'.List msg (B'.Text msg))
get_HoldsText'lst (HoldsText_newtype_ struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)
has_HoldsText'lst :: U'.ReadCtx m msg => HoldsText msg -> m Bool
has_HoldsText'lst(HoldsText_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
set_HoldsText'lst :: U'.RWCtx m s => HoldsText (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (B'.Text (M'.MutMsg s))) -> m ()
set_HoldsText'lst (HoldsText_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 1 struct
new_HoldsText'lst :: U'.RWCtx m s => Int -> HoldsText (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (B'.Text (M'.MutMsg s))))
new_HoldsText'lst len struct = do
    result <- C'.newList (U'.message struct) len
    set_HoldsText'lst struct result
    pure result
get_HoldsText'lstlst :: U'.ReadCtx m msg => HoldsText msg -> m (B'.List msg (B'.List msg (B'.Text msg)))
get_HoldsText'lstlst (HoldsText_newtype_ struct) =
    U'.getPtr 2 struct
    >>= C'.fromPtr (U'.message struct)
has_HoldsText'lstlst :: U'.ReadCtx m msg => HoldsText msg -> m Bool
has_HoldsText'lstlst(HoldsText_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 2 struct
set_HoldsText'lstlst :: U'.RWCtx m s => HoldsText (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (B'.List (M'.MutMsg s) (B'.Text (M'.MutMsg s)))) -> m ()
set_HoldsText'lstlst (HoldsText_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 2 struct
new_HoldsText'lstlst :: U'.RWCtx m s => Int -> HoldsText (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (B'.List (M'.MutMsg s) (B'.Text (M'.MutMsg s)))))
new_HoldsText'lstlst len struct = do
    result <- C'.newList (U'.message struct) len
    set_HoldsText'lstlst struct result
    pure result
newtype HoldsVerEmptyList msg = HoldsVerEmptyList_newtype_ (U'.Struct msg)
instance U'.TraverseMsg HoldsVerEmptyList where
    tMsg f (HoldsVerEmptyList_newtype_ s) = HoldsVerEmptyList_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (HoldsVerEmptyList msg) where
    fromStruct = pure . HoldsVerEmptyList_newtype_
instance C'.ToStruct msg (HoldsVerEmptyList msg) where
    toStruct (HoldsVerEmptyList_newtype_ struct) = struct
instance U'.HasMessage (HoldsVerEmptyList msg) where
    type InMessage (HoldsVerEmptyList msg) = msg
    message (HoldsVerEmptyList_newtype_ struct) = U'.message struct
instance U'.MessageDefault (HoldsVerEmptyList msg) where
    messageDefault = HoldsVerEmptyList_newtype_ . U'.messageDefault
instance B'.ListElem msg (HoldsVerEmptyList msg) where
    newtype List msg (HoldsVerEmptyList msg) = List_HoldsVerEmptyList (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_HoldsVerEmptyList <$> C'.fromPtr msg ptr
    toUntypedList (List_HoldsVerEmptyList l) = U'.ListStruct l
    length (List_HoldsVerEmptyList l) = U'.length l
    index i (List_HoldsVerEmptyList l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (HoldsVerEmptyList msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (HoldsVerEmptyList msg) where
    fromPtr msg ptr = HoldsVerEmptyList_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (HoldsVerEmptyList_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (HoldsVerEmptyList (M'.MutMsg s)) where
    setIndex (HoldsVerEmptyList_newtype_ elt) i (List_HoldsVerEmptyList l) = U'.setIndex elt i l
    newList msg len = List_HoldsVerEmptyList <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (HoldsVerEmptyList (M'.MutMsg s)) where
    new msg = HoldsVerEmptyList_newtype_ <$> U'.allocStruct msg 0 1
get_HoldsVerEmptyList'mylist :: U'.ReadCtx m msg => HoldsVerEmptyList msg -> m (B'.List msg (VerEmpty msg))
get_HoldsVerEmptyList'mylist (HoldsVerEmptyList_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_HoldsVerEmptyList'mylist :: U'.ReadCtx m msg => HoldsVerEmptyList msg -> m Bool
has_HoldsVerEmptyList'mylist(HoldsVerEmptyList_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_HoldsVerEmptyList'mylist :: U'.RWCtx m s => HoldsVerEmptyList (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (VerEmpty (M'.MutMsg s))) -> m ()
set_HoldsVerEmptyList'mylist (HoldsVerEmptyList_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_HoldsVerEmptyList'mylist :: U'.RWCtx m s => Int -> HoldsVerEmptyList (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (VerEmpty (M'.MutMsg s))))
new_HoldsVerEmptyList'mylist len struct = do
    result <- C'.newList (U'.message struct) len
    set_HoldsVerEmptyList'mylist struct result
    pure result
newtype HoldsVerOneDataList msg = HoldsVerOneDataList_newtype_ (U'.Struct msg)
instance U'.TraverseMsg HoldsVerOneDataList where
    tMsg f (HoldsVerOneDataList_newtype_ s) = HoldsVerOneDataList_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (HoldsVerOneDataList msg) where
    fromStruct = pure . HoldsVerOneDataList_newtype_
instance C'.ToStruct msg (HoldsVerOneDataList msg) where
    toStruct (HoldsVerOneDataList_newtype_ struct) = struct
instance U'.HasMessage (HoldsVerOneDataList msg) where
    type InMessage (HoldsVerOneDataList msg) = msg
    message (HoldsVerOneDataList_newtype_ struct) = U'.message struct
instance U'.MessageDefault (HoldsVerOneDataList msg) where
    messageDefault = HoldsVerOneDataList_newtype_ . U'.messageDefault
instance B'.ListElem msg (HoldsVerOneDataList msg) where
    newtype List msg (HoldsVerOneDataList msg) = List_HoldsVerOneDataList (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_HoldsVerOneDataList <$> C'.fromPtr msg ptr
    toUntypedList (List_HoldsVerOneDataList l) = U'.ListStruct l
    length (List_HoldsVerOneDataList l) = U'.length l
    index i (List_HoldsVerOneDataList l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (HoldsVerOneDataList msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (HoldsVerOneDataList msg) where
    fromPtr msg ptr = HoldsVerOneDataList_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (HoldsVerOneDataList_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (HoldsVerOneDataList (M'.MutMsg s)) where
    setIndex (HoldsVerOneDataList_newtype_ elt) i (List_HoldsVerOneDataList l) = U'.setIndex elt i l
    newList msg len = List_HoldsVerOneDataList <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (HoldsVerOneDataList (M'.MutMsg s)) where
    new msg = HoldsVerOneDataList_newtype_ <$> U'.allocStruct msg 0 1
get_HoldsVerOneDataList'mylist :: U'.ReadCtx m msg => HoldsVerOneDataList msg -> m (B'.List msg (VerOneData msg))
get_HoldsVerOneDataList'mylist (HoldsVerOneDataList_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_HoldsVerOneDataList'mylist :: U'.ReadCtx m msg => HoldsVerOneDataList msg -> m Bool
has_HoldsVerOneDataList'mylist(HoldsVerOneDataList_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_HoldsVerOneDataList'mylist :: U'.RWCtx m s => HoldsVerOneDataList (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (VerOneData (M'.MutMsg s))) -> m ()
set_HoldsVerOneDataList'mylist (HoldsVerOneDataList_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_HoldsVerOneDataList'mylist :: U'.RWCtx m s => Int -> HoldsVerOneDataList (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (VerOneData (M'.MutMsg s))))
new_HoldsVerOneDataList'mylist len struct = do
    result <- C'.newList (U'.message struct) len
    set_HoldsVerOneDataList'mylist struct result
    pure result
newtype HoldsVerOnePtrList msg = HoldsVerOnePtrList_newtype_ (U'.Struct msg)
instance U'.TraverseMsg HoldsVerOnePtrList where
    tMsg f (HoldsVerOnePtrList_newtype_ s) = HoldsVerOnePtrList_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (HoldsVerOnePtrList msg) where
    fromStruct = pure . HoldsVerOnePtrList_newtype_
instance C'.ToStruct msg (HoldsVerOnePtrList msg) where
    toStruct (HoldsVerOnePtrList_newtype_ struct) = struct
instance U'.HasMessage (HoldsVerOnePtrList msg) where
    type InMessage (HoldsVerOnePtrList msg) = msg
    message (HoldsVerOnePtrList_newtype_ struct) = U'.message struct
instance U'.MessageDefault (HoldsVerOnePtrList msg) where
    messageDefault = HoldsVerOnePtrList_newtype_ . U'.messageDefault
instance B'.ListElem msg (HoldsVerOnePtrList msg) where
    newtype List msg (HoldsVerOnePtrList msg) = List_HoldsVerOnePtrList (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_HoldsVerOnePtrList <$> C'.fromPtr msg ptr
    toUntypedList (List_HoldsVerOnePtrList l) = U'.ListStruct l
    length (List_HoldsVerOnePtrList l) = U'.length l
    index i (List_HoldsVerOnePtrList l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (HoldsVerOnePtrList msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (HoldsVerOnePtrList msg) where
    fromPtr msg ptr = HoldsVerOnePtrList_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (HoldsVerOnePtrList_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (HoldsVerOnePtrList (M'.MutMsg s)) where
    setIndex (HoldsVerOnePtrList_newtype_ elt) i (List_HoldsVerOnePtrList l) = U'.setIndex elt i l
    newList msg len = List_HoldsVerOnePtrList <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (HoldsVerOnePtrList (M'.MutMsg s)) where
    new msg = HoldsVerOnePtrList_newtype_ <$> U'.allocStruct msg 0 1
get_HoldsVerOnePtrList'mylist :: U'.ReadCtx m msg => HoldsVerOnePtrList msg -> m (B'.List msg (VerOnePtr msg))
get_HoldsVerOnePtrList'mylist (HoldsVerOnePtrList_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_HoldsVerOnePtrList'mylist :: U'.ReadCtx m msg => HoldsVerOnePtrList msg -> m Bool
has_HoldsVerOnePtrList'mylist(HoldsVerOnePtrList_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_HoldsVerOnePtrList'mylist :: U'.RWCtx m s => HoldsVerOnePtrList (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (VerOnePtr (M'.MutMsg s))) -> m ()
set_HoldsVerOnePtrList'mylist (HoldsVerOnePtrList_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_HoldsVerOnePtrList'mylist :: U'.RWCtx m s => Int -> HoldsVerOnePtrList (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (VerOnePtr (M'.MutMsg s))))
new_HoldsVerOnePtrList'mylist len struct = do
    result <- C'.newList (U'.message struct) len
    set_HoldsVerOnePtrList'mylist struct result
    pure result
newtype HoldsVerTwoDataList msg = HoldsVerTwoDataList_newtype_ (U'.Struct msg)
instance U'.TraverseMsg HoldsVerTwoDataList where
    tMsg f (HoldsVerTwoDataList_newtype_ s) = HoldsVerTwoDataList_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (HoldsVerTwoDataList msg) where
    fromStruct = pure . HoldsVerTwoDataList_newtype_
instance C'.ToStruct msg (HoldsVerTwoDataList msg) where
    toStruct (HoldsVerTwoDataList_newtype_ struct) = struct
instance U'.HasMessage (HoldsVerTwoDataList msg) where
    type InMessage (HoldsVerTwoDataList msg) = msg
    message (HoldsVerTwoDataList_newtype_ struct) = U'.message struct
instance U'.MessageDefault (HoldsVerTwoDataList msg) where
    messageDefault = HoldsVerTwoDataList_newtype_ . U'.messageDefault
instance B'.ListElem msg (HoldsVerTwoDataList msg) where
    newtype List msg (HoldsVerTwoDataList msg) = List_HoldsVerTwoDataList (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_HoldsVerTwoDataList <$> C'.fromPtr msg ptr
    toUntypedList (List_HoldsVerTwoDataList l) = U'.ListStruct l
    length (List_HoldsVerTwoDataList l) = U'.length l
    index i (List_HoldsVerTwoDataList l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (HoldsVerTwoDataList msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (HoldsVerTwoDataList msg) where
    fromPtr msg ptr = HoldsVerTwoDataList_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (HoldsVerTwoDataList_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (HoldsVerTwoDataList (M'.MutMsg s)) where
    setIndex (HoldsVerTwoDataList_newtype_ elt) i (List_HoldsVerTwoDataList l) = U'.setIndex elt i l
    newList msg len = List_HoldsVerTwoDataList <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (HoldsVerTwoDataList (M'.MutMsg s)) where
    new msg = HoldsVerTwoDataList_newtype_ <$> U'.allocStruct msg 0 1
get_HoldsVerTwoDataList'mylist :: U'.ReadCtx m msg => HoldsVerTwoDataList msg -> m (B'.List msg (VerTwoData msg))
get_HoldsVerTwoDataList'mylist (HoldsVerTwoDataList_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_HoldsVerTwoDataList'mylist :: U'.ReadCtx m msg => HoldsVerTwoDataList msg -> m Bool
has_HoldsVerTwoDataList'mylist(HoldsVerTwoDataList_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_HoldsVerTwoDataList'mylist :: U'.RWCtx m s => HoldsVerTwoDataList (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (VerTwoData (M'.MutMsg s))) -> m ()
set_HoldsVerTwoDataList'mylist (HoldsVerTwoDataList_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_HoldsVerTwoDataList'mylist :: U'.RWCtx m s => Int -> HoldsVerTwoDataList (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (VerTwoData (M'.MutMsg s))))
new_HoldsVerTwoDataList'mylist len struct = do
    result <- C'.newList (U'.message struct) len
    set_HoldsVerTwoDataList'mylist struct result
    pure result
newtype HoldsVerTwoPtrList msg = HoldsVerTwoPtrList_newtype_ (U'.Struct msg)
instance U'.TraverseMsg HoldsVerTwoPtrList where
    tMsg f (HoldsVerTwoPtrList_newtype_ s) = HoldsVerTwoPtrList_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (HoldsVerTwoPtrList msg) where
    fromStruct = pure . HoldsVerTwoPtrList_newtype_
instance C'.ToStruct msg (HoldsVerTwoPtrList msg) where
    toStruct (HoldsVerTwoPtrList_newtype_ struct) = struct
instance U'.HasMessage (HoldsVerTwoPtrList msg) where
    type InMessage (HoldsVerTwoPtrList msg) = msg
    message (HoldsVerTwoPtrList_newtype_ struct) = U'.message struct
instance U'.MessageDefault (HoldsVerTwoPtrList msg) where
    messageDefault = HoldsVerTwoPtrList_newtype_ . U'.messageDefault
instance B'.ListElem msg (HoldsVerTwoPtrList msg) where
    newtype List msg (HoldsVerTwoPtrList msg) = List_HoldsVerTwoPtrList (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_HoldsVerTwoPtrList <$> C'.fromPtr msg ptr
    toUntypedList (List_HoldsVerTwoPtrList l) = U'.ListStruct l
    length (List_HoldsVerTwoPtrList l) = U'.length l
    index i (List_HoldsVerTwoPtrList l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (HoldsVerTwoPtrList msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (HoldsVerTwoPtrList msg) where
    fromPtr msg ptr = HoldsVerTwoPtrList_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (HoldsVerTwoPtrList_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (HoldsVerTwoPtrList (M'.MutMsg s)) where
    setIndex (HoldsVerTwoPtrList_newtype_ elt) i (List_HoldsVerTwoPtrList l) = U'.setIndex elt i l
    newList msg len = List_HoldsVerTwoPtrList <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (HoldsVerTwoPtrList (M'.MutMsg s)) where
    new msg = HoldsVerTwoPtrList_newtype_ <$> U'.allocStruct msg 0 1
get_HoldsVerTwoPtrList'mylist :: U'.ReadCtx m msg => HoldsVerTwoPtrList msg -> m (B'.List msg (VerTwoPtr msg))
get_HoldsVerTwoPtrList'mylist (HoldsVerTwoPtrList_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_HoldsVerTwoPtrList'mylist :: U'.ReadCtx m msg => HoldsVerTwoPtrList msg -> m Bool
has_HoldsVerTwoPtrList'mylist(HoldsVerTwoPtrList_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_HoldsVerTwoPtrList'mylist :: U'.RWCtx m s => HoldsVerTwoPtrList (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (VerTwoPtr (M'.MutMsg s))) -> m ()
set_HoldsVerTwoPtrList'mylist (HoldsVerTwoPtrList_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_HoldsVerTwoPtrList'mylist :: U'.RWCtx m s => Int -> HoldsVerTwoPtrList (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (VerTwoPtr (M'.MutMsg s))))
new_HoldsVerTwoPtrList'mylist len struct = do
    result <- C'.newList (U'.message struct) len
    set_HoldsVerTwoPtrList'mylist struct result
    pure result
newtype HoldsVerTwoTwoList msg = HoldsVerTwoTwoList_newtype_ (U'.Struct msg)
instance U'.TraverseMsg HoldsVerTwoTwoList where
    tMsg f (HoldsVerTwoTwoList_newtype_ s) = HoldsVerTwoTwoList_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (HoldsVerTwoTwoList msg) where
    fromStruct = pure . HoldsVerTwoTwoList_newtype_
instance C'.ToStruct msg (HoldsVerTwoTwoList msg) where
    toStruct (HoldsVerTwoTwoList_newtype_ struct) = struct
instance U'.HasMessage (HoldsVerTwoTwoList msg) where
    type InMessage (HoldsVerTwoTwoList msg) = msg
    message (HoldsVerTwoTwoList_newtype_ struct) = U'.message struct
instance U'.MessageDefault (HoldsVerTwoTwoList msg) where
    messageDefault = HoldsVerTwoTwoList_newtype_ . U'.messageDefault
instance B'.ListElem msg (HoldsVerTwoTwoList msg) where
    newtype List msg (HoldsVerTwoTwoList msg) = List_HoldsVerTwoTwoList (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_HoldsVerTwoTwoList <$> C'.fromPtr msg ptr
    toUntypedList (List_HoldsVerTwoTwoList l) = U'.ListStruct l
    length (List_HoldsVerTwoTwoList l) = U'.length l
    index i (List_HoldsVerTwoTwoList l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (HoldsVerTwoTwoList msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (HoldsVerTwoTwoList msg) where
    fromPtr msg ptr = HoldsVerTwoTwoList_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (HoldsVerTwoTwoList_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (HoldsVerTwoTwoList (M'.MutMsg s)) where
    setIndex (HoldsVerTwoTwoList_newtype_ elt) i (List_HoldsVerTwoTwoList l) = U'.setIndex elt i l
    newList msg len = List_HoldsVerTwoTwoList <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (HoldsVerTwoTwoList (M'.MutMsg s)) where
    new msg = HoldsVerTwoTwoList_newtype_ <$> U'.allocStruct msg 0 1
get_HoldsVerTwoTwoList'mylist :: U'.ReadCtx m msg => HoldsVerTwoTwoList msg -> m (B'.List msg (VerTwoDataTwoPtr msg))
get_HoldsVerTwoTwoList'mylist (HoldsVerTwoTwoList_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_HoldsVerTwoTwoList'mylist :: U'.ReadCtx m msg => HoldsVerTwoTwoList msg -> m Bool
has_HoldsVerTwoTwoList'mylist(HoldsVerTwoTwoList_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_HoldsVerTwoTwoList'mylist :: U'.RWCtx m s => HoldsVerTwoTwoList (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (VerTwoDataTwoPtr (M'.MutMsg s))) -> m ()
set_HoldsVerTwoTwoList'mylist (HoldsVerTwoTwoList_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_HoldsVerTwoTwoList'mylist :: U'.RWCtx m s => Int -> HoldsVerTwoTwoList (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (VerTwoDataTwoPtr (M'.MutMsg s))))
new_HoldsVerTwoTwoList'mylist len struct = do
    result <- C'.newList (U'.message struct) len
    set_HoldsVerTwoTwoList'mylist struct result
    pure result
newtype HoldsVerTwoTwoPlus msg = HoldsVerTwoTwoPlus_newtype_ (U'.Struct msg)
instance U'.TraverseMsg HoldsVerTwoTwoPlus where
    tMsg f (HoldsVerTwoTwoPlus_newtype_ s) = HoldsVerTwoTwoPlus_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (HoldsVerTwoTwoPlus msg) where
    fromStruct = pure . HoldsVerTwoTwoPlus_newtype_
instance C'.ToStruct msg (HoldsVerTwoTwoPlus msg) where
    toStruct (HoldsVerTwoTwoPlus_newtype_ struct) = struct
instance U'.HasMessage (HoldsVerTwoTwoPlus msg) where
    type InMessage (HoldsVerTwoTwoPlus msg) = msg
    message (HoldsVerTwoTwoPlus_newtype_ struct) = U'.message struct
instance U'.MessageDefault (HoldsVerTwoTwoPlus msg) where
    messageDefault = HoldsVerTwoTwoPlus_newtype_ . U'.messageDefault
instance B'.ListElem msg (HoldsVerTwoTwoPlus msg) where
    newtype List msg (HoldsVerTwoTwoPlus msg) = List_HoldsVerTwoTwoPlus (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_HoldsVerTwoTwoPlus <$> C'.fromPtr msg ptr
    toUntypedList (List_HoldsVerTwoTwoPlus l) = U'.ListStruct l
    length (List_HoldsVerTwoTwoPlus l) = U'.length l
    index i (List_HoldsVerTwoTwoPlus l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (HoldsVerTwoTwoPlus msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (HoldsVerTwoTwoPlus msg) where
    fromPtr msg ptr = HoldsVerTwoTwoPlus_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (HoldsVerTwoTwoPlus_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (HoldsVerTwoTwoPlus (M'.MutMsg s)) where
    setIndex (HoldsVerTwoTwoPlus_newtype_ elt) i (List_HoldsVerTwoTwoPlus l) = U'.setIndex elt i l
    newList msg len = List_HoldsVerTwoTwoPlus <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (HoldsVerTwoTwoPlus (M'.MutMsg s)) where
    new msg = HoldsVerTwoTwoPlus_newtype_ <$> U'.allocStruct msg 0 1
get_HoldsVerTwoTwoPlus'mylist :: U'.ReadCtx m msg => HoldsVerTwoTwoPlus msg -> m (B'.List msg (VerTwoTwoPlus msg))
get_HoldsVerTwoTwoPlus'mylist (HoldsVerTwoTwoPlus_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_HoldsVerTwoTwoPlus'mylist :: U'.ReadCtx m msg => HoldsVerTwoTwoPlus msg -> m Bool
has_HoldsVerTwoTwoPlus'mylist(HoldsVerTwoTwoPlus_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_HoldsVerTwoTwoPlus'mylist :: U'.RWCtx m s => HoldsVerTwoTwoPlus (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (VerTwoTwoPlus (M'.MutMsg s))) -> m ()
set_HoldsVerTwoTwoPlus'mylist (HoldsVerTwoTwoPlus_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_HoldsVerTwoTwoPlus'mylist :: U'.RWCtx m s => Int -> HoldsVerTwoTwoPlus (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (VerTwoTwoPlus (M'.MutMsg s))))
new_HoldsVerTwoTwoPlus'mylist len struct = do
    result <- C'.newList (U'.message struct) len
    set_HoldsVerTwoTwoPlus'mylist struct result
    pure result
newtype Hoth msg = Hoth_newtype_ (U'.Struct msg)
instance U'.TraverseMsg Hoth where
    tMsg f (Hoth_newtype_ s) = Hoth_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (Hoth msg) where
    fromStruct = pure . Hoth_newtype_
instance C'.ToStruct msg (Hoth msg) where
    toStruct (Hoth_newtype_ struct) = struct
instance U'.HasMessage (Hoth msg) where
    type InMessage (Hoth msg) = msg
    message (Hoth_newtype_ struct) = U'.message struct
instance U'.MessageDefault (Hoth msg) where
    messageDefault = Hoth_newtype_ . U'.messageDefault
instance B'.ListElem msg (Hoth msg) where
    newtype List msg (Hoth msg) = List_Hoth (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_Hoth <$> C'.fromPtr msg ptr
    toUntypedList (List_Hoth l) = U'.ListStruct l
    length (List_Hoth l) = U'.length l
    index i (List_Hoth l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Hoth msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (Hoth msg) where
    fromPtr msg ptr = Hoth_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (Hoth_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (Hoth (M'.MutMsg s)) where
    setIndex (Hoth_newtype_ elt) i (List_Hoth l) = U'.setIndex elt i l
    newList msg len = List_Hoth <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (Hoth (M'.MutMsg s)) where
    new msg = Hoth_newtype_ <$> U'.allocStruct msg 0 1
get_Hoth'base :: U'.ReadCtx m msg => Hoth msg -> m (EchoBase msg)
get_Hoth'base (Hoth_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_Hoth'base :: U'.ReadCtx m msg => Hoth msg -> m Bool
has_Hoth'base(Hoth_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_Hoth'base :: U'.RWCtx m s => Hoth (M'.MutMsg s) -> (EchoBase (M'.MutMsg s)) -> m ()
set_Hoth'base (Hoth_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Hoth'base :: U'.RWCtx m s => Hoth (M'.MutMsg s) -> m ((EchoBase (M'.MutMsg s)))
new_Hoth'base struct = do
    result <- C'.new (U'.message struct)
    set_Hoth'base struct result
    pure result
newtype ListStructCapn msg = ListStructCapn_newtype_ (U'.Struct msg)
instance U'.TraverseMsg ListStructCapn where
    tMsg f (ListStructCapn_newtype_ s) = ListStructCapn_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (ListStructCapn msg) where
    fromStruct = pure . ListStructCapn_newtype_
instance C'.ToStruct msg (ListStructCapn msg) where
    toStruct (ListStructCapn_newtype_ struct) = struct
instance U'.HasMessage (ListStructCapn msg) where
    type InMessage (ListStructCapn msg) = msg
    message (ListStructCapn_newtype_ struct) = U'.message struct
instance U'.MessageDefault (ListStructCapn msg) where
    messageDefault = ListStructCapn_newtype_ . U'.messageDefault
instance B'.ListElem msg (ListStructCapn msg) where
    newtype List msg (ListStructCapn msg) = List_ListStructCapn (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_ListStructCapn <$> C'.fromPtr msg ptr
    toUntypedList (List_ListStructCapn l) = U'.ListStruct l
    length (List_ListStructCapn l) = U'.length l
    index i (List_ListStructCapn l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (ListStructCapn msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (ListStructCapn msg) where
    fromPtr msg ptr = ListStructCapn_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (ListStructCapn_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (ListStructCapn (M'.MutMsg s)) where
    setIndex (ListStructCapn_newtype_ elt) i (List_ListStructCapn l) = U'.setIndex elt i l
    newList msg len = List_ListStructCapn <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (ListStructCapn (M'.MutMsg s)) where
    new msg = ListStructCapn_newtype_ <$> U'.allocStruct msg 0 1
get_ListStructCapn'vec :: U'.ReadCtx m msg => ListStructCapn msg -> m (B'.List msg (Nester1Capn msg))
get_ListStructCapn'vec (ListStructCapn_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_ListStructCapn'vec :: U'.ReadCtx m msg => ListStructCapn msg -> m Bool
has_ListStructCapn'vec(ListStructCapn_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_ListStructCapn'vec :: U'.RWCtx m s => ListStructCapn (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (Nester1Capn (M'.MutMsg s))) -> m ()
set_ListStructCapn'vec (ListStructCapn_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_ListStructCapn'vec :: U'.RWCtx m s => Int -> ListStructCapn (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (Nester1Capn (M'.MutMsg s))))
new_ListStructCapn'vec len struct = do
    result <- C'.newList (U'.message struct) len
    set_ListStructCapn'vec struct result
    pure result
newtype Nester1Capn msg = Nester1Capn_newtype_ (U'.Struct msg)
instance U'.TraverseMsg Nester1Capn where
    tMsg f (Nester1Capn_newtype_ s) = Nester1Capn_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (Nester1Capn msg) where
    fromStruct = pure . Nester1Capn_newtype_
instance C'.ToStruct msg (Nester1Capn msg) where
    toStruct (Nester1Capn_newtype_ struct) = struct
instance U'.HasMessage (Nester1Capn msg) where
    type InMessage (Nester1Capn msg) = msg
    message (Nester1Capn_newtype_ struct) = U'.message struct
instance U'.MessageDefault (Nester1Capn msg) where
    messageDefault = Nester1Capn_newtype_ . U'.messageDefault
instance B'.ListElem msg (Nester1Capn msg) where
    newtype List msg (Nester1Capn msg) = List_Nester1Capn (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_Nester1Capn <$> C'.fromPtr msg ptr
    toUntypedList (List_Nester1Capn l) = U'.ListStruct l
    length (List_Nester1Capn l) = U'.length l
    index i (List_Nester1Capn l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Nester1Capn msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (Nester1Capn msg) where
    fromPtr msg ptr = Nester1Capn_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (Nester1Capn_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (Nester1Capn (M'.MutMsg s)) where
    setIndex (Nester1Capn_newtype_ elt) i (List_Nester1Capn l) = U'.setIndex elt i l
    newList msg len = List_Nester1Capn <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (Nester1Capn (M'.MutMsg s)) where
    new msg = Nester1Capn_newtype_ <$> U'.allocStruct msg 0 1
get_Nester1Capn'strs :: U'.ReadCtx m msg => Nester1Capn msg -> m (B'.List msg (B'.Text msg))
get_Nester1Capn'strs (Nester1Capn_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_Nester1Capn'strs :: U'.ReadCtx m msg => Nester1Capn msg -> m Bool
has_Nester1Capn'strs(Nester1Capn_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_Nester1Capn'strs :: U'.RWCtx m s => Nester1Capn (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (B'.Text (M'.MutMsg s))) -> m ()
set_Nester1Capn'strs (Nester1Capn_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Nester1Capn'strs :: U'.RWCtx m s => Int -> Nester1Capn (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (B'.Text (M'.MutMsg s))))
new_Nester1Capn'strs len struct = do
    result <- C'.newList (U'.message struct) len
    set_Nester1Capn'strs struct result
    pure result
newtype PlaneBase msg = PlaneBase_newtype_ (U'.Struct msg)
instance U'.TraverseMsg PlaneBase where
    tMsg f (PlaneBase_newtype_ s) = PlaneBase_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (PlaneBase msg) where
    fromStruct = pure . PlaneBase_newtype_
instance C'.ToStruct msg (PlaneBase msg) where
    toStruct (PlaneBase_newtype_ struct) = struct
instance U'.HasMessage (PlaneBase msg) where
    type InMessage (PlaneBase msg) = msg
    message (PlaneBase_newtype_ struct) = U'.message struct
instance U'.MessageDefault (PlaneBase msg) where
    messageDefault = PlaneBase_newtype_ . U'.messageDefault
instance B'.ListElem msg (PlaneBase msg) where
    newtype List msg (PlaneBase msg) = List_PlaneBase (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_PlaneBase <$> C'.fromPtr msg ptr
    toUntypedList (List_PlaneBase l) = U'.ListStruct l
    length (List_PlaneBase l) = U'.length l
    index i (List_PlaneBase l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (PlaneBase msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (PlaneBase msg) where
    fromPtr msg ptr = PlaneBase_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (PlaneBase_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (PlaneBase (M'.MutMsg s)) where
    setIndex (PlaneBase_newtype_ elt) i (List_PlaneBase l) = U'.setIndex elt i l
    newList msg len = List_PlaneBase <$> U'.allocCompositeList msg 4 2 len
instance C'.Allocate s (PlaneBase (M'.MutMsg s)) where
    new msg = PlaneBase_newtype_ <$> U'.allocStruct msg 4 2
get_PlaneBase'name :: U'.ReadCtx m msg => PlaneBase msg -> m (B'.Text msg)
get_PlaneBase'name (PlaneBase_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_PlaneBase'name :: U'.ReadCtx m msg => PlaneBase msg -> m Bool
has_PlaneBase'name(PlaneBase_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_PlaneBase'name :: U'.RWCtx m s => PlaneBase (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_PlaneBase'name (PlaneBase_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_PlaneBase'name :: U'.RWCtx m s => Int -> PlaneBase (M'.MutMsg s) -> m ((B'.Text (M'.MutMsg s)))
new_PlaneBase'name len struct = do
    result <- B'.newText (U'.message struct) len
    set_PlaneBase'name struct result
    pure result
get_PlaneBase'homes :: U'.ReadCtx m msg => PlaneBase msg -> m (B'.List msg Airport)
get_PlaneBase'homes (PlaneBase_newtype_ struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)
has_PlaneBase'homes :: U'.ReadCtx m msg => PlaneBase msg -> m Bool
has_PlaneBase'homes(PlaneBase_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
set_PlaneBase'homes :: U'.RWCtx m s => PlaneBase (M'.MutMsg s) -> (B'.List (M'.MutMsg s) Airport) -> m ()
set_PlaneBase'homes (PlaneBase_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 1 struct
new_PlaneBase'homes :: U'.RWCtx m s => Int -> PlaneBase (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) Airport))
new_PlaneBase'homes len struct = do
    result <- C'.newList (U'.message struct) len
    set_PlaneBase'homes struct result
    pure result
get_PlaneBase'rating :: U'.ReadCtx m msg => PlaneBase msg -> m Int64
get_PlaneBase'rating (PlaneBase_newtype_ struct) = H'.getWordField struct 0 0 0
set_PlaneBase'rating :: U'.RWCtx m s => PlaneBase (M'.MutMsg s) -> Int64 -> m ()
set_PlaneBase'rating (PlaneBase_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 0 0 0
get_PlaneBase'canFly :: U'.ReadCtx m msg => PlaneBase msg -> m Bool
get_PlaneBase'canFly (PlaneBase_newtype_ struct) = H'.getWordField struct 1 0 0
set_PlaneBase'canFly :: U'.RWCtx m s => PlaneBase (M'.MutMsg s) -> Bool -> m ()
set_PlaneBase'canFly (PlaneBase_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word1) 1 0 0
get_PlaneBase'capacity :: U'.ReadCtx m msg => PlaneBase msg -> m Int64
get_PlaneBase'capacity (PlaneBase_newtype_ struct) = H'.getWordField struct 2 0 0
set_PlaneBase'capacity :: U'.RWCtx m s => PlaneBase (M'.MutMsg s) -> Int64 -> m ()
set_PlaneBase'capacity (PlaneBase_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 2 0 0
get_PlaneBase'maxSpeed :: U'.ReadCtx m msg => PlaneBase msg -> m Double
get_PlaneBase'maxSpeed (PlaneBase_newtype_ struct) = H'.getWordField struct 3 0 0
set_PlaneBase'maxSpeed :: U'.RWCtx m s => PlaneBase (M'.MutMsg s) -> Double -> m ()
set_PlaneBase'maxSpeed (PlaneBase_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 3 0 0
newtype RWTestCapn msg = RWTestCapn_newtype_ (U'.Struct msg)
instance U'.TraverseMsg RWTestCapn where
    tMsg f (RWTestCapn_newtype_ s) = RWTestCapn_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (RWTestCapn msg) where
    fromStruct = pure . RWTestCapn_newtype_
instance C'.ToStruct msg (RWTestCapn msg) where
    toStruct (RWTestCapn_newtype_ struct) = struct
instance U'.HasMessage (RWTestCapn msg) where
    type InMessage (RWTestCapn msg) = msg
    message (RWTestCapn_newtype_ struct) = U'.message struct
instance U'.MessageDefault (RWTestCapn msg) where
    messageDefault = RWTestCapn_newtype_ . U'.messageDefault
instance B'.ListElem msg (RWTestCapn msg) where
    newtype List msg (RWTestCapn msg) = List_RWTestCapn (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_RWTestCapn <$> C'.fromPtr msg ptr
    toUntypedList (List_RWTestCapn l) = U'.ListStruct l
    length (List_RWTestCapn l) = U'.length l
    index i (List_RWTestCapn l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (RWTestCapn msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (RWTestCapn msg) where
    fromPtr msg ptr = RWTestCapn_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (RWTestCapn_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (RWTestCapn (M'.MutMsg s)) where
    setIndex (RWTestCapn_newtype_ elt) i (List_RWTestCapn l) = U'.setIndex elt i l
    newList msg len = List_RWTestCapn <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (RWTestCapn (M'.MutMsg s)) where
    new msg = RWTestCapn_newtype_ <$> U'.allocStruct msg 0 1
get_RWTestCapn'nestMatrix :: U'.ReadCtx m msg => RWTestCapn msg -> m (B'.List msg (B'.List msg (Nester1Capn msg)))
get_RWTestCapn'nestMatrix (RWTestCapn_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_RWTestCapn'nestMatrix :: U'.ReadCtx m msg => RWTestCapn msg -> m Bool
has_RWTestCapn'nestMatrix(RWTestCapn_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_RWTestCapn'nestMatrix :: U'.RWCtx m s => RWTestCapn (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (B'.List (M'.MutMsg s) (Nester1Capn (M'.MutMsg s)))) -> m ()
set_RWTestCapn'nestMatrix (RWTestCapn_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_RWTestCapn'nestMatrix :: U'.RWCtx m s => Int -> RWTestCapn (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (B'.List (M'.MutMsg s) (Nester1Capn (M'.MutMsg s)))))
new_RWTestCapn'nestMatrix len struct = do
    result <- C'.newList (U'.message struct) len
    set_RWTestCapn'nestMatrix struct result
    pure result
newtype Regression msg = Regression_newtype_ (U'.Struct msg)
instance U'.TraverseMsg Regression where
    tMsg f (Regression_newtype_ s) = Regression_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (Regression msg) where
    fromStruct = pure . Regression_newtype_
instance C'.ToStruct msg (Regression msg) where
    toStruct (Regression_newtype_ struct) = struct
instance U'.HasMessage (Regression msg) where
    type InMessage (Regression msg) = msg
    message (Regression_newtype_ struct) = U'.message struct
instance U'.MessageDefault (Regression msg) where
    messageDefault = Regression_newtype_ . U'.messageDefault
instance B'.ListElem msg (Regression msg) where
    newtype List msg (Regression msg) = List_Regression (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_Regression <$> C'.fromPtr msg ptr
    toUntypedList (List_Regression l) = U'.ListStruct l
    length (List_Regression l) = U'.length l
    index i (List_Regression l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Regression msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (Regression msg) where
    fromPtr msg ptr = Regression_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (Regression_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (Regression (M'.MutMsg s)) where
    setIndex (Regression_newtype_ elt) i (List_Regression l) = U'.setIndex elt i l
    newList msg len = List_Regression <$> U'.allocCompositeList msg 3 3 len
instance C'.Allocate s (Regression (M'.MutMsg s)) where
    new msg = Regression_newtype_ <$> U'.allocStruct msg 3 3
get_Regression'base :: U'.ReadCtx m msg => Regression msg -> m (PlaneBase msg)
get_Regression'base (Regression_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_Regression'base :: U'.ReadCtx m msg => Regression msg -> m Bool
has_Regression'base(Regression_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_Regression'base :: U'.RWCtx m s => Regression (M'.MutMsg s) -> (PlaneBase (M'.MutMsg s)) -> m ()
set_Regression'base (Regression_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Regression'base :: U'.RWCtx m s => Regression (M'.MutMsg s) -> m ((PlaneBase (M'.MutMsg s)))
new_Regression'base struct = do
    result <- C'.new (U'.message struct)
    set_Regression'base struct result
    pure result
get_Regression'b0 :: U'.ReadCtx m msg => Regression msg -> m Double
get_Regression'b0 (Regression_newtype_ struct) = H'.getWordField struct 0 0 0
set_Regression'b0 :: U'.RWCtx m s => Regression (M'.MutMsg s) -> Double -> m ()
set_Regression'b0 (Regression_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 0 0 0
get_Regression'beta :: U'.ReadCtx m msg => Regression msg -> m (B'.List msg Double)
get_Regression'beta (Regression_newtype_ struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)
has_Regression'beta :: U'.ReadCtx m msg => Regression msg -> m Bool
has_Regression'beta(Regression_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
set_Regression'beta :: U'.RWCtx m s => Regression (M'.MutMsg s) -> (B'.List (M'.MutMsg s) Double) -> m ()
set_Regression'beta (Regression_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 1 struct
new_Regression'beta :: U'.RWCtx m s => Int -> Regression (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) Double))
new_Regression'beta len struct = do
    result <- C'.newList (U'.message struct) len
    set_Regression'beta struct result
    pure result
get_Regression'planes :: U'.ReadCtx m msg => Regression msg -> m (B'.List msg (Aircraft msg))
get_Regression'planes (Regression_newtype_ struct) =
    U'.getPtr 2 struct
    >>= C'.fromPtr (U'.message struct)
has_Regression'planes :: U'.ReadCtx m msg => Regression msg -> m Bool
has_Regression'planes(Regression_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 2 struct
set_Regression'planes :: U'.RWCtx m s => Regression (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (Aircraft (M'.MutMsg s))) -> m ()
set_Regression'planes (Regression_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 2 struct
new_Regression'planes :: U'.RWCtx m s => Int -> Regression (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (Aircraft (M'.MutMsg s))))
new_Regression'planes len struct = do
    result <- C'.newList (U'.message struct) len
    set_Regression'planes struct result
    pure result
get_Regression'ymu :: U'.ReadCtx m msg => Regression msg -> m Double
get_Regression'ymu (Regression_newtype_ struct) = H'.getWordField struct 1 0 0
set_Regression'ymu :: U'.RWCtx m s => Regression (M'.MutMsg s) -> Double -> m ()
set_Regression'ymu (Regression_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 1 0 0
get_Regression'ysd :: U'.ReadCtx m msg => Regression msg -> m Double
get_Regression'ysd (Regression_newtype_ struct) = H'.getWordField struct 2 0 0
set_Regression'ysd :: U'.RWCtx m s => Regression (M'.MutMsg s) -> Double -> m ()
set_Regression'ysd (Regression_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 2 0 0
newtype StackingA msg = StackingA_newtype_ (U'.Struct msg)
instance U'.TraverseMsg StackingA where
    tMsg f (StackingA_newtype_ s) = StackingA_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (StackingA msg) where
    fromStruct = pure . StackingA_newtype_
instance C'.ToStruct msg (StackingA msg) where
    toStruct (StackingA_newtype_ struct) = struct
instance U'.HasMessage (StackingA msg) where
    type InMessage (StackingA msg) = msg
    message (StackingA_newtype_ struct) = U'.message struct
instance U'.MessageDefault (StackingA msg) where
    messageDefault = StackingA_newtype_ . U'.messageDefault
instance B'.ListElem msg (StackingA msg) where
    newtype List msg (StackingA msg) = List_StackingA (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_StackingA <$> C'.fromPtr msg ptr
    toUntypedList (List_StackingA l) = U'.ListStruct l
    length (List_StackingA l) = U'.length l
    index i (List_StackingA l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (StackingA msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (StackingA msg) where
    fromPtr msg ptr = StackingA_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (StackingA_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (StackingA (M'.MutMsg s)) where
    setIndex (StackingA_newtype_ elt) i (List_StackingA l) = U'.setIndex elt i l
    newList msg len = List_StackingA <$> U'.allocCompositeList msg 1 1 len
instance C'.Allocate s (StackingA (M'.MutMsg s)) where
    new msg = StackingA_newtype_ <$> U'.allocStruct msg 1 1
get_StackingA'num :: U'.ReadCtx m msg => StackingA msg -> m Int32
get_StackingA'num (StackingA_newtype_ struct) = H'.getWordField struct 0 0 0
set_StackingA'num :: U'.RWCtx m s => StackingA (M'.MutMsg s) -> Int32 -> m ()
set_StackingA'num (StackingA_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0
get_StackingA'b :: U'.ReadCtx m msg => StackingA msg -> m (StackingB msg)
get_StackingA'b (StackingA_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_StackingA'b :: U'.ReadCtx m msg => StackingA msg -> m Bool
has_StackingA'b(StackingA_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_StackingA'b :: U'.RWCtx m s => StackingA (M'.MutMsg s) -> (StackingB (M'.MutMsg s)) -> m ()
set_StackingA'b (StackingA_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_StackingA'b :: U'.RWCtx m s => StackingA (M'.MutMsg s) -> m ((StackingB (M'.MutMsg s)))
new_StackingA'b struct = do
    result <- C'.new (U'.message struct)
    set_StackingA'b struct result
    pure result
newtype StackingB msg = StackingB_newtype_ (U'.Struct msg)
instance U'.TraverseMsg StackingB where
    tMsg f (StackingB_newtype_ s) = StackingB_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (StackingB msg) where
    fromStruct = pure . StackingB_newtype_
instance C'.ToStruct msg (StackingB msg) where
    toStruct (StackingB_newtype_ struct) = struct
instance U'.HasMessage (StackingB msg) where
    type InMessage (StackingB msg) = msg
    message (StackingB_newtype_ struct) = U'.message struct
instance U'.MessageDefault (StackingB msg) where
    messageDefault = StackingB_newtype_ . U'.messageDefault
instance B'.ListElem msg (StackingB msg) where
    newtype List msg (StackingB msg) = List_StackingB (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_StackingB <$> C'.fromPtr msg ptr
    toUntypedList (List_StackingB l) = U'.ListStruct l
    length (List_StackingB l) = U'.length l
    index i (List_StackingB l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (StackingB msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (StackingB msg) where
    fromPtr msg ptr = StackingB_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (StackingB_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (StackingB (M'.MutMsg s)) where
    setIndex (StackingB_newtype_ elt) i (List_StackingB l) = U'.setIndex elt i l
    newList msg len = List_StackingB <$> U'.allocCompositeList msg 1 0 len
instance C'.Allocate s (StackingB (M'.MutMsg s)) where
    new msg = StackingB_newtype_ <$> U'.allocStruct msg 1 0
get_StackingB'num :: U'.ReadCtx m msg => StackingB msg -> m Int32
get_StackingB'num (StackingB_newtype_ struct) = H'.getWordField struct 0 0 0
set_StackingB'num :: U'.RWCtx m s => StackingB (M'.MutMsg s) -> Int32 -> m ()
set_StackingB'num (StackingB_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0
newtype StackingRoot msg = StackingRoot_newtype_ (U'.Struct msg)
instance U'.TraverseMsg StackingRoot where
    tMsg f (StackingRoot_newtype_ s) = StackingRoot_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (StackingRoot msg) where
    fromStruct = pure . StackingRoot_newtype_
instance C'.ToStruct msg (StackingRoot msg) where
    toStruct (StackingRoot_newtype_ struct) = struct
instance U'.HasMessage (StackingRoot msg) where
    type InMessage (StackingRoot msg) = msg
    message (StackingRoot_newtype_ struct) = U'.message struct
instance U'.MessageDefault (StackingRoot msg) where
    messageDefault = StackingRoot_newtype_ . U'.messageDefault
instance B'.ListElem msg (StackingRoot msg) where
    newtype List msg (StackingRoot msg) = List_StackingRoot (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_StackingRoot <$> C'.fromPtr msg ptr
    toUntypedList (List_StackingRoot l) = U'.ListStruct l
    length (List_StackingRoot l) = U'.length l
    index i (List_StackingRoot l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (StackingRoot msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (StackingRoot msg) where
    fromPtr msg ptr = StackingRoot_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (StackingRoot_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (StackingRoot (M'.MutMsg s)) where
    setIndex (StackingRoot_newtype_ elt) i (List_StackingRoot l) = U'.setIndex elt i l
    newList msg len = List_StackingRoot <$> U'.allocCompositeList msg 0 2 len
instance C'.Allocate s (StackingRoot (M'.MutMsg s)) where
    new msg = StackingRoot_newtype_ <$> U'.allocStruct msg 0 2
get_StackingRoot'aWithDefault :: U'.ReadCtx m msg => StackingRoot msg -> m (StackingA msg)
get_StackingRoot'aWithDefault (StackingRoot_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_StackingRoot'aWithDefault :: U'.ReadCtx m msg => StackingRoot msg -> m Bool
has_StackingRoot'aWithDefault(StackingRoot_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_StackingRoot'aWithDefault :: U'.RWCtx m s => StackingRoot (M'.MutMsg s) -> (StackingA (M'.MutMsg s)) -> m ()
set_StackingRoot'aWithDefault (StackingRoot_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_StackingRoot'aWithDefault :: U'.RWCtx m s => StackingRoot (M'.MutMsg s) -> m ((StackingA (M'.MutMsg s)))
new_StackingRoot'aWithDefault struct = do
    result <- C'.new (U'.message struct)
    set_StackingRoot'aWithDefault struct result
    pure result
get_StackingRoot'a :: U'.ReadCtx m msg => StackingRoot msg -> m (StackingA msg)
get_StackingRoot'a (StackingRoot_newtype_ struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)
has_StackingRoot'a :: U'.ReadCtx m msg => StackingRoot msg -> m Bool
has_StackingRoot'a(StackingRoot_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
set_StackingRoot'a :: U'.RWCtx m s => StackingRoot (M'.MutMsg s) -> (StackingA (M'.MutMsg s)) -> m ()
set_StackingRoot'a (StackingRoot_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 1 struct
new_StackingRoot'a :: U'.RWCtx m s => StackingRoot (M'.MutMsg s) -> m ((StackingA (M'.MutMsg s)))
new_StackingRoot'a struct = do
    result <- C'.new (U'.message struct)
    set_StackingRoot'a struct result
    pure result
newtype VerEmpty msg = VerEmpty_newtype_ (U'.Struct msg)
instance U'.TraverseMsg VerEmpty where
    tMsg f (VerEmpty_newtype_ s) = VerEmpty_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (VerEmpty msg) where
    fromStruct = pure . VerEmpty_newtype_
instance C'.ToStruct msg (VerEmpty msg) where
    toStruct (VerEmpty_newtype_ struct) = struct
instance U'.HasMessage (VerEmpty msg) where
    type InMessage (VerEmpty msg) = msg
    message (VerEmpty_newtype_ struct) = U'.message struct
instance U'.MessageDefault (VerEmpty msg) where
    messageDefault = VerEmpty_newtype_ . U'.messageDefault
instance B'.ListElem msg (VerEmpty msg) where
    newtype List msg (VerEmpty msg) = List_VerEmpty (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_VerEmpty <$> C'.fromPtr msg ptr
    toUntypedList (List_VerEmpty l) = U'.ListStruct l
    length (List_VerEmpty l) = U'.length l
    index i (List_VerEmpty l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (VerEmpty msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (VerEmpty msg) where
    fromPtr msg ptr = VerEmpty_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (VerEmpty_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (VerEmpty (M'.MutMsg s)) where
    setIndex (VerEmpty_newtype_ elt) i (List_VerEmpty l) = U'.setIndex elt i l
    newList msg len = List_VerEmpty <$> U'.allocCompositeList msg 0 0 len
instance C'.Allocate s (VerEmpty (M'.MutMsg s)) where
    new msg = VerEmpty_newtype_ <$> U'.allocStruct msg 0 0
newtype VerOneData msg = VerOneData_newtype_ (U'.Struct msg)
instance U'.TraverseMsg VerOneData where
    tMsg f (VerOneData_newtype_ s) = VerOneData_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (VerOneData msg) where
    fromStruct = pure . VerOneData_newtype_
instance C'.ToStruct msg (VerOneData msg) where
    toStruct (VerOneData_newtype_ struct) = struct
instance U'.HasMessage (VerOneData msg) where
    type InMessage (VerOneData msg) = msg
    message (VerOneData_newtype_ struct) = U'.message struct
instance U'.MessageDefault (VerOneData msg) where
    messageDefault = VerOneData_newtype_ . U'.messageDefault
instance B'.ListElem msg (VerOneData msg) where
    newtype List msg (VerOneData msg) = List_VerOneData (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_VerOneData <$> C'.fromPtr msg ptr
    toUntypedList (List_VerOneData l) = U'.ListStruct l
    length (List_VerOneData l) = U'.length l
    index i (List_VerOneData l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (VerOneData msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (VerOneData msg) where
    fromPtr msg ptr = VerOneData_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (VerOneData_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (VerOneData (M'.MutMsg s)) where
    setIndex (VerOneData_newtype_ elt) i (List_VerOneData l) = U'.setIndex elt i l
    newList msg len = List_VerOneData <$> U'.allocCompositeList msg 1 0 len
instance C'.Allocate s (VerOneData (M'.MutMsg s)) where
    new msg = VerOneData_newtype_ <$> U'.allocStruct msg 1 0
get_VerOneData'val :: U'.ReadCtx m msg => VerOneData msg -> m Int16
get_VerOneData'val (VerOneData_newtype_ struct) = H'.getWordField struct 0 0 0
set_VerOneData'val :: U'.RWCtx m s => VerOneData (M'.MutMsg s) -> Int16 -> m ()
set_VerOneData'val (VerOneData_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word16) 0 0 0
newtype VerOnePtr msg = VerOnePtr_newtype_ (U'.Struct msg)
instance U'.TraverseMsg VerOnePtr where
    tMsg f (VerOnePtr_newtype_ s) = VerOnePtr_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (VerOnePtr msg) where
    fromStruct = pure . VerOnePtr_newtype_
instance C'.ToStruct msg (VerOnePtr msg) where
    toStruct (VerOnePtr_newtype_ struct) = struct
instance U'.HasMessage (VerOnePtr msg) where
    type InMessage (VerOnePtr msg) = msg
    message (VerOnePtr_newtype_ struct) = U'.message struct
instance U'.MessageDefault (VerOnePtr msg) where
    messageDefault = VerOnePtr_newtype_ . U'.messageDefault
instance B'.ListElem msg (VerOnePtr msg) where
    newtype List msg (VerOnePtr msg) = List_VerOnePtr (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_VerOnePtr <$> C'.fromPtr msg ptr
    toUntypedList (List_VerOnePtr l) = U'.ListStruct l
    length (List_VerOnePtr l) = U'.length l
    index i (List_VerOnePtr l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (VerOnePtr msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (VerOnePtr msg) where
    fromPtr msg ptr = VerOnePtr_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (VerOnePtr_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (VerOnePtr (M'.MutMsg s)) where
    setIndex (VerOnePtr_newtype_ elt) i (List_VerOnePtr l) = U'.setIndex elt i l
    newList msg len = List_VerOnePtr <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (VerOnePtr (M'.MutMsg s)) where
    new msg = VerOnePtr_newtype_ <$> U'.allocStruct msg 0 1
get_VerOnePtr'ptr :: U'.ReadCtx m msg => VerOnePtr msg -> m (VerOneData msg)
get_VerOnePtr'ptr (VerOnePtr_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_VerOnePtr'ptr :: U'.ReadCtx m msg => VerOnePtr msg -> m Bool
has_VerOnePtr'ptr(VerOnePtr_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_VerOnePtr'ptr :: U'.RWCtx m s => VerOnePtr (M'.MutMsg s) -> (VerOneData (M'.MutMsg s)) -> m ()
set_VerOnePtr'ptr (VerOnePtr_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_VerOnePtr'ptr :: U'.RWCtx m s => VerOnePtr (M'.MutMsg s) -> m ((VerOneData (M'.MutMsg s)))
new_VerOnePtr'ptr struct = do
    result <- C'.new (U'.message struct)
    set_VerOnePtr'ptr struct result
    pure result
newtype VerTwoData msg = VerTwoData_newtype_ (U'.Struct msg)
instance U'.TraverseMsg VerTwoData where
    tMsg f (VerTwoData_newtype_ s) = VerTwoData_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (VerTwoData msg) where
    fromStruct = pure . VerTwoData_newtype_
instance C'.ToStruct msg (VerTwoData msg) where
    toStruct (VerTwoData_newtype_ struct) = struct
instance U'.HasMessage (VerTwoData msg) where
    type InMessage (VerTwoData msg) = msg
    message (VerTwoData_newtype_ struct) = U'.message struct
instance U'.MessageDefault (VerTwoData msg) where
    messageDefault = VerTwoData_newtype_ . U'.messageDefault
instance B'.ListElem msg (VerTwoData msg) where
    newtype List msg (VerTwoData msg) = List_VerTwoData (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_VerTwoData <$> C'.fromPtr msg ptr
    toUntypedList (List_VerTwoData l) = U'.ListStruct l
    length (List_VerTwoData l) = U'.length l
    index i (List_VerTwoData l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (VerTwoData msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (VerTwoData msg) where
    fromPtr msg ptr = VerTwoData_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (VerTwoData_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (VerTwoData (M'.MutMsg s)) where
    setIndex (VerTwoData_newtype_ elt) i (List_VerTwoData l) = U'.setIndex elt i l
    newList msg len = List_VerTwoData <$> U'.allocCompositeList msg 2 0 len
instance C'.Allocate s (VerTwoData (M'.MutMsg s)) where
    new msg = VerTwoData_newtype_ <$> U'.allocStruct msg 2 0
get_VerTwoData'val :: U'.ReadCtx m msg => VerTwoData msg -> m Int16
get_VerTwoData'val (VerTwoData_newtype_ struct) = H'.getWordField struct 0 0 0
set_VerTwoData'val :: U'.RWCtx m s => VerTwoData (M'.MutMsg s) -> Int16 -> m ()
set_VerTwoData'val (VerTwoData_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word16) 0 0 0
get_VerTwoData'duo :: U'.ReadCtx m msg => VerTwoData msg -> m Int64
get_VerTwoData'duo (VerTwoData_newtype_ struct) = H'.getWordField struct 1 0 0
set_VerTwoData'duo :: U'.RWCtx m s => VerTwoData (M'.MutMsg s) -> Int64 -> m ()
set_VerTwoData'duo (VerTwoData_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 1 0 0
newtype VerTwoDataTwoPtr msg = VerTwoDataTwoPtr_newtype_ (U'.Struct msg)
instance U'.TraverseMsg VerTwoDataTwoPtr where
    tMsg f (VerTwoDataTwoPtr_newtype_ s) = VerTwoDataTwoPtr_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (VerTwoDataTwoPtr msg) where
    fromStruct = pure . VerTwoDataTwoPtr_newtype_
instance C'.ToStruct msg (VerTwoDataTwoPtr msg) where
    toStruct (VerTwoDataTwoPtr_newtype_ struct) = struct
instance U'.HasMessage (VerTwoDataTwoPtr msg) where
    type InMessage (VerTwoDataTwoPtr msg) = msg
    message (VerTwoDataTwoPtr_newtype_ struct) = U'.message struct
instance U'.MessageDefault (VerTwoDataTwoPtr msg) where
    messageDefault = VerTwoDataTwoPtr_newtype_ . U'.messageDefault
instance B'.ListElem msg (VerTwoDataTwoPtr msg) where
    newtype List msg (VerTwoDataTwoPtr msg) = List_VerTwoDataTwoPtr (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_VerTwoDataTwoPtr <$> C'.fromPtr msg ptr
    toUntypedList (List_VerTwoDataTwoPtr l) = U'.ListStruct l
    length (List_VerTwoDataTwoPtr l) = U'.length l
    index i (List_VerTwoDataTwoPtr l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (VerTwoDataTwoPtr msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (VerTwoDataTwoPtr msg) where
    fromPtr msg ptr = VerTwoDataTwoPtr_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (VerTwoDataTwoPtr_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (VerTwoDataTwoPtr (M'.MutMsg s)) where
    setIndex (VerTwoDataTwoPtr_newtype_ elt) i (List_VerTwoDataTwoPtr l) = U'.setIndex elt i l
    newList msg len = List_VerTwoDataTwoPtr <$> U'.allocCompositeList msg 2 2 len
instance C'.Allocate s (VerTwoDataTwoPtr (M'.MutMsg s)) where
    new msg = VerTwoDataTwoPtr_newtype_ <$> U'.allocStruct msg 2 2
get_VerTwoDataTwoPtr'val :: U'.ReadCtx m msg => VerTwoDataTwoPtr msg -> m Int16
get_VerTwoDataTwoPtr'val (VerTwoDataTwoPtr_newtype_ struct) = H'.getWordField struct 0 0 0
set_VerTwoDataTwoPtr'val :: U'.RWCtx m s => VerTwoDataTwoPtr (M'.MutMsg s) -> Int16 -> m ()
set_VerTwoDataTwoPtr'val (VerTwoDataTwoPtr_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word16) 0 0 0
get_VerTwoDataTwoPtr'duo :: U'.ReadCtx m msg => VerTwoDataTwoPtr msg -> m Int64
get_VerTwoDataTwoPtr'duo (VerTwoDataTwoPtr_newtype_ struct) = H'.getWordField struct 1 0 0
set_VerTwoDataTwoPtr'duo :: U'.RWCtx m s => VerTwoDataTwoPtr (M'.MutMsg s) -> Int64 -> m ()
set_VerTwoDataTwoPtr'duo (VerTwoDataTwoPtr_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 1 0 0
get_VerTwoDataTwoPtr'ptr1 :: U'.ReadCtx m msg => VerTwoDataTwoPtr msg -> m (VerOneData msg)
get_VerTwoDataTwoPtr'ptr1 (VerTwoDataTwoPtr_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_VerTwoDataTwoPtr'ptr1 :: U'.ReadCtx m msg => VerTwoDataTwoPtr msg -> m Bool
has_VerTwoDataTwoPtr'ptr1(VerTwoDataTwoPtr_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_VerTwoDataTwoPtr'ptr1 :: U'.RWCtx m s => VerTwoDataTwoPtr (M'.MutMsg s) -> (VerOneData (M'.MutMsg s)) -> m ()
set_VerTwoDataTwoPtr'ptr1 (VerTwoDataTwoPtr_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_VerTwoDataTwoPtr'ptr1 :: U'.RWCtx m s => VerTwoDataTwoPtr (M'.MutMsg s) -> m ((VerOneData (M'.MutMsg s)))
new_VerTwoDataTwoPtr'ptr1 struct = do
    result <- C'.new (U'.message struct)
    set_VerTwoDataTwoPtr'ptr1 struct result
    pure result
get_VerTwoDataTwoPtr'ptr2 :: U'.ReadCtx m msg => VerTwoDataTwoPtr msg -> m (VerOneData msg)
get_VerTwoDataTwoPtr'ptr2 (VerTwoDataTwoPtr_newtype_ struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)
has_VerTwoDataTwoPtr'ptr2 :: U'.ReadCtx m msg => VerTwoDataTwoPtr msg -> m Bool
has_VerTwoDataTwoPtr'ptr2(VerTwoDataTwoPtr_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
set_VerTwoDataTwoPtr'ptr2 :: U'.RWCtx m s => VerTwoDataTwoPtr (M'.MutMsg s) -> (VerOneData (M'.MutMsg s)) -> m ()
set_VerTwoDataTwoPtr'ptr2 (VerTwoDataTwoPtr_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 1 struct
new_VerTwoDataTwoPtr'ptr2 :: U'.RWCtx m s => VerTwoDataTwoPtr (M'.MutMsg s) -> m ((VerOneData (M'.MutMsg s)))
new_VerTwoDataTwoPtr'ptr2 struct = do
    result <- C'.new (U'.message struct)
    set_VerTwoDataTwoPtr'ptr2 struct result
    pure result
newtype VerTwoPtr msg = VerTwoPtr_newtype_ (U'.Struct msg)
instance U'.TraverseMsg VerTwoPtr where
    tMsg f (VerTwoPtr_newtype_ s) = VerTwoPtr_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (VerTwoPtr msg) where
    fromStruct = pure . VerTwoPtr_newtype_
instance C'.ToStruct msg (VerTwoPtr msg) where
    toStruct (VerTwoPtr_newtype_ struct) = struct
instance U'.HasMessage (VerTwoPtr msg) where
    type InMessage (VerTwoPtr msg) = msg
    message (VerTwoPtr_newtype_ struct) = U'.message struct
instance U'.MessageDefault (VerTwoPtr msg) where
    messageDefault = VerTwoPtr_newtype_ . U'.messageDefault
instance B'.ListElem msg (VerTwoPtr msg) where
    newtype List msg (VerTwoPtr msg) = List_VerTwoPtr (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_VerTwoPtr <$> C'.fromPtr msg ptr
    toUntypedList (List_VerTwoPtr l) = U'.ListStruct l
    length (List_VerTwoPtr l) = U'.length l
    index i (List_VerTwoPtr l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (VerTwoPtr msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (VerTwoPtr msg) where
    fromPtr msg ptr = VerTwoPtr_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (VerTwoPtr_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (VerTwoPtr (M'.MutMsg s)) where
    setIndex (VerTwoPtr_newtype_ elt) i (List_VerTwoPtr l) = U'.setIndex elt i l
    newList msg len = List_VerTwoPtr <$> U'.allocCompositeList msg 0 2 len
instance C'.Allocate s (VerTwoPtr (M'.MutMsg s)) where
    new msg = VerTwoPtr_newtype_ <$> U'.allocStruct msg 0 2
get_VerTwoPtr'ptr1 :: U'.ReadCtx m msg => VerTwoPtr msg -> m (VerOneData msg)
get_VerTwoPtr'ptr1 (VerTwoPtr_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_VerTwoPtr'ptr1 :: U'.ReadCtx m msg => VerTwoPtr msg -> m Bool
has_VerTwoPtr'ptr1(VerTwoPtr_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_VerTwoPtr'ptr1 :: U'.RWCtx m s => VerTwoPtr (M'.MutMsg s) -> (VerOneData (M'.MutMsg s)) -> m ()
set_VerTwoPtr'ptr1 (VerTwoPtr_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_VerTwoPtr'ptr1 :: U'.RWCtx m s => VerTwoPtr (M'.MutMsg s) -> m ((VerOneData (M'.MutMsg s)))
new_VerTwoPtr'ptr1 struct = do
    result <- C'.new (U'.message struct)
    set_VerTwoPtr'ptr1 struct result
    pure result
get_VerTwoPtr'ptr2 :: U'.ReadCtx m msg => VerTwoPtr msg -> m (VerOneData msg)
get_VerTwoPtr'ptr2 (VerTwoPtr_newtype_ struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)
has_VerTwoPtr'ptr2 :: U'.ReadCtx m msg => VerTwoPtr msg -> m Bool
has_VerTwoPtr'ptr2(VerTwoPtr_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
set_VerTwoPtr'ptr2 :: U'.RWCtx m s => VerTwoPtr (M'.MutMsg s) -> (VerOneData (M'.MutMsg s)) -> m ()
set_VerTwoPtr'ptr2 (VerTwoPtr_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 1 struct
new_VerTwoPtr'ptr2 :: U'.RWCtx m s => VerTwoPtr (M'.MutMsg s) -> m ((VerOneData (M'.MutMsg s)))
new_VerTwoPtr'ptr2 struct = do
    result <- C'.new (U'.message struct)
    set_VerTwoPtr'ptr2 struct result
    pure result
newtype VerTwoTwoPlus msg = VerTwoTwoPlus_newtype_ (U'.Struct msg)
instance U'.TraverseMsg VerTwoTwoPlus where
    tMsg f (VerTwoTwoPlus_newtype_ s) = VerTwoTwoPlus_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (VerTwoTwoPlus msg) where
    fromStruct = pure . VerTwoTwoPlus_newtype_
instance C'.ToStruct msg (VerTwoTwoPlus msg) where
    toStruct (VerTwoTwoPlus_newtype_ struct) = struct
instance U'.HasMessage (VerTwoTwoPlus msg) where
    type InMessage (VerTwoTwoPlus msg) = msg
    message (VerTwoTwoPlus_newtype_ struct) = U'.message struct
instance U'.MessageDefault (VerTwoTwoPlus msg) where
    messageDefault = VerTwoTwoPlus_newtype_ . U'.messageDefault
instance B'.ListElem msg (VerTwoTwoPlus msg) where
    newtype List msg (VerTwoTwoPlus msg) = List_VerTwoTwoPlus (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_VerTwoTwoPlus <$> C'.fromPtr msg ptr
    toUntypedList (List_VerTwoTwoPlus l) = U'.ListStruct l
    length (List_VerTwoTwoPlus l) = U'.length l
    index i (List_VerTwoTwoPlus l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (VerTwoTwoPlus msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (VerTwoTwoPlus msg) where
    fromPtr msg ptr = VerTwoTwoPlus_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (VerTwoTwoPlus_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (VerTwoTwoPlus (M'.MutMsg s)) where
    setIndex (VerTwoTwoPlus_newtype_ elt) i (List_VerTwoTwoPlus l) = U'.setIndex elt i l
    newList msg len = List_VerTwoTwoPlus <$> U'.allocCompositeList msg 3 3 len
instance C'.Allocate s (VerTwoTwoPlus (M'.MutMsg s)) where
    new msg = VerTwoTwoPlus_newtype_ <$> U'.allocStruct msg 3 3
get_VerTwoTwoPlus'val :: U'.ReadCtx m msg => VerTwoTwoPlus msg -> m Int16
get_VerTwoTwoPlus'val (VerTwoTwoPlus_newtype_ struct) = H'.getWordField struct 0 0 0
set_VerTwoTwoPlus'val :: U'.RWCtx m s => VerTwoTwoPlus (M'.MutMsg s) -> Int16 -> m ()
set_VerTwoTwoPlus'val (VerTwoTwoPlus_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word16) 0 0 0
get_VerTwoTwoPlus'duo :: U'.ReadCtx m msg => VerTwoTwoPlus msg -> m Int64
get_VerTwoTwoPlus'duo (VerTwoTwoPlus_newtype_ struct) = H'.getWordField struct 1 0 0
set_VerTwoTwoPlus'duo :: U'.RWCtx m s => VerTwoTwoPlus (M'.MutMsg s) -> Int64 -> m ()
set_VerTwoTwoPlus'duo (VerTwoTwoPlus_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 1 0 0
get_VerTwoTwoPlus'ptr1 :: U'.ReadCtx m msg => VerTwoTwoPlus msg -> m (VerTwoDataTwoPtr msg)
get_VerTwoTwoPlus'ptr1 (VerTwoTwoPlus_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_VerTwoTwoPlus'ptr1 :: U'.ReadCtx m msg => VerTwoTwoPlus msg -> m Bool
has_VerTwoTwoPlus'ptr1(VerTwoTwoPlus_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_VerTwoTwoPlus'ptr1 :: U'.RWCtx m s => VerTwoTwoPlus (M'.MutMsg s) -> (VerTwoDataTwoPtr (M'.MutMsg s)) -> m ()
set_VerTwoTwoPlus'ptr1 (VerTwoTwoPlus_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_VerTwoTwoPlus'ptr1 :: U'.RWCtx m s => VerTwoTwoPlus (M'.MutMsg s) -> m ((VerTwoDataTwoPtr (M'.MutMsg s)))
new_VerTwoTwoPlus'ptr1 struct = do
    result <- C'.new (U'.message struct)
    set_VerTwoTwoPlus'ptr1 struct result
    pure result
get_VerTwoTwoPlus'ptr2 :: U'.ReadCtx m msg => VerTwoTwoPlus msg -> m (VerTwoDataTwoPtr msg)
get_VerTwoTwoPlus'ptr2 (VerTwoTwoPlus_newtype_ struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)
has_VerTwoTwoPlus'ptr2 :: U'.ReadCtx m msg => VerTwoTwoPlus msg -> m Bool
has_VerTwoTwoPlus'ptr2(VerTwoTwoPlus_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
set_VerTwoTwoPlus'ptr2 :: U'.RWCtx m s => VerTwoTwoPlus (M'.MutMsg s) -> (VerTwoDataTwoPtr (M'.MutMsg s)) -> m ()
set_VerTwoTwoPlus'ptr2 (VerTwoTwoPlus_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 1 struct
new_VerTwoTwoPlus'ptr2 :: U'.RWCtx m s => VerTwoTwoPlus (M'.MutMsg s) -> m ((VerTwoDataTwoPtr (M'.MutMsg s)))
new_VerTwoTwoPlus'ptr2 struct = do
    result <- C'.new (U'.message struct)
    set_VerTwoTwoPlus'ptr2 struct result
    pure result
get_VerTwoTwoPlus'tre :: U'.ReadCtx m msg => VerTwoTwoPlus msg -> m Int64
get_VerTwoTwoPlus'tre (VerTwoTwoPlus_newtype_ struct) = H'.getWordField struct 2 0 0
set_VerTwoTwoPlus'tre :: U'.RWCtx m s => VerTwoTwoPlus (M'.MutMsg s) -> Int64 -> m ()
set_VerTwoTwoPlus'tre (VerTwoTwoPlus_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 2 0 0
get_VerTwoTwoPlus'lst3 :: U'.ReadCtx m msg => VerTwoTwoPlus msg -> m (B'.List msg Int64)
get_VerTwoTwoPlus'lst3 (VerTwoTwoPlus_newtype_ struct) =
    U'.getPtr 2 struct
    >>= C'.fromPtr (U'.message struct)
has_VerTwoTwoPlus'lst3 :: U'.ReadCtx m msg => VerTwoTwoPlus msg -> m Bool
has_VerTwoTwoPlus'lst3(VerTwoTwoPlus_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 2 struct
set_VerTwoTwoPlus'lst3 :: U'.RWCtx m s => VerTwoTwoPlus (M'.MutMsg s) -> (B'.List (M'.MutMsg s) Int64) -> m ()
set_VerTwoTwoPlus'lst3 (VerTwoTwoPlus_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 2 struct
new_VerTwoTwoPlus'lst3 :: U'.RWCtx m s => Int -> VerTwoTwoPlus (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) Int64))
new_VerTwoTwoPlus'lst3 len struct = do
    result <- C'.newList (U'.message struct) len
    set_VerTwoTwoPlus'lst3 struct result
    pure result
newtype VoidUnion msg = VoidUnion_newtype_ (U'.Struct msg)
instance U'.TraverseMsg VoidUnion where
    tMsg f (VoidUnion_newtype_ s) = VoidUnion_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (VoidUnion msg) where
    fromStruct = pure . VoidUnion_newtype_
instance C'.ToStruct msg (VoidUnion msg) where
    toStruct (VoidUnion_newtype_ struct) = struct
instance U'.HasMessage (VoidUnion msg) where
    type InMessage (VoidUnion msg) = msg
    message (VoidUnion_newtype_ struct) = U'.message struct
instance U'.MessageDefault (VoidUnion msg) where
    messageDefault = VoidUnion_newtype_ . U'.messageDefault
instance B'.ListElem msg (VoidUnion msg) where
    newtype List msg (VoidUnion msg) = List_VoidUnion (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_VoidUnion <$> C'.fromPtr msg ptr
    toUntypedList (List_VoidUnion l) = U'.ListStruct l
    length (List_VoidUnion l) = U'.length l
    index i (List_VoidUnion l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (VoidUnion msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (VoidUnion msg) where
    fromPtr msg ptr = VoidUnion_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (VoidUnion_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (VoidUnion (M'.MutMsg s)) where
    setIndex (VoidUnion_newtype_ elt) i (List_VoidUnion l) = U'.setIndex elt i l
    newList msg len = List_VoidUnion <$> U'.allocCompositeList msg 1 0 len
instance C'.Allocate s (VoidUnion (M'.MutMsg s)) where
    new msg = VoidUnion_newtype_ <$> U'.allocStruct msg 1 0
data VoidUnion' msg
    = VoidUnion'a
    | VoidUnion'b
    | VoidUnion'unknown' Word16
get_VoidUnion' :: U'.ReadCtx m msg => VoidUnion msg -> m (VoidUnion' msg)
get_VoidUnion' (VoidUnion_newtype_ struct) = C'.fromStruct struct
set_VoidUnion'a :: U'.RWCtx m s => VoidUnion (M'.MutMsg s) -> m ()
set_VoidUnion'a (VoidUnion_newtype_ struct) = H'.setWordField struct (0 :: Word16) 0 0 0
set_VoidUnion'b :: U'.RWCtx m s => VoidUnion (M'.MutMsg s) -> m ()
set_VoidUnion'b (VoidUnion_newtype_ struct) = H'.setWordField struct (1 :: Word16) 0 0 0
set_VoidUnion'unknown' :: U'.RWCtx m s => VoidUnion (M'.MutMsg s) -> Word16 -> m ()
set_VoidUnion'unknown'(VoidUnion_newtype_ struct) tagValue = H'.setWordField struct (tagValue :: Word16) 0 0 0
instance C'.FromStruct msg (VoidUnion' msg) where
    fromStruct struct = do
        tag <-  H'.getWordField struct 0 0 0
        case tag of
            1 -> pure VoidUnion'b
            0 -> pure VoidUnion'a
            _ -> pure $ VoidUnion'unknown' tag
newtype Wrap2x2 msg = Wrap2x2_newtype_ (U'.Struct msg)
instance U'.TraverseMsg Wrap2x2 where
    tMsg f (Wrap2x2_newtype_ s) = Wrap2x2_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (Wrap2x2 msg) where
    fromStruct = pure . Wrap2x2_newtype_
instance C'.ToStruct msg (Wrap2x2 msg) where
    toStruct (Wrap2x2_newtype_ struct) = struct
instance U'.HasMessage (Wrap2x2 msg) where
    type InMessage (Wrap2x2 msg) = msg
    message (Wrap2x2_newtype_ struct) = U'.message struct
instance U'.MessageDefault (Wrap2x2 msg) where
    messageDefault = Wrap2x2_newtype_ . U'.messageDefault
instance B'.ListElem msg (Wrap2x2 msg) where
    newtype List msg (Wrap2x2 msg) = List_Wrap2x2 (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_Wrap2x2 <$> C'.fromPtr msg ptr
    toUntypedList (List_Wrap2x2 l) = U'.ListStruct l
    length (List_Wrap2x2 l) = U'.length l
    index i (List_Wrap2x2 l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Wrap2x2 msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (Wrap2x2 msg) where
    fromPtr msg ptr = Wrap2x2_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (Wrap2x2_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (Wrap2x2 (M'.MutMsg s)) where
    setIndex (Wrap2x2_newtype_ elt) i (List_Wrap2x2 l) = U'.setIndex elt i l
    newList msg len = List_Wrap2x2 <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (Wrap2x2 (M'.MutMsg s)) where
    new msg = Wrap2x2_newtype_ <$> U'.allocStruct msg 0 1
get_Wrap2x2'mightNotBeReallyEmpty :: U'.ReadCtx m msg => Wrap2x2 msg -> m (VerTwoDataTwoPtr msg)
get_Wrap2x2'mightNotBeReallyEmpty (Wrap2x2_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_Wrap2x2'mightNotBeReallyEmpty :: U'.ReadCtx m msg => Wrap2x2 msg -> m Bool
has_Wrap2x2'mightNotBeReallyEmpty(Wrap2x2_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_Wrap2x2'mightNotBeReallyEmpty :: U'.RWCtx m s => Wrap2x2 (M'.MutMsg s) -> (VerTwoDataTwoPtr (M'.MutMsg s)) -> m ()
set_Wrap2x2'mightNotBeReallyEmpty (Wrap2x2_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Wrap2x2'mightNotBeReallyEmpty :: U'.RWCtx m s => Wrap2x2 (M'.MutMsg s) -> m ((VerTwoDataTwoPtr (M'.MutMsg s)))
new_Wrap2x2'mightNotBeReallyEmpty struct = do
    result <- C'.new (U'.message struct)
    set_Wrap2x2'mightNotBeReallyEmpty struct result
    pure result
newtype Wrap2x2plus msg = Wrap2x2plus_newtype_ (U'.Struct msg)
instance U'.TraverseMsg Wrap2x2plus where
    tMsg f (Wrap2x2plus_newtype_ s) = Wrap2x2plus_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (Wrap2x2plus msg) where
    fromStruct = pure . Wrap2x2plus_newtype_
instance C'.ToStruct msg (Wrap2x2plus msg) where
    toStruct (Wrap2x2plus_newtype_ struct) = struct
instance U'.HasMessage (Wrap2x2plus msg) where
    type InMessage (Wrap2x2plus msg) = msg
    message (Wrap2x2plus_newtype_ struct) = U'.message struct
instance U'.MessageDefault (Wrap2x2plus msg) where
    messageDefault = Wrap2x2plus_newtype_ . U'.messageDefault
instance B'.ListElem msg (Wrap2x2plus msg) where
    newtype List msg (Wrap2x2plus msg) = List_Wrap2x2plus (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_Wrap2x2plus <$> C'.fromPtr msg ptr
    toUntypedList (List_Wrap2x2plus l) = U'.ListStruct l
    length (List_Wrap2x2plus l) = U'.length l
    index i (List_Wrap2x2plus l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Wrap2x2plus msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (Wrap2x2plus msg) where
    fromPtr msg ptr = Wrap2x2plus_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (Wrap2x2plus_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (Wrap2x2plus (M'.MutMsg s)) where
    setIndex (Wrap2x2plus_newtype_ elt) i (List_Wrap2x2plus l) = U'.setIndex elt i l
    newList msg len = List_Wrap2x2plus <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (Wrap2x2plus (M'.MutMsg s)) where
    new msg = Wrap2x2plus_newtype_ <$> U'.allocStruct msg 0 1
get_Wrap2x2plus'mightNotBeReallyEmpty :: U'.ReadCtx m msg => Wrap2x2plus msg -> m (VerTwoTwoPlus msg)
get_Wrap2x2plus'mightNotBeReallyEmpty (Wrap2x2plus_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_Wrap2x2plus'mightNotBeReallyEmpty :: U'.ReadCtx m msg => Wrap2x2plus msg -> m Bool
has_Wrap2x2plus'mightNotBeReallyEmpty(Wrap2x2plus_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_Wrap2x2plus'mightNotBeReallyEmpty :: U'.RWCtx m s => Wrap2x2plus (M'.MutMsg s) -> (VerTwoTwoPlus (M'.MutMsg s)) -> m ()
set_Wrap2x2plus'mightNotBeReallyEmpty (Wrap2x2plus_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Wrap2x2plus'mightNotBeReallyEmpty :: U'.RWCtx m s => Wrap2x2plus (M'.MutMsg s) -> m ((VerTwoTwoPlus (M'.MutMsg s)))
new_Wrap2x2plus'mightNotBeReallyEmpty struct = do
    result <- C'.new (U'.message struct)
    set_Wrap2x2plus'mightNotBeReallyEmpty struct result
    pure result
newtype WrapEmpty msg = WrapEmpty_newtype_ (U'.Struct msg)
instance U'.TraverseMsg WrapEmpty where
    tMsg f (WrapEmpty_newtype_ s) = WrapEmpty_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (WrapEmpty msg) where
    fromStruct = pure . WrapEmpty_newtype_
instance C'.ToStruct msg (WrapEmpty msg) where
    toStruct (WrapEmpty_newtype_ struct) = struct
instance U'.HasMessage (WrapEmpty msg) where
    type InMessage (WrapEmpty msg) = msg
    message (WrapEmpty_newtype_ struct) = U'.message struct
instance U'.MessageDefault (WrapEmpty msg) where
    messageDefault = WrapEmpty_newtype_ . U'.messageDefault
instance B'.ListElem msg (WrapEmpty msg) where
    newtype List msg (WrapEmpty msg) = List_WrapEmpty (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_WrapEmpty <$> C'.fromPtr msg ptr
    toUntypedList (List_WrapEmpty l) = U'.ListStruct l
    length (List_WrapEmpty l) = U'.length l
    index i (List_WrapEmpty l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (WrapEmpty msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (WrapEmpty msg) where
    fromPtr msg ptr = WrapEmpty_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (WrapEmpty_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (WrapEmpty (M'.MutMsg s)) where
    setIndex (WrapEmpty_newtype_ elt) i (List_WrapEmpty l) = U'.setIndex elt i l
    newList msg len = List_WrapEmpty <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (WrapEmpty (M'.MutMsg s)) where
    new msg = WrapEmpty_newtype_ <$> U'.allocStruct msg 0 1
get_WrapEmpty'mightNotBeReallyEmpty :: U'.ReadCtx m msg => WrapEmpty msg -> m (VerEmpty msg)
get_WrapEmpty'mightNotBeReallyEmpty (WrapEmpty_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_WrapEmpty'mightNotBeReallyEmpty :: U'.ReadCtx m msg => WrapEmpty msg -> m Bool
has_WrapEmpty'mightNotBeReallyEmpty(WrapEmpty_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_WrapEmpty'mightNotBeReallyEmpty :: U'.RWCtx m s => WrapEmpty (M'.MutMsg s) -> (VerEmpty (M'.MutMsg s)) -> m ()
set_WrapEmpty'mightNotBeReallyEmpty (WrapEmpty_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_WrapEmpty'mightNotBeReallyEmpty :: U'.RWCtx m s => WrapEmpty (M'.MutMsg s) -> m ((VerEmpty (M'.MutMsg s)))
new_WrapEmpty'mightNotBeReallyEmpty struct = do
    result <- C'.new (U'.message struct)
    set_WrapEmpty'mightNotBeReallyEmpty struct result
    pure result
newtype Z msg = Z_newtype_ (U'.Struct msg)
instance U'.TraverseMsg Z where
    tMsg f (Z_newtype_ s) = Z_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (Z msg) where
    fromStruct = pure . Z_newtype_
instance C'.ToStruct msg (Z msg) where
    toStruct (Z_newtype_ struct) = struct
instance U'.HasMessage (Z msg) where
    type InMessage (Z msg) = msg
    message (Z_newtype_ struct) = U'.message struct
instance U'.MessageDefault (Z msg) where
    messageDefault = Z_newtype_ . U'.messageDefault
instance B'.ListElem msg (Z msg) where
    newtype List msg (Z msg) = List_Z (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_Z <$> C'.fromPtr msg ptr
    toUntypedList (List_Z l) = U'.ListStruct l
    length (List_Z l) = U'.length l
    index i (List_Z l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Z msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (Z msg) where
    fromPtr msg ptr = Z_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (Z_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (Z (M'.MutMsg s)) where
    setIndex (Z_newtype_ elt) i (List_Z l) = U'.setIndex elt i l
    newList msg len = List_Z <$> U'.allocCompositeList msg 3 1 len
instance C'.Allocate s (Z (M'.MutMsg s)) where
    new msg = Z_newtype_ <$> U'.allocStruct msg 3 1
data Z' msg
    = Z'void
    | Z'zz (Z msg)
    | Z'f64 Double
    | Z'f32 Float
    | Z'i64 Int64
    | Z'i32 Int32
    | Z'i16 Int16
    | Z'i8 Int8
    | Z'u64 Word64
    | Z'u32 Word32
    | Z'u16 Word16
    | Z'u8 Word8
    | Z'bool Bool
    | Z'text (B'.Text msg)
    | Z'blob (B'.Data msg)
    | Z'f64vec (B'.List msg Double)
    | Z'f32vec (B'.List msg Float)
    | Z'i64vec (B'.List msg Int64)
    | Z'i32vec (B'.List msg Int32)
    | Z'i16vec (B'.List msg Int16)
    | Z'i8vec (B'.List msg Int8)
    | Z'u64vec (B'.List msg Word64)
    | Z'u32vec (B'.List msg Word32)
    | Z'u16vec (B'.List msg Word16)
    | Z'u8vec (B'.List msg Word8)
    | Z'zvec (B'.List msg (Z msg))
    | Z'zvecvec (B'.List msg (B'.List msg (Z msg)))
    | Z'zdate (Zdate msg)
    | Z'zdata (Zdata msg)
    | Z'aircraftvec (B'.List msg (Aircraft msg))
    | Z'aircraft (Aircraft msg)
    | Z'regression (Regression msg)
    | Z'planebase (PlaneBase msg)
    | Z'airport Airport
    | Z'b737 (B737 msg)
    | Z'a320 (A320 msg)
    | Z'f16 (F16 msg)
    | Z'zdatevec (B'.List msg (Zdate msg))
    | Z'zdatavec (B'.List msg (Zdata msg))
    | Z'boolvec (B'.List msg Bool)
    | Z'datavec (B'.List msg (B'.Data msg))
    | Z'textvec (B'.List msg (B'.Text msg))
    | Z'grp (Z'grp'group' msg)
    | Z'echo (Echo msg)
    | Z'echoBases (EchoBases msg)
    | Z'unknown' Word16
get_Z' :: U'.ReadCtx m msg => Z msg -> m (Z' msg)
get_Z' (Z_newtype_ struct) = C'.fromStruct struct
set_Z'void :: U'.RWCtx m s => Z (M'.MutMsg s) -> m ()
set_Z'void (Z_newtype_ struct) = H'.setWordField struct (0 :: Word16) 0 0 0
set_Z'zz :: U'.RWCtx m s => Z (M'.MutMsg s) -> (Z (M'.MutMsg s)) -> m ()
set_Z'zz(Z_newtype_ struct) value = do
    H'.setWordField struct (1 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'zz :: U'.RWCtx m s => Z (M'.MutMsg s) -> m ((Z (M'.MutMsg s)))
new_Z'zz struct = do
    result <- C'.new (U'.message struct)
    set_Z'zz struct result
    pure result
set_Z'f64 :: U'.RWCtx m s => Z (M'.MutMsg s) -> Double -> m ()
set_Z'f64 (Z_newtype_ struct) value = do
    H'.setWordField struct (2 :: Word16) 0 0 0
    H'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 1 0 0
set_Z'f32 :: U'.RWCtx m s => Z (M'.MutMsg s) -> Float -> m ()
set_Z'f32 (Z_newtype_ struct) value = do
    H'.setWordField struct (3 :: Word16) 0 0 0
    H'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 1 0 0
set_Z'i64 :: U'.RWCtx m s => Z (M'.MutMsg s) -> Int64 -> m ()
set_Z'i64 (Z_newtype_ struct) value = do
    H'.setWordField struct (4 :: Word16) 0 0 0
    H'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 1 0 0
set_Z'i32 :: U'.RWCtx m s => Z (M'.MutMsg s) -> Int32 -> m ()
set_Z'i32 (Z_newtype_ struct) value = do
    H'.setWordField struct (5 :: Word16) 0 0 0
    H'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 1 0 0
set_Z'i16 :: U'.RWCtx m s => Z (M'.MutMsg s) -> Int16 -> m ()
set_Z'i16 (Z_newtype_ struct) value = do
    H'.setWordField struct (6 :: Word16) 0 0 0
    H'.setWordField struct (fromIntegral (C'.toWord value) :: Word16) 1 0 0
set_Z'i8 :: U'.RWCtx m s => Z (M'.MutMsg s) -> Int8 -> m ()
set_Z'i8 (Z_newtype_ struct) value = do
    H'.setWordField struct (7 :: Word16) 0 0 0
    H'.setWordField struct (fromIntegral (C'.toWord value) :: Word8) 1 0 0
set_Z'u64 :: U'.RWCtx m s => Z (M'.MutMsg s) -> Word64 -> m ()
set_Z'u64 (Z_newtype_ struct) value = do
    H'.setWordField struct (8 :: Word16) 0 0 0
    H'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 1 0 0
set_Z'u32 :: U'.RWCtx m s => Z (M'.MutMsg s) -> Word32 -> m ()
set_Z'u32 (Z_newtype_ struct) value = do
    H'.setWordField struct (9 :: Word16) 0 0 0
    H'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 1 0 0
set_Z'u16 :: U'.RWCtx m s => Z (M'.MutMsg s) -> Word16 -> m ()
set_Z'u16 (Z_newtype_ struct) value = do
    H'.setWordField struct (10 :: Word16) 0 0 0
    H'.setWordField struct (fromIntegral (C'.toWord value) :: Word16) 1 0 0
set_Z'u8 :: U'.RWCtx m s => Z (M'.MutMsg s) -> Word8 -> m ()
set_Z'u8 (Z_newtype_ struct) value = do
    H'.setWordField struct (11 :: Word16) 0 0 0
    H'.setWordField struct (fromIntegral (C'.toWord value) :: Word8) 1 0 0
set_Z'bool :: U'.RWCtx m s => Z (M'.MutMsg s) -> Bool -> m ()
set_Z'bool (Z_newtype_ struct) value = do
    H'.setWordField struct (12 :: Word16) 0 0 0
    H'.setWordField struct (fromIntegral (C'.toWord value) :: Word1) 1 0 0
set_Z'text :: U'.RWCtx m s => Z (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_Z'text(Z_newtype_ struct) value = do
    H'.setWordField struct (13 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'text :: U'.RWCtx m s => Int -> Z (M'.MutMsg s) -> m ((B'.Text (M'.MutMsg s)))
new_Z'text len struct = do
    result <- B'.newText (U'.message struct) len
    set_Z'text struct result
    pure result
set_Z'blob :: U'.RWCtx m s => Z (M'.MutMsg s) -> (B'.Data (M'.MutMsg s)) -> m ()
set_Z'blob(Z_newtype_ struct) value = do
    H'.setWordField struct (14 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'blob :: U'.RWCtx m s => Int -> Z (M'.MutMsg s) -> m ((B'.Data (M'.MutMsg s)))
new_Z'blob len struct = do
    result <- B'.newData (U'.message struct) len
    set_Z'blob struct result
    pure result
set_Z'f64vec :: U'.RWCtx m s => Z (M'.MutMsg s) -> (B'.List (M'.MutMsg s) Double) -> m ()
set_Z'f64vec(Z_newtype_ struct) value = do
    H'.setWordField struct (15 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'f64vec :: U'.RWCtx m s => Int -> Z (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) Double))
new_Z'f64vec len struct = do
    result <- C'.newList (U'.message struct) len
    set_Z'f64vec struct result
    pure result
set_Z'f32vec :: U'.RWCtx m s => Z (M'.MutMsg s) -> (B'.List (M'.MutMsg s) Float) -> m ()
set_Z'f32vec(Z_newtype_ struct) value = do
    H'.setWordField struct (16 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'f32vec :: U'.RWCtx m s => Int -> Z (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) Float))
new_Z'f32vec len struct = do
    result <- C'.newList (U'.message struct) len
    set_Z'f32vec struct result
    pure result
set_Z'i64vec :: U'.RWCtx m s => Z (M'.MutMsg s) -> (B'.List (M'.MutMsg s) Int64) -> m ()
set_Z'i64vec(Z_newtype_ struct) value = do
    H'.setWordField struct (17 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'i64vec :: U'.RWCtx m s => Int -> Z (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) Int64))
new_Z'i64vec len struct = do
    result <- C'.newList (U'.message struct) len
    set_Z'i64vec struct result
    pure result
set_Z'i32vec :: U'.RWCtx m s => Z (M'.MutMsg s) -> (B'.List (M'.MutMsg s) Int32) -> m ()
set_Z'i32vec(Z_newtype_ struct) value = do
    H'.setWordField struct (18 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'i32vec :: U'.RWCtx m s => Int -> Z (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) Int32))
new_Z'i32vec len struct = do
    result <- C'.newList (U'.message struct) len
    set_Z'i32vec struct result
    pure result
set_Z'i16vec :: U'.RWCtx m s => Z (M'.MutMsg s) -> (B'.List (M'.MutMsg s) Int16) -> m ()
set_Z'i16vec(Z_newtype_ struct) value = do
    H'.setWordField struct (19 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'i16vec :: U'.RWCtx m s => Int -> Z (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) Int16))
new_Z'i16vec len struct = do
    result <- C'.newList (U'.message struct) len
    set_Z'i16vec struct result
    pure result
set_Z'i8vec :: U'.RWCtx m s => Z (M'.MutMsg s) -> (B'.List (M'.MutMsg s) Int8) -> m ()
set_Z'i8vec(Z_newtype_ struct) value = do
    H'.setWordField struct (20 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'i8vec :: U'.RWCtx m s => Int -> Z (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) Int8))
new_Z'i8vec len struct = do
    result <- C'.newList (U'.message struct) len
    set_Z'i8vec struct result
    pure result
set_Z'u64vec :: U'.RWCtx m s => Z (M'.MutMsg s) -> (B'.List (M'.MutMsg s) Word64) -> m ()
set_Z'u64vec(Z_newtype_ struct) value = do
    H'.setWordField struct (21 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'u64vec :: U'.RWCtx m s => Int -> Z (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) Word64))
new_Z'u64vec len struct = do
    result <- C'.newList (U'.message struct) len
    set_Z'u64vec struct result
    pure result
set_Z'u32vec :: U'.RWCtx m s => Z (M'.MutMsg s) -> (B'.List (M'.MutMsg s) Word32) -> m ()
set_Z'u32vec(Z_newtype_ struct) value = do
    H'.setWordField struct (22 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'u32vec :: U'.RWCtx m s => Int -> Z (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) Word32))
new_Z'u32vec len struct = do
    result <- C'.newList (U'.message struct) len
    set_Z'u32vec struct result
    pure result
set_Z'u16vec :: U'.RWCtx m s => Z (M'.MutMsg s) -> (B'.List (M'.MutMsg s) Word16) -> m ()
set_Z'u16vec(Z_newtype_ struct) value = do
    H'.setWordField struct (23 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'u16vec :: U'.RWCtx m s => Int -> Z (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) Word16))
new_Z'u16vec len struct = do
    result <- C'.newList (U'.message struct) len
    set_Z'u16vec struct result
    pure result
set_Z'u8vec :: U'.RWCtx m s => Z (M'.MutMsg s) -> (B'.List (M'.MutMsg s) Word8) -> m ()
set_Z'u8vec(Z_newtype_ struct) value = do
    H'.setWordField struct (24 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'u8vec :: U'.RWCtx m s => Int -> Z (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) Word8))
new_Z'u8vec len struct = do
    result <- C'.newList (U'.message struct) len
    set_Z'u8vec struct result
    pure result
set_Z'zvec :: U'.RWCtx m s => Z (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (Z (M'.MutMsg s))) -> m ()
set_Z'zvec(Z_newtype_ struct) value = do
    H'.setWordField struct (25 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'zvec :: U'.RWCtx m s => Int -> Z (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (Z (M'.MutMsg s))))
new_Z'zvec len struct = do
    result <- C'.newList (U'.message struct) len
    set_Z'zvec struct result
    pure result
set_Z'zvecvec :: U'.RWCtx m s => Z (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (B'.List (M'.MutMsg s) (Z (M'.MutMsg s)))) -> m ()
set_Z'zvecvec(Z_newtype_ struct) value = do
    H'.setWordField struct (26 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'zvecvec :: U'.RWCtx m s => Int -> Z (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (B'.List (M'.MutMsg s) (Z (M'.MutMsg s)))))
new_Z'zvecvec len struct = do
    result <- C'.newList (U'.message struct) len
    set_Z'zvecvec struct result
    pure result
set_Z'zdate :: U'.RWCtx m s => Z (M'.MutMsg s) -> (Zdate (M'.MutMsg s)) -> m ()
set_Z'zdate(Z_newtype_ struct) value = do
    H'.setWordField struct (27 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'zdate :: U'.RWCtx m s => Z (M'.MutMsg s) -> m ((Zdate (M'.MutMsg s)))
new_Z'zdate struct = do
    result <- C'.new (U'.message struct)
    set_Z'zdate struct result
    pure result
set_Z'zdata :: U'.RWCtx m s => Z (M'.MutMsg s) -> (Zdata (M'.MutMsg s)) -> m ()
set_Z'zdata(Z_newtype_ struct) value = do
    H'.setWordField struct (28 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'zdata :: U'.RWCtx m s => Z (M'.MutMsg s) -> m ((Zdata (M'.MutMsg s)))
new_Z'zdata struct = do
    result <- C'.new (U'.message struct)
    set_Z'zdata struct result
    pure result
set_Z'aircraftvec :: U'.RWCtx m s => Z (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (Aircraft (M'.MutMsg s))) -> m ()
set_Z'aircraftvec(Z_newtype_ struct) value = do
    H'.setWordField struct (29 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'aircraftvec :: U'.RWCtx m s => Int -> Z (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (Aircraft (M'.MutMsg s))))
new_Z'aircraftvec len struct = do
    result <- C'.newList (U'.message struct) len
    set_Z'aircraftvec struct result
    pure result
set_Z'aircraft :: U'.RWCtx m s => Z (M'.MutMsg s) -> (Aircraft (M'.MutMsg s)) -> m ()
set_Z'aircraft(Z_newtype_ struct) value = do
    H'.setWordField struct (30 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'aircraft :: U'.RWCtx m s => Z (M'.MutMsg s) -> m ((Aircraft (M'.MutMsg s)))
new_Z'aircraft struct = do
    result <- C'.new (U'.message struct)
    set_Z'aircraft struct result
    pure result
set_Z'regression :: U'.RWCtx m s => Z (M'.MutMsg s) -> (Regression (M'.MutMsg s)) -> m ()
set_Z'regression(Z_newtype_ struct) value = do
    H'.setWordField struct (31 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'regression :: U'.RWCtx m s => Z (M'.MutMsg s) -> m ((Regression (M'.MutMsg s)))
new_Z'regression struct = do
    result <- C'.new (U'.message struct)
    set_Z'regression struct result
    pure result
set_Z'planebase :: U'.RWCtx m s => Z (M'.MutMsg s) -> (PlaneBase (M'.MutMsg s)) -> m ()
set_Z'planebase(Z_newtype_ struct) value = do
    H'.setWordField struct (32 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'planebase :: U'.RWCtx m s => Z (M'.MutMsg s) -> m ((PlaneBase (M'.MutMsg s)))
new_Z'planebase struct = do
    result <- C'.new (U'.message struct)
    set_Z'planebase struct result
    pure result
set_Z'airport :: U'.RWCtx m s => Z (M'.MutMsg s) -> Airport -> m ()
set_Z'airport (Z_newtype_ struct) value = do
    H'.setWordField struct (33 :: Word16) 0 0 0
    H'.setWordField struct (fromIntegral (C'.toWord value) :: Word16) 1 0 0
set_Z'b737 :: U'.RWCtx m s => Z (M'.MutMsg s) -> (B737 (M'.MutMsg s)) -> m ()
set_Z'b737(Z_newtype_ struct) value = do
    H'.setWordField struct (34 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'b737 :: U'.RWCtx m s => Z (M'.MutMsg s) -> m ((B737 (M'.MutMsg s)))
new_Z'b737 struct = do
    result <- C'.new (U'.message struct)
    set_Z'b737 struct result
    pure result
set_Z'a320 :: U'.RWCtx m s => Z (M'.MutMsg s) -> (A320 (M'.MutMsg s)) -> m ()
set_Z'a320(Z_newtype_ struct) value = do
    H'.setWordField struct (35 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'a320 :: U'.RWCtx m s => Z (M'.MutMsg s) -> m ((A320 (M'.MutMsg s)))
new_Z'a320 struct = do
    result <- C'.new (U'.message struct)
    set_Z'a320 struct result
    pure result
set_Z'f16 :: U'.RWCtx m s => Z (M'.MutMsg s) -> (F16 (M'.MutMsg s)) -> m ()
set_Z'f16(Z_newtype_ struct) value = do
    H'.setWordField struct (36 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'f16 :: U'.RWCtx m s => Z (M'.MutMsg s) -> m ((F16 (M'.MutMsg s)))
new_Z'f16 struct = do
    result <- C'.new (U'.message struct)
    set_Z'f16 struct result
    pure result
set_Z'zdatevec :: U'.RWCtx m s => Z (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (Zdate (M'.MutMsg s))) -> m ()
set_Z'zdatevec(Z_newtype_ struct) value = do
    H'.setWordField struct (37 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'zdatevec :: U'.RWCtx m s => Int -> Z (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (Zdate (M'.MutMsg s))))
new_Z'zdatevec len struct = do
    result <- C'.newList (U'.message struct) len
    set_Z'zdatevec struct result
    pure result
set_Z'zdatavec :: U'.RWCtx m s => Z (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (Zdata (M'.MutMsg s))) -> m ()
set_Z'zdatavec(Z_newtype_ struct) value = do
    H'.setWordField struct (38 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'zdatavec :: U'.RWCtx m s => Int -> Z (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (Zdata (M'.MutMsg s))))
new_Z'zdatavec len struct = do
    result <- C'.newList (U'.message struct) len
    set_Z'zdatavec struct result
    pure result
set_Z'boolvec :: U'.RWCtx m s => Z (M'.MutMsg s) -> (B'.List (M'.MutMsg s) Bool) -> m ()
set_Z'boolvec(Z_newtype_ struct) value = do
    H'.setWordField struct (39 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'boolvec :: U'.RWCtx m s => Int -> Z (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) Bool))
new_Z'boolvec len struct = do
    result <- C'.newList (U'.message struct) len
    set_Z'boolvec struct result
    pure result
set_Z'datavec :: U'.RWCtx m s => Z (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (B'.Data (M'.MutMsg s))) -> m ()
set_Z'datavec(Z_newtype_ struct) value = do
    H'.setWordField struct (40 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'datavec :: U'.RWCtx m s => Int -> Z (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (B'.Data (M'.MutMsg s))))
new_Z'datavec len struct = do
    result <- C'.newList (U'.message struct) len
    set_Z'datavec struct result
    pure result
set_Z'textvec :: U'.RWCtx m s => Z (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (B'.Text (M'.MutMsg s))) -> m ()
set_Z'textvec(Z_newtype_ struct) value = do
    H'.setWordField struct (41 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'textvec :: U'.RWCtx m s => Int -> Z (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (B'.Text (M'.MutMsg s))))
new_Z'textvec len struct = do
    result <- C'.newList (U'.message struct) len
    set_Z'textvec struct result
    pure result
set_Z'grp :: U'.RWCtx m s => Z (M'.MutMsg s) -> m (Z'grp'group' (M'.MutMsg s))
set_Z'grp (Z_newtype_ struct) = do
    H'.setWordField struct (42 :: Word16) 0 0 0
    pure $ Z'grp'group'_newtype_ struct
set_Z'echo :: U'.RWCtx m s => Z (M'.MutMsg s) -> (Echo (M'.MutMsg s)) -> m ()
set_Z'echo(Z_newtype_ struct) value = do
    H'.setWordField struct (43 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
set_Z'echoBases :: U'.RWCtx m s => Z (M'.MutMsg s) -> (EchoBases (M'.MutMsg s)) -> m ()
set_Z'echoBases(Z_newtype_ struct) value = do
    H'.setWordField struct (44 :: Word16) 0 0 0
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Z'echoBases :: U'.RWCtx m s => Z (M'.MutMsg s) -> m ((EchoBases (M'.MutMsg s)))
new_Z'echoBases struct = do
    result <- C'.new (U'.message struct)
    set_Z'echoBases struct result
    pure result
set_Z'unknown' :: U'.RWCtx m s => Z (M'.MutMsg s) -> Word16 -> m ()
set_Z'unknown'(Z_newtype_ struct) tagValue = H'.setWordField struct (tagValue :: Word16) 0 0 0
newtype Z'grp'group' msg = Z'grp'group'_newtype_ (U'.Struct msg)
instance U'.TraverseMsg Z'grp'group' where
    tMsg f (Z'grp'group'_newtype_ s) = Z'grp'group'_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (Z'grp'group' msg) where
    fromStruct = pure . Z'grp'group'_newtype_
instance C'.ToStruct msg (Z'grp'group' msg) where
    toStruct (Z'grp'group'_newtype_ struct) = struct
instance U'.HasMessage (Z'grp'group' msg) where
    type InMessage (Z'grp'group' msg) = msg
    message (Z'grp'group'_newtype_ struct) = U'.message struct
instance U'.MessageDefault (Z'grp'group' msg) where
    messageDefault = Z'grp'group'_newtype_ . U'.messageDefault
get_Z'grp'first :: U'.ReadCtx m msg => Z'grp'group' msg -> m Word64
get_Z'grp'first (Z'grp'group'_newtype_ struct) = H'.getWordField struct 1 0 0
set_Z'grp'first :: U'.RWCtx m s => Z'grp'group' (M'.MutMsg s) -> Word64 -> m ()
set_Z'grp'first (Z'grp'group'_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 1 0 0
get_Z'grp'second :: U'.ReadCtx m msg => Z'grp'group' msg -> m Word64
get_Z'grp'second (Z'grp'group'_newtype_ struct) = H'.getWordField struct 2 0 0
set_Z'grp'second :: U'.RWCtx m s => Z'grp'group' (M'.MutMsg s) -> Word64 -> m ()
set_Z'grp'second (Z'grp'group'_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 2 0 0
instance C'.FromStruct msg (Z' msg) where
    fromStruct struct = do
        tag <-  H'.getWordField struct 0 0 0
        case tag of
            44 -> Z'echoBases <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            43 -> Z'echo <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            42 -> Z'grp <$> C'.fromStruct struct
            41 -> Z'textvec <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            40 -> Z'datavec <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            39 -> Z'boolvec <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            38 -> Z'zdatavec <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            37 -> Z'zdatevec <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            36 -> Z'f16 <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            35 -> Z'a320 <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            34 -> Z'b737 <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            33 -> Z'airport <$>  H'.getWordField struct 1 0 0
            32 -> Z'planebase <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            31 -> Z'regression <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            30 -> Z'aircraft <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            29 -> Z'aircraftvec <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            28 -> Z'zdata <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            27 -> Z'zdate <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            26 -> Z'zvecvec <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            25 -> Z'zvec <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            24 -> Z'u8vec <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            23 -> Z'u16vec <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            22 -> Z'u32vec <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            21 -> Z'u64vec <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            20 -> Z'i8vec <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            19 -> Z'i16vec <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            18 -> Z'i32vec <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            17 -> Z'i64vec <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            16 -> Z'f32vec <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            15 -> Z'f64vec <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            14 -> Z'blob <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            13 -> Z'text <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            12 -> Z'bool <$>  H'.getWordField struct 1 0 0
            11 -> Z'u8 <$>  H'.getWordField struct 1 0 0
            10 -> Z'u16 <$>  H'.getWordField struct 1 0 0
            9 -> Z'u32 <$>  H'.getWordField struct 1 0 0
            8 -> Z'u64 <$>  H'.getWordField struct 1 0 0
            7 -> Z'i8 <$>  H'.getWordField struct 1 0 0
            6 -> Z'i16 <$>  H'.getWordField struct 1 0 0
            5 -> Z'i32 <$>  H'.getWordField struct 1 0 0
            4 -> Z'i64 <$>  H'.getWordField struct 1 0 0
            3 -> Z'f32 <$>  H'.getWordField struct 1 0 0
            2 -> Z'f64 <$>  H'.getWordField struct 1 0 0
            1 -> Z'zz <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            0 -> pure Z'void
            _ -> pure $ Z'unknown' tag
newtype Zdata msg = Zdata_newtype_ (U'.Struct msg)
instance U'.TraverseMsg Zdata where
    tMsg f (Zdata_newtype_ s) = Zdata_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (Zdata msg) where
    fromStruct = pure . Zdata_newtype_
instance C'.ToStruct msg (Zdata msg) where
    toStruct (Zdata_newtype_ struct) = struct
instance U'.HasMessage (Zdata msg) where
    type InMessage (Zdata msg) = msg
    message (Zdata_newtype_ struct) = U'.message struct
instance U'.MessageDefault (Zdata msg) where
    messageDefault = Zdata_newtype_ . U'.messageDefault
instance B'.ListElem msg (Zdata msg) where
    newtype List msg (Zdata msg) = List_Zdata (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_Zdata <$> C'.fromPtr msg ptr
    toUntypedList (List_Zdata l) = U'.ListStruct l
    length (List_Zdata l) = U'.length l
    index i (List_Zdata l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Zdata msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (Zdata msg) where
    fromPtr msg ptr = Zdata_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (Zdata_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (Zdata (M'.MutMsg s)) where
    setIndex (Zdata_newtype_ elt) i (List_Zdata l) = U'.setIndex elt i l
    newList msg len = List_Zdata <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (Zdata (M'.MutMsg s)) where
    new msg = Zdata_newtype_ <$> U'.allocStruct msg 0 1
get_Zdata'data_ :: U'.ReadCtx m msg => Zdata msg -> m (B'.Data msg)
get_Zdata'data_ (Zdata_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_Zdata'data_ :: U'.ReadCtx m msg => Zdata msg -> m Bool
has_Zdata'data_(Zdata_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_Zdata'data_ :: U'.RWCtx m s => Zdata (M'.MutMsg s) -> (B'.Data (M'.MutMsg s)) -> m ()
set_Zdata'data_ (Zdata_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Zdata'data_ :: U'.RWCtx m s => Int -> Zdata (M'.MutMsg s) -> m ((B'.Data (M'.MutMsg s)))
new_Zdata'data_ len struct = do
    result <- B'.newData (U'.message struct) len
    set_Zdata'data_ struct result
    pure result
newtype Zdate msg = Zdate_newtype_ (U'.Struct msg)
instance U'.TraverseMsg Zdate where
    tMsg f (Zdate_newtype_ s) = Zdate_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (Zdate msg) where
    fromStruct = pure . Zdate_newtype_
instance C'.ToStruct msg (Zdate msg) where
    toStruct (Zdate_newtype_ struct) = struct
instance U'.HasMessage (Zdate msg) where
    type InMessage (Zdate msg) = msg
    message (Zdate_newtype_ struct) = U'.message struct
instance U'.MessageDefault (Zdate msg) where
    messageDefault = Zdate_newtype_ . U'.messageDefault
instance B'.ListElem msg (Zdate msg) where
    newtype List msg (Zdate msg) = List_Zdate (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_Zdate <$> C'.fromPtr msg ptr
    toUntypedList (List_Zdate l) = U'.ListStruct l
    length (List_Zdate l) = U'.length l
    index i (List_Zdate l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Zdate msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (Zdate msg) where
    fromPtr msg ptr = Zdate_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (Zdate_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (Zdate (M'.MutMsg s)) where
    setIndex (Zdate_newtype_ elt) i (List_Zdate l) = U'.setIndex elt i l
    newList msg len = List_Zdate <$> U'.allocCompositeList msg 1 0 len
instance C'.Allocate s (Zdate (M'.MutMsg s)) where
    new msg = Zdate_newtype_ <$> U'.allocStruct msg 1 0
get_Zdate'year :: U'.ReadCtx m msg => Zdate msg -> m Int16
get_Zdate'year (Zdate_newtype_ struct) = H'.getWordField struct 0 0 0
set_Zdate'year :: U'.RWCtx m s => Zdate (M'.MutMsg s) -> Int16 -> m ()
set_Zdate'year (Zdate_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word16) 0 0 0
get_Zdate'month :: U'.ReadCtx m msg => Zdate msg -> m Word8
get_Zdate'month (Zdate_newtype_ struct) = H'.getWordField struct 0 16 0
set_Zdate'month :: U'.RWCtx m s => Zdate (M'.MutMsg s) -> Word8 -> m ()
set_Zdate'month (Zdate_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word8) 0 16 0
get_Zdate'day :: U'.ReadCtx m msg => Zdate msg -> m Word8
get_Zdate'day (Zdate_newtype_ struct) = H'.getWordField struct 0 24 0
set_Zdate'day :: U'.RWCtx m s => Zdate (M'.MutMsg s) -> Word8 -> m ()
set_Zdate'day (Zdate_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word8) 0 24 0
newtype Zjob msg = Zjob_newtype_ (U'.Struct msg)
instance U'.TraverseMsg Zjob where
    tMsg f (Zjob_newtype_ s) = Zjob_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (Zjob msg) where
    fromStruct = pure . Zjob_newtype_
instance C'.ToStruct msg (Zjob msg) where
    toStruct (Zjob_newtype_ struct) = struct
instance U'.HasMessage (Zjob msg) where
    type InMessage (Zjob msg) = msg
    message (Zjob_newtype_ struct) = U'.message struct
instance U'.MessageDefault (Zjob msg) where
    messageDefault = Zjob_newtype_ . U'.messageDefault
instance B'.ListElem msg (Zjob msg) where
    newtype List msg (Zjob msg) = List_Zjob (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_Zjob <$> C'.fromPtr msg ptr
    toUntypedList (List_Zjob l) = U'.ListStruct l
    length (List_Zjob l) = U'.length l
    index i (List_Zjob l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Zjob msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (Zjob msg) where
    fromPtr msg ptr = Zjob_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (Zjob_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (Zjob (M'.MutMsg s)) where
    setIndex (Zjob_newtype_ elt) i (List_Zjob l) = U'.setIndex elt i l
    newList msg len = List_Zjob <$> U'.allocCompositeList msg 0 2 len
instance C'.Allocate s (Zjob (M'.MutMsg s)) where
    new msg = Zjob_newtype_ <$> U'.allocStruct msg 0 2
get_Zjob'cmd :: U'.ReadCtx m msg => Zjob msg -> m (B'.Text msg)
get_Zjob'cmd (Zjob_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_Zjob'cmd :: U'.ReadCtx m msg => Zjob msg -> m Bool
has_Zjob'cmd(Zjob_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_Zjob'cmd :: U'.RWCtx m s => Zjob (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_Zjob'cmd (Zjob_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Zjob'cmd :: U'.RWCtx m s => Int -> Zjob (M'.MutMsg s) -> m ((B'.Text (M'.MutMsg s)))
new_Zjob'cmd len struct = do
    result <- B'.newText (U'.message struct) len
    set_Zjob'cmd struct result
    pure result
get_Zjob'args :: U'.ReadCtx m msg => Zjob msg -> m (B'.List msg (B'.Text msg))
get_Zjob'args (Zjob_newtype_ struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)
has_Zjob'args :: U'.ReadCtx m msg => Zjob msg -> m Bool
has_Zjob'args(Zjob_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
set_Zjob'args :: U'.RWCtx m s => Zjob (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (B'.Text (M'.MutMsg s))) -> m ()
set_Zjob'args (Zjob_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 1 struct
new_Zjob'args :: U'.RWCtx m s => Int -> Zjob (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (B'.Text (M'.MutMsg s))))
new_Zjob'args len struct = do
    result <- C'.newList (U'.message struct) len
    set_Zjob'args struct result
    pure result
newtype Zserver msg = Zserver_newtype_ (U'.Struct msg)
instance U'.TraverseMsg Zserver where
    tMsg f (Zserver_newtype_ s) = Zserver_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (Zserver msg) where
    fromStruct = pure . Zserver_newtype_
instance C'.ToStruct msg (Zserver msg) where
    toStruct (Zserver_newtype_ struct) = struct
instance U'.HasMessage (Zserver msg) where
    type InMessage (Zserver msg) = msg
    message (Zserver_newtype_ struct) = U'.message struct
instance U'.MessageDefault (Zserver msg) where
    messageDefault = Zserver_newtype_ . U'.messageDefault
instance B'.ListElem msg (Zserver msg) where
    newtype List msg (Zserver msg) = List_Zserver (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_Zserver <$> C'.fromPtr msg ptr
    toUntypedList (List_Zserver l) = U'.ListStruct l
    length (List_Zserver l) = U'.length l
    index i (List_Zserver l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Zserver msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (Zserver msg) where
    fromPtr msg ptr = Zserver_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (Zserver_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (Zserver (M'.MutMsg s)) where
    setIndex (Zserver_newtype_ elt) i (List_Zserver l) = U'.setIndex elt i l
    newList msg len = List_Zserver <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (Zserver (M'.MutMsg s)) where
    new msg = Zserver_newtype_ <$> U'.allocStruct msg 0 1
get_Zserver'waitingjobs :: U'.ReadCtx m msg => Zserver msg -> m (B'.List msg (Zjob msg))
get_Zserver'waitingjobs (Zserver_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_Zserver'waitingjobs :: U'.ReadCtx m msg => Zserver msg -> m Bool
has_Zserver'waitingjobs(Zserver_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_Zserver'waitingjobs :: U'.RWCtx m s => Zserver (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (Zjob (M'.MutMsg s))) -> m ()
set_Zserver'waitingjobs (Zserver_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Zserver'waitingjobs :: U'.RWCtx m s => Int -> Zserver (M'.MutMsg s) -> m ((B'.List (M'.MutMsg s) (Zjob (M'.MutMsg s))))
new_Zserver'waitingjobs len struct = do
    result <- C'.newList (U'.message struct) len
    set_Zserver'waitingjobs struct result
    pure result
constDate :: (Zdate M'.ConstMsg)
constDate = H'.getPtrConst $ Data.ByteString.pack [0,0,0,0,3,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,223,7,8,27,0,0,0,0]
constEnum :: Airport
constEnum = C'.fromWord 1
constList :: (B'.List M'.ConstMsg (Zdate M'.ConstMsg))
constList = H'.getPtrConst $ Data.ByteString.pack [0,0,0,0,5,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,23,0,0,0,8,0,0,0,1,0,0,0,223,7,8,27,0,0,0,0,223,7,8,28,0,0,0,0]
newtype CallSequence'getNumber'params msg = CallSequence'getNumber'params_newtype_ (U'.Struct msg)
instance U'.TraverseMsg CallSequence'getNumber'params where
    tMsg f (CallSequence'getNumber'params_newtype_ s) = CallSequence'getNumber'params_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (CallSequence'getNumber'params msg) where
    fromStruct = pure . CallSequence'getNumber'params_newtype_
instance C'.ToStruct msg (CallSequence'getNumber'params msg) where
    toStruct (CallSequence'getNumber'params_newtype_ struct) = struct
instance U'.HasMessage (CallSequence'getNumber'params msg) where
    type InMessage (CallSequence'getNumber'params msg) = msg
    message (CallSequence'getNumber'params_newtype_ struct) = U'.message struct
instance U'.MessageDefault (CallSequence'getNumber'params msg) where
    messageDefault = CallSequence'getNumber'params_newtype_ . U'.messageDefault
instance B'.ListElem msg (CallSequence'getNumber'params msg) where
    newtype List msg (CallSequence'getNumber'params msg) = List_CallSequence'getNumber'params (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_CallSequence'getNumber'params <$> C'.fromPtr msg ptr
    toUntypedList (List_CallSequence'getNumber'params l) = U'.ListStruct l
    length (List_CallSequence'getNumber'params l) = U'.length l
    index i (List_CallSequence'getNumber'params l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (CallSequence'getNumber'params msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (CallSequence'getNumber'params msg) where
    fromPtr msg ptr = CallSequence'getNumber'params_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (CallSequence'getNumber'params_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (CallSequence'getNumber'params (M'.MutMsg s)) where
    setIndex (CallSequence'getNumber'params_newtype_ elt) i (List_CallSequence'getNumber'params l) = U'.setIndex elt i l
    newList msg len = List_CallSequence'getNumber'params <$> U'.allocCompositeList msg 0 0 len
instance C'.Allocate s (CallSequence'getNumber'params (M'.MutMsg s)) where
    new msg = CallSequence'getNumber'params_newtype_ <$> U'.allocStruct msg 0 0
newtype CallSequence'getNumber'results msg = CallSequence'getNumber'results_newtype_ (U'.Struct msg)
instance U'.TraverseMsg CallSequence'getNumber'results where
    tMsg f (CallSequence'getNumber'results_newtype_ s) = CallSequence'getNumber'results_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (CallSequence'getNumber'results msg) where
    fromStruct = pure . CallSequence'getNumber'results_newtype_
instance C'.ToStruct msg (CallSequence'getNumber'results msg) where
    toStruct (CallSequence'getNumber'results_newtype_ struct) = struct
instance U'.HasMessage (CallSequence'getNumber'results msg) where
    type InMessage (CallSequence'getNumber'results msg) = msg
    message (CallSequence'getNumber'results_newtype_ struct) = U'.message struct
instance U'.MessageDefault (CallSequence'getNumber'results msg) where
    messageDefault = CallSequence'getNumber'results_newtype_ . U'.messageDefault
instance B'.ListElem msg (CallSequence'getNumber'results msg) where
    newtype List msg (CallSequence'getNumber'results msg) = List_CallSequence'getNumber'results (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_CallSequence'getNumber'results <$> C'.fromPtr msg ptr
    toUntypedList (List_CallSequence'getNumber'results l) = U'.ListStruct l
    length (List_CallSequence'getNumber'results l) = U'.length l
    index i (List_CallSequence'getNumber'results l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (CallSequence'getNumber'results msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (CallSequence'getNumber'results msg) where
    fromPtr msg ptr = CallSequence'getNumber'results_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (CallSequence'getNumber'results_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (CallSequence'getNumber'results (M'.MutMsg s)) where
    setIndex (CallSequence'getNumber'results_newtype_ elt) i (List_CallSequence'getNumber'results l) = U'.setIndex elt i l
    newList msg len = List_CallSequence'getNumber'results <$> U'.allocCompositeList msg 1 0 len
instance C'.Allocate s (CallSequence'getNumber'results (M'.MutMsg s)) where
    new msg = CallSequence'getNumber'results_newtype_ <$> U'.allocStruct msg 1 0
get_CallSequence'getNumber'results'n :: U'.ReadCtx m msg => CallSequence'getNumber'results msg -> m Word32
get_CallSequence'getNumber'results'n (CallSequence'getNumber'results_newtype_ struct) = H'.getWordField struct 0 0 0
set_CallSequence'getNumber'results'n :: U'.RWCtx m s => CallSequence'getNumber'results (M'.MutMsg s) -> Word32 -> m ()
set_CallSequence'getNumber'results'n (CallSequence'getNumber'results_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0
newtype CounterAcceptor'accept'params msg = CounterAcceptor'accept'params_newtype_ (U'.Struct msg)
instance U'.TraverseMsg CounterAcceptor'accept'params where
    tMsg f (CounterAcceptor'accept'params_newtype_ s) = CounterAcceptor'accept'params_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (CounterAcceptor'accept'params msg) where
    fromStruct = pure . CounterAcceptor'accept'params_newtype_
instance C'.ToStruct msg (CounterAcceptor'accept'params msg) where
    toStruct (CounterAcceptor'accept'params_newtype_ struct) = struct
instance U'.HasMessage (CounterAcceptor'accept'params msg) where
    type InMessage (CounterAcceptor'accept'params msg) = msg
    message (CounterAcceptor'accept'params_newtype_ struct) = U'.message struct
instance U'.MessageDefault (CounterAcceptor'accept'params msg) where
    messageDefault = CounterAcceptor'accept'params_newtype_ . U'.messageDefault
instance B'.ListElem msg (CounterAcceptor'accept'params msg) where
    newtype List msg (CounterAcceptor'accept'params msg) = List_CounterAcceptor'accept'params (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_CounterAcceptor'accept'params <$> C'.fromPtr msg ptr
    toUntypedList (List_CounterAcceptor'accept'params l) = U'.ListStruct l
    length (List_CounterAcceptor'accept'params l) = U'.length l
    index i (List_CounterAcceptor'accept'params l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (CounterAcceptor'accept'params msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (CounterAcceptor'accept'params msg) where
    fromPtr msg ptr = CounterAcceptor'accept'params_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (CounterAcceptor'accept'params_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (CounterAcceptor'accept'params (M'.MutMsg s)) where
    setIndex (CounterAcceptor'accept'params_newtype_ elt) i (List_CounterAcceptor'accept'params l) = U'.setIndex elt i l
    newList msg len = List_CounterAcceptor'accept'params <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (CounterAcceptor'accept'params (M'.MutMsg s)) where
    new msg = CounterAcceptor'accept'params_newtype_ <$> U'.allocStruct msg 0 1
get_CounterAcceptor'accept'params'counter :: U'.ReadCtx m msg => CounterAcceptor'accept'params msg -> m (CallSequence msg)
get_CounterAcceptor'accept'params'counter (CounterAcceptor'accept'params_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_CounterAcceptor'accept'params'counter :: U'.ReadCtx m msg => CounterAcceptor'accept'params msg -> m Bool
has_CounterAcceptor'accept'params'counter(CounterAcceptor'accept'params_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_CounterAcceptor'accept'params'counter :: U'.RWCtx m s => CounterAcceptor'accept'params (M'.MutMsg s) -> (CallSequence (M'.MutMsg s)) -> m ()
set_CounterAcceptor'accept'params'counter (CounterAcceptor'accept'params_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
newtype CounterAcceptor'accept'results msg = CounterAcceptor'accept'results_newtype_ (U'.Struct msg)
instance U'.TraverseMsg CounterAcceptor'accept'results where
    tMsg f (CounterAcceptor'accept'results_newtype_ s) = CounterAcceptor'accept'results_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (CounterAcceptor'accept'results msg) where
    fromStruct = pure . CounterAcceptor'accept'results_newtype_
instance C'.ToStruct msg (CounterAcceptor'accept'results msg) where
    toStruct (CounterAcceptor'accept'results_newtype_ struct) = struct
instance U'.HasMessage (CounterAcceptor'accept'results msg) where
    type InMessage (CounterAcceptor'accept'results msg) = msg
    message (CounterAcceptor'accept'results_newtype_ struct) = U'.message struct
instance U'.MessageDefault (CounterAcceptor'accept'results msg) where
    messageDefault = CounterAcceptor'accept'results_newtype_ . U'.messageDefault
instance B'.ListElem msg (CounterAcceptor'accept'results msg) where
    newtype List msg (CounterAcceptor'accept'results msg) = List_CounterAcceptor'accept'results (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_CounterAcceptor'accept'results <$> C'.fromPtr msg ptr
    toUntypedList (List_CounterAcceptor'accept'results l) = U'.ListStruct l
    length (List_CounterAcceptor'accept'results l) = U'.length l
    index i (List_CounterAcceptor'accept'results l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (CounterAcceptor'accept'results msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (CounterAcceptor'accept'results msg) where
    fromPtr msg ptr = CounterAcceptor'accept'results_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (CounterAcceptor'accept'results_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (CounterAcceptor'accept'results (M'.MutMsg s)) where
    setIndex (CounterAcceptor'accept'results_newtype_ elt) i (List_CounterAcceptor'accept'results l) = U'.setIndex elt i l
    newList msg len = List_CounterAcceptor'accept'results <$> U'.allocCompositeList msg 0 0 len
instance C'.Allocate s (CounterAcceptor'accept'results (M'.MutMsg s)) where
    new msg = CounterAcceptor'accept'results_newtype_ <$> U'.allocStruct msg 0 0
newtype CounterFactory'newCounter'params msg = CounterFactory'newCounter'params_newtype_ (U'.Struct msg)
instance U'.TraverseMsg CounterFactory'newCounter'params where
    tMsg f (CounterFactory'newCounter'params_newtype_ s) = CounterFactory'newCounter'params_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (CounterFactory'newCounter'params msg) where
    fromStruct = pure . CounterFactory'newCounter'params_newtype_
instance C'.ToStruct msg (CounterFactory'newCounter'params msg) where
    toStruct (CounterFactory'newCounter'params_newtype_ struct) = struct
instance U'.HasMessage (CounterFactory'newCounter'params msg) where
    type InMessage (CounterFactory'newCounter'params msg) = msg
    message (CounterFactory'newCounter'params_newtype_ struct) = U'.message struct
instance U'.MessageDefault (CounterFactory'newCounter'params msg) where
    messageDefault = CounterFactory'newCounter'params_newtype_ . U'.messageDefault
instance B'.ListElem msg (CounterFactory'newCounter'params msg) where
    newtype List msg (CounterFactory'newCounter'params msg) = List_CounterFactory'newCounter'params (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_CounterFactory'newCounter'params <$> C'.fromPtr msg ptr
    toUntypedList (List_CounterFactory'newCounter'params l) = U'.ListStruct l
    length (List_CounterFactory'newCounter'params l) = U'.length l
    index i (List_CounterFactory'newCounter'params l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (CounterFactory'newCounter'params msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (CounterFactory'newCounter'params msg) where
    fromPtr msg ptr = CounterFactory'newCounter'params_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (CounterFactory'newCounter'params_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (CounterFactory'newCounter'params (M'.MutMsg s)) where
    setIndex (CounterFactory'newCounter'params_newtype_ elt) i (List_CounterFactory'newCounter'params l) = U'.setIndex elt i l
    newList msg len = List_CounterFactory'newCounter'params <$> U'.allocCompositeList msg 1 0 len
instance C'.Allocate s (CounterFactory'newCounter'params (M'.MutMsg s)) where
    new msg = CounterFactory'newCounter'params_newtype_ <$> U'.allocStruct msg 1 0
get_CounterFactory'newCounter'params'start :: U'.ReadCtx m msg => CounterFactory'newCounter'params msg -> m Word32
get_CounterFactory'newCounter'params'start (CounterFactory'newCounter'params_newtype_ struct) = H'.getWordField struct 0 0 0
set_CounterFactory'newCounter'params'start :: U'.RWCtx m s => CounterFactory'newCounter'params (M'.MutMsg s) -> Word32 -> m ()
set_CounterFactory'newCounter'params'start (CounterFactory'newCounter'params_newtype_ struct) value = H'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0
newtype CounterFactory'newCounter'results msg = CounterFactory'newCounter'results_newtype_ (U'.Struct msg)
instance U'.TraverseMsg CounterFactory'newCounter'results where
    tMsg f (CounterFactory'newCounter'results_newtype_ s) = CounterFactory'newCounter'results_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (CounterFactory'newCounter'results msg) where
    fromStruct = pure . CounterFactory'newCounter'results_newtype_
instance C'.ToStruct msg (CounterFactory'newCounter'results msg) where
    toStruct (CounterFactory'newCounter'results_newtype_ struct) = struct
instance U'.HasMessage (CounterFactory'newCounter'results msg) where
    type InMessage (CounterFactory'newCounter'results msg) = msg
    message (CounterFactory'newCounter'results_newtype_ struct) = U'.message struct
instance U'.MessageDefault (CounterFactory'newCounter'results msg) where
    messageDefault = CounterFactory'newCounter'results_newtype_ . U'.messageDefault
instance B'.ListElem msg (CounterFactory'newCounter'results msg) where
    newtype List msg (CounterFactory'newCounter'results msg) = List_CounterFactory'newCounter'results (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_CounterFactory'newCounter'results <$> C'.fromPtr msg ptr
    toUntypedList (List_CounterFactory'newCounter'results l) = U'.ListStruct l
    length (List_CounterFactory'newCounter'results l) = U'.length l
    index i (List_CounterFactory'newCounter'results l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (CounterFactory'newCounter'results msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (CounterFactory'newCounter'results msg) where
    fromPtr msg ptr = CounterFactory'newCounter'results_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (CounterFactory'newCounter'results_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (CounterFactory'newCounter'results (M'.MutMsg s)) where
    setIndex (CounterFactory'newCounter'results_newtype_ elt) i (List_CounterFactory'newCounter'results l) = U'.setIndex elt i l
    newList msg len = List_CounterFactory'newCounter'results <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (CounterFactory'newCounter'results (M'.MutMsg s)) where
    new msg = CounterFactory'newCounter'results_newtype_ <$> U'.allocStruct msg 0 1
get_CounterFactory'newCounter'results'counter :: U'.ReadCtx m msg => CounterFactory'newCounter'results msg -> m (CallSequence msg)
get_CounterFactory'newCounter'results'counter (CounterFactory'newCounter'results_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_CounterFactory'newCounter'results'counter :: U'.ReadCtx m msg => CounterFactory'newCounter'results msg -> m Bool
has_CounterFactory'newCounter'results'counter(CounterFactory'newCounter'results_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_CounterFactory'newCounter'results'counter :: U'.RWCtx m s => CounterFactory'newCounter'results (M'.MutMsg s) -> (CallSequence (M'.MutMsg s)) -> m ()
set_CounterFactory'newCounter'results'counter (CounterFactory'newCounter'results_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
newtype Echo'echo'params msg = Echo'echo'params_newtype_ (U'.Struct msg)
instance U'.TraverseMsg Echo'echo'params where
    tMsg f (Echo'echo'params_newtype_ s) = Echo'echo'params_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (Echo'echo'params msg) where
    fromStruct = pure . Echo'echo'params_newtype_
instance C'.ToStruct msg (Echo'echo'params msg) where
    toStruct (Echo'echo'params_newtype_ struct) = struct
instance U'.HasMessage (Echo'echo'params msg) where
    type InMessage (Echo'echo'params msg) = msg
    message (Echo'echo'params_newtype_ struct) = U'.message struct
instance U'.MessageDefault (Echo'echo'params msg) where
    messageDefault = Echo'echo'params_newtype_ . U'.messageDefault
instance B'.ListElem msg (Echo'echo'params msg) where
    newtype List msg (Echo'echo'params msg) = List_Echo'echo'params (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_Echo'echo'params <$> C'.fromPtr msg ptr
    toUntypedList (List_Echo'echo'params l) = U'.ListStruct l
    length (List_Echo'echo'params l) = U'.length l
    index i (List_Echo'echo'params l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Echo'echo'params msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (Echo'echo'params msg) where
    fromPtr msg ptr = Echo'echo'params_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (Echo'echo'params_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (Echo'echo'params (M'.MutMsg s)) where
    setIndex (Echo'echo'params_newtype_ elt) i (List_Echo'echo'params l) = U'.setIndex elt i l
    newList msg len = List_Echo'echo'params <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (Echo'echo'params (M'.MutMsg s)) where
    new msg = Echo'echo'params_newtype_ <$> U'.allocStruct msg 0 1
get_Echo'echo'params'in_ :: U'.ReadCtx m msg => Echo'echo'params msg -> m (B'.Text msg)
get_Echo'echo'params'in_ (Echo'echo'params_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_Echo'echo'params'in_ :: U'.ReadCtx m msg => Echo'echo'params msg -> m Bool
has_Echo'echo'params'in_(Echo'echo'params_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_Echo'echo'params'in_ :: U'.RWCtx m s => Echo'echo'params (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_Echo'echo'params'in_ (Echo'echo'params_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Echo'echo'params'in_ :: U'.RWCtx m s => Int -> Echo'echo'params (M'.MutMsg s) -> m ((B'.Text (M'.MutMsg s)))
new_Echo'echo'params'in_ len struct = do
    result <- B'.newText (U'.message struct) len
    set_Echo'echo'params'in_ struct result
    pure result
newtype Echo'echo'results msg = Echo'echo'results_newtype_ (U'.Struct msg)
instance U'.TraverseMsg Echo'echo'results where
    tMsg f (Echo'echo'results_newtype_ s) = Echo'echo'results_newtype_ <$> U'.tMsg f s
instance C'.FromStruct msg (Echo'echo'results msg) where
    fromStruct = pure . Echo'echo'results_newtype_
instance C'.ToStruct msg (Echo'echo'results msg) where
    toStruct (Echo'echo'results_newtype_ struct) = struct
instance U'.HasMessage (Echo'echo'results msg) where
    type InMessage (Echo'echo'results msg) = msg
    message (Echo'echo'results_newtype_ struct) = U'.message struct
instance U'.MessageDefault (Echo'echo'results msg) where
    messageDefault = Echo'echo'results_newtype_ . U'.messageDefault
instance B'.ListElem msg (Echo'echo'results msg) where
    newtype List msg (Echo'echo'results msg) = List_Echo'echo'results (U'.ListOf msg (U'.Struct msg))
    listFromPtr msg ptr = List_Echo'echo'results <$> C'.fromPtr msg ptr
    toUntypedList (List_Echo'echo'results l) = U'.ListStruct l
    length (List_Echo'echo'results l) = U'.length l
    index i (List_Echo'echo'results l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Echo'echo'results msg); go = C'.fromStruct} in go)
instance C'.IsPtr msg (Echo'echo'results msg) where
    fromPtr msg ptr = Echo'echo'results_newtype_ <$> C'.fromPtr msg ptr
    toPtr msg (Echo'echo'results_newtype_ struct) = C'.toPtr msg struct
instance B'.MutListElem s (Echo'echo'results (M'.MutMsg s)) where
    setIndex (Echo'echo'results_newtype_ elt) i (List_Echo'echo'results l) = U'.setIndex elt i l
    newList msg len = List_Echo'echo'results <$> U'.allocCompositeList msg 0 1 len
instance C'.Allocate s (Echo'echo'results (M'.MutMsg s)) where
    new msg = Echo'echo'results_newtype_ <$> U'.allocStruct msg 0 1
get_Echo'echo'results'out :: U'.ReadCtx m msg => Echo'echo'results msg -> m (B'.Text msg)
get_Echo'echo'results'out (Echo'echo'results_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)
has_Echo'echo'results'out :: U'.ReadCtx m msg => Echo'echo'results msg -> m Bool
has_Echo'echo'results'out(Echo'echo'results_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_Echo'echo'results'out :: U'.RWCtx m s => Echo'echo'results (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_Echo'echo'results'out (Echo'echo'results_newtype_ struct) value = do
    ptr <- C'.toPtr (U'.message struct) value
    U'.setPtr ptr 0 struct
new_Echo'echo'results'out :: U'.RWCtx m s => Int -> Echo'echo'results (M'.MutMsg s) -> m ((B'.Text (M'.MutMsg s)))
new_Echo'echo'results'out len struct = do
    result <- B'.newText (U'.message struct) len
    set_Echo'echo'results'out struct result
    pure result