{-# OPTIONS_GHC -Wno-unused-imports #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE DataKinds #-}
module Capnp.Capnp.Schema where

-- Code generated by capnpc-haskell. DO NOT EDIT.
-- Generated from schema file: capnp/schema.capnp

import Data.Int
import Data.Word

import GHC.OverloadedLabels

import qualified Data.Capnp as DC'
import Data.Capnp.Bits (Word1)

import qualified Data.Bits
import qualified Data.Maybe
import qualified Codec.Capnp as C'
import qualified Data.Capnp.Basics as B'
import qualified Data.Capnp.TraversalLimit as TL'
import qualified Data.Capnp.Untyped as U'
import qualified Data.Capnp.Message as M'

import qualified Capnp.ById.Xbdf87d7bb8304e81

data Type'anyPointer'unconstrained msg
    = Type'anyPointer'unconstrained'anyKind
    | Type'anyPointer'unconstrained'struct
    | Type'anyPointer'unconstrained'list
    | Type'anyPointer'unconstrained'capability
    | Type'anyPointer'unconstrained'unknown' Word16





instance C'.IsStruct msg (Type'anyPointer'unconstrained msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 1 16 0
        case tag of
            3 -> pure Type'anyPointer'unconstrained'capability
            2 -> pure Type'anyPointer'unconstrained'list
            1 -> pure Type'anyPointer'unconstrained'struct
            0 -> pure Type'anyPointer'unconstrained'anyKind
            _ -> pure $ Type'anyPointer'unconstrained'unknown' tag
instance B'.ListElem msg (Type'anyPointer'unconstrained msg) where
    newtype List msg (Type'anyPointer'unconstrained msg) = List_Type'anyPointer'unconstrained (U'.ListOf msg (U'.Struct msg))
    length (List_Type'anyPointer'unconstrained l) = U'.length l
    index i (List_Type'anyPointer'unconstrained l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Type'anyPointer'unconstrained msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (Type'anyPointer'unconstrained msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Type'anyPointer'unconstrained msg); go = C'.fromStruct} in go)

    toPtr = error "TODO: toPtr for non-newtype structs."

instance C'.IsPtr msg (B'.List msg (Type'anyPointer'unconstrained msg)) where
    fromPtr msg ptr = List_Type'anyPointer'unconstrained <$> C'.fromPtr msg ptr
    toPtr (List_Type'anyPointer'unconstrained l) = C'.toPtr l

newtype Brand msg = Brand (U'.Struct msg)

instance C'.IsStruct msg (Brand msg) where
    fromStruct = pure . Brand
instance C'.IsPtr msg (Brand msg) where
    fromPtr msg ptr = Brand <$> C'.fromPtr msg ptr
    toPtr (Brand struct) = C'.toPtr struct
instance B'.ListElem msg (Brand msg) where
    newtype List msg (Brand msg) = List_Brand (U'.ListOf msg (U'.Struct msg))
    length (List_Brand l) = U'.length l
    index i (List_Brand l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Brand msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Brand (M'.MutMsg s)) where
    setIndex (Brand elt) i (List_Brand l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Brand msg)) where
    fromPtr msg ptr = List_Brand <$> C'.fromPtr msg ptr
    toPtr (List_Brand l) = C'.toPtr l
get_Brand'scopes :: U'.ReadCtx m msg => Brand msg -> m (B'.List msg (Brand'Scope msg))
get_Brand'scopes (Brand struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "scopes" (DC'.Get m (Brand msg) ((B'.List msg (Brand'Scope msg)))) where
    fromLabel = DC'.Get get_Brand'scopes

has_Brand'scopes :: U'.ReadCtx m msg => Brand msg -> m Bool
has_Brand'scopes(Brand struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "scopes" (DC'.Has m (Brand msg)) where
    fromLabel = DC'.Has has_Brand'scopes

set_Brand'scopes :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Brand (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (Brand'Scope (M'.MutMsg s))) -> m ()
set_Brand'scopes (Brand struct) value = U'.setPtr (C'.toPtr value) 0 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "scopes" (DC'.Set m (Brand (M'.MutMsg s)) ((B'.List (M'.MutMsg s) (Brand'Scope (M'.MutMsg s))))) where
    fromLabel = DC'.Set set_Brand'scopes


newtype Method msg = Method (U'.Struct msg)

instance C'.IsStruct msg (Method msg) where
    fromStruct = pure . Method
instance C'.IsPtr msg (Method msg) where
    fromPtr msg ptr = Method <$> C'.fromPtr msg ptr
    toPtr (Method struct) = C'.toPtr struct
instance B'.ListElem msg (Method msg) where
    newtype List msg (Method msg) = List_Method (U'.ListOf msg (U'.Struct msg))
    length (List_Method l) = U'.length l
    index i (List_Method l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Method msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Method (M'.MutMsg s)) where
    setIndex (Method elt) i (List_Method l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Method msg)) where
    fromPtr msg ptr = List_Method <$> C'.fromPtr msg ptr
    toPtr (List_Method l) = C'.toPtr l
get_Method'name :: U'.ReadCtx m msg => Method msg -> m (B'.Text msg)
get_Method'name (Method struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "name" (DC'.Get m (Method msg) ((B'.Text msg))) where
    fromLabel = DC'.Get get_Method'name

has_Method'name :: U'.ReadCtx m msg => Method msg -> m Bool
has_Method'name(Method struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "name" (DC'.Has m (Method msg)) where
    fromLabel = DC'.Has has_Method'name

set_Method'name :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Method (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_Method'name (Method struct) value = U'.setPtr (C'.toPtr value) 0 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "name" (DC'.Set m (Method (M'.MutMsg s)) ((B'.Text (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Method'name


get_Method'codeOrder :: U'.ReadCtx m msg => Method msg -> m Word16
get_Method'codeOrder (Method struct) = C'.getWordField struct 0 0 0
instance U'.ReadCtx m msg => IsLabel "codeOrder" (DC'.Get m (Method msg) (Word16)) where
    fromLabel = DC'.Get get_Method'codeOrder

has_Method'codeOrder :: U'.ReadCtx m msg => Method msg -> m Bool
has_Method'codeOrder(Method struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "codeOrder" (DC'.Has m (Method msg)) where
    fromLabel = DC'.Has has_Method'codeOrder

set_Method'codeOrder :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Method (M'.MutMsg s) -> Word16 -> m ()
set_Method'codeOrder (Method struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word16) 0 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "codeOrder" (DC'.Set m (Method (M'.MutMsg s)) (Word16)) where
    fromLabel = DC'.Set set_Method'codeOrder


get_Method'paramStructType :: U'.ReadCtx m msg => Method msg -> m Word64
get_Method'paramStructType (Method struct) = C'.getWordField struct 1 0 0
instance U'.ReadCtx m msg => IsLabel "paramStructType" (DC'.Get m (Method msg) (Word64)) where
    fromLabel = DC'.Get get_Method'paramStructType

has_Method'paramStructType :: U'.ReadCtx m msg => Method msg -> m Bool
has_Method'paramStructType(Method struct) = pure $ 1 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "paramStructType" (DC'.Has m (Method msg)) where
    fromLabel = DC'.Has has_Method'paramStructType

set_Method'paramStructType :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Method (M'.MutMsg s) -> Word64 -> m ()
set_Method'paramStructType (Method struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 1 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "paramStructType" (DC'.Set m (Method (M'.MutMsg s)) (Word64)) where
    fromLabel = DC'.Set set_Method'paramStructType


get_Method'resultStructType :: U'.ReadCtx m msg => Method msg -> m Word64
get_Method'resultStructType (Method struct) = C'.getWordField struct 2 0 0
instance U'.ReadCtx m msg => IsLabel "resultStructType" (DC'.Get m (Method msg) (Word64)) where
    fromLabel = DC'.Get get_Method'resultStructType

has_Method'resultStructType :: U'.ReadCtx m msg => Method msg -> m Bool
has_Method'resultStructType(Method struct) = pure $ 2 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "resultStructType" (DC'.Has m (Method msg)) where
    fromLabel = DC'.Has has_Method'resultStructType

set_Method'resultStructType :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Method (M'.MutMsg s) -> Word64 -> m ()
set_Method'resultStructType (Method struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 2 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "resultStructType" (DC'.Set m (Method (M'.MutMsg s)) (Word64)) where
    fromLabel = DC'.Set set_Method'resultStructType


get_Method'annotations :: U'.ReadCtx m msg => Method msg -> m (B'.List msg (Annotation msg))
get_Method'annotations (Method struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "annotations" (DC'.Get m (Method msg) ((B'.List msg (Annotation msg)))) where
    fromLabel = DC'.Get get_Method'annotations

has_Method'annotations :: U'.ReadCtx m msg => Method msg -> m Bool
has_Method'annotations(Method struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
instance U'.ReadCtx m msg => IsLabel "annotations" (DC'.Has m (Method msg)) where
    fromLabel = DC'.Has has_Method'annotations

set_Method'annotations :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Method (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (Annotation (M'.MutMsg s))) -> m ()
set_Method'annotations (Method struct) value = U'.setPtr (C'.toPtr value) 1 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "annotations" (DC'.Set m (Method (M'.MutMsg s)) ((B'.List (M'.MutMsg s) (Annotation (M'.MutMsg s))))) where
    fromLabel = DC'.Set set_Method'annotations


get_Method'paramBrand :: U'.ReadCtx m msg => Method msg -> m (Brand msg)
get_Method'paramBrand (Method struct) =
    U'.getPtr 2 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "paramBrand" (DC'.Get m (Method msg) ((Brand msg))) where
    fromLabel = DC'.Get get_Method'paramBrand

has_Method'paramBrand :: U'.ReadCtx m msg => Method msg -> m Bool
has_Method'paramBrand(Method struct) = Data.Maybe.isJust <$> U'.getPtr 2 struct
instance U'.ReadCtx m msg => IsLabel "paramBrand" (DC'.Has m (Method msg)) where
    fromLabel = DC'.Has has_Method'paramBrand

set_Method'paramBrand :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Method (M'.MutMsg s) -> (Brand (M'.MutMsg s)) -> m ()
set_Method'paramBrand (Method struct) value = U'.setPtr (C'.toPtr value) 2 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "paramBrand" (DC'.Set m (Method (M'.MutMsg s)) ((Brand (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Method'paramBrand


get_Method'resultBrand :: U'.ReadCtx m msg => Method msg -> m (Brand msg)
get_Method'resultBrand (Method struct) =
    U'.getPtr 3 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "resultBrand" (DC'.Get m (Method msg) ((Brand msg))) where
    fromLabel = DC'.Get get_Method'resultBrand

has_Method'resultBrand :: U'.ReadCtx m msg => Method msg -> m Bool
has_Method'resultBrand(Method struct) = Data.Maybe.isJust <$> U'.getPtr 3 struct
instance U'.ReadCtx m msg => IsLabel "resultBrand" (DC'.Has m (Method msg)) where
    fromLabel = DC'.Has has_Method'resultBrand

set_Method'resultBrand :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Method (M'.MutMsg s) -> (Brand (M'.MutMsg s)) -> m ()
set_Method'resultBrand (Method struct) value = U'.setPtr (C'.toPtr value) 3 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "resultBrand" (DC'.Set m (Method (M'.MutMsg s)) ((Brand (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Method'resultBrand


get_Method'implicitParameters :: U'.ReadCtx m msg => Method msg -> m (B'.List msg (Node'Parameter msg))
get_Method'implicitParameters (Method struct) =
    U'.getPtr 4 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "implicitParameters" (DC'.Get m (Method msg) ((B'.List msg (Node'Parameter msg)))) where
    fromLabel = DC'.Get get_Method'implicitParameters

has_Method'implicitParameters :: U'.ReadCtx m msg => Method msg -> m Bool
has_Method'implicitParameters(Method struct) = Data.Maybe.isJust <$> U'.getPtr 4 struct
instance U'.ReadCtx m msg => IsLabel "implicitParameters" (DC'.Has m (Method msg)) where
    fromLabel = DC'.Has has_Method'implicitParameters

set_Method'implicitParameters :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Method (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (Node'Parameter (M'.MutMsg s))) -> m ()
set_Method'implicitParameters (Method struct) value = U'.setPtr (C'.toPtr value) 4 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "implicitParameters" (DC'.Set m (Method (M'.MutMsg s)) ((B'.List (M'.MutMsg s) (Node'Parameter (M'.MutMsg s))))) where
    fromLabel = DC'.Set set_Method'implicitParameters


newtype Enumerant msg = Enumerant (U'.Struct msg)

instance C'.IsStruct msg (Enumerant msg) where
    fromStruct = pure . Enumerant
instance C'.IsPtr msg (Enumerant msg) where
    fromPtr msg ptr = Enumerant <$> C'.fromPtr msg ptr
    toPtr (Enumerant struct) = C'.toPtr struct
instance B'.ListElem msg (Enumerant msg) where
    newtype List msg (Enumerant msg) = List_Enumerant (U'.ListOf msg (U'.Struct msg))
    length (List_Enumerant l) = U'.length l
    index i (List_Enumerant l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Enumerant msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Enumerant (M'.MutMsg s)) where
    setIndex (Enumerant elt) i (List_Enumerant l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Enumerant msg)) where
    fromPtr msg ptr = List_Enumerant <$> C'.fromPtr msg ptr
    toPtr (List_Enumerant l) = C'.toPtr l
get_Enumerant'name :: U'.ReadCtx m msg => Enumerant msg -> m (B'.Text msg)
get_Enumerant'name (Enumerant struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "name" (DC'.Get m (Enumerant msg) ((B'.Text msg))) where
    fromLabel = DC'.Get get_Enumerant'name

has_Enumerant'name :: U'.ReadCtx m msg => Enumerant msg -> m Bool
has_Enumerant'name(Enumerant struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "name" (DC'.Has m (Enumerant msg)) where
    fromLabel = DC'.Has has_Enumerant'name

set_Enumerant'name :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Enumerant (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_Enumerant'name (Enumerant struct) value = U'.setPtr (C'.toPtr value) 0 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "name" (DC'.Set m (Enumerant (M'.MutMsg s)) ((B'.Text (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Enumerant'name


get_Enumerant'codeOrder :: U'.ReadCtx m msg => Enumerant msg -> m Word16
get_Enumerant'codeOrder (Enumerant struct) = C'.getWordField struct 0 0 0
instance U'.ReadCtx m msg => IsLabel "codeOrder" (DC'.Get m (Enumerant msg) (Word16)) where
    fromLabel = DC'.Get get_Enumerant'codeOrder

has_Enumerant'codeOrder :: U'.ReadCtx m msg => Enumerant msg -> m Bool
has_Enumerant'codeOrder(Enumerant struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "codeOrder" (DC'.Has m (Enumerant msg)) where
    fromLabel = DC'.Has has_Enumerant'codeOrder

set_Enumerant'codeOrder :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Enumerant (M'.MutMsg s) -> Word16 -> m ()
set_Enumerant'codeOrder (Enumerant struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word16) 0 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "codeOrder" (DC'.Set m (Enumerant (M'.MutMsg s)) (Word16)) where
    fromLabel = DC'.Set set_Enumerant'codeOrder


get_Enumerant'annotations :: U'.ReadCtx m msg => Enumerant msg -> m (B'.List msg (Annotation msg))
get_Enumerant'annotations (Enumerant struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "annotations" (DC'.Get m (Enumerant msg) ((B'.List msg (Annotation msg)))) where
    fromLabel = DC'.Get get_Enumerant'annotations

has_Enumerant'annotations :: U'.ReadCtx m msg => Enumerant msg -> m Bool
has_Enumerant'annotations(Enumerant struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
instance U'.ReadCtx m msg => IsLabel "annotations" (DC'.Has m (Enumerant msg)) where
    fromLabel = DC'.Has has_Enumerant'annotations

set_Enumerant'annotations :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Enumerant (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (Annotation (M'.MutMsg s))) -> m ()
set_Enumerant'annotations (Enumerant struct) value = U'.setPtr (C'.toPtr value) 1 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "annotations" (DC'.Set m (Enumerant (M'.MutMsg s)) ((B'.List (M'.MutMsg s) (Annotation (M'.MutMsg s))))) where
    fromLabel = DC'.Set set_Enumerant'annotations


field'noDiscriminant :: Word16
field'noDiscriminant = C'.fromWord 65535

newtype Field msg = Field (U'.Struct msg)

instance C'.IsStruct msg (Field msg) where
    fromStruct = pure . Field
instance C'.IsPtr msg (Field msg) where
    fromPtr msg ptr = Field <$> C'.fromPtr msg ptr
    toPtr (Field struct) = C'.toPtr struct
instance B'.ListElem msg (Field msg) where
    newtype List msg (Field msg) = List_Field (U'.ListOf msg (U'.Struct msg))
    length (List_Field l) = U'.length l
    index i (List_Field l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Field msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Field (M'.MutMsg s)) where
    setIndex (Field elt) i (List_Field l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Field msg)) where
    fromPtr msg ptr = List_Field <$> C'.fromPtr msg ptr
    toPtr (List_Field l) = C'.toPtr l
get_Field'name :: U'.ReadCtx m msg => Field msg -> m (B'.Text msg)
get_Field'name (Field struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "name" (DC'.Get m (Field msg) ((B'.Text msg))) where
    fromLabel = DC'.Get get_Field'name

has_Field'name :: U'.ReadCtx m msg => Field msg -> m Bool
has_Field'name(Field struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "name" (DC'.Has m (Field msg)) where
    fromLabel = DC'.Has has_Field'name

set_Field'name :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Field (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_Field'name (Field struct) value = U'.setPtr (C'.toPtr value) 0 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "name" (DC'.Set m (Field (M'.MutMsg s)) ((B'.Text (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Field'name


get_Field'codeOrder :: U'.ReadCtx m msg => Field msg -> m Word16
get_Field'codeOrder (Field struct) = C'.getWordField struct 0 0 0
instance U'.ReadCtx m msg => IsLabel "codeOrder" (DC'.Get m (Field msg) (Word16)) where
    fromLabel = DC'.Get get_Field'codeOrder

has_Field'codeOrder :: U'.ReadCtx m msg => Field msg -> m Bool
has_Field'codeOrder(Field struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "codeOrder" (DC'.Has m (Field msg)) where
    fromLabel = DC'.Has has_Field'codeOrder

set_Field'codeOrder :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Field (M'.MutMsg s) -> Word16 -> m ()
set_Field'codeOrder (Field struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word16) 0 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "codeOrder" (DC'.Set m (Field (M'.MutMsg s)) (Word16)) where
    fromLabel = DC'.Set set_Field'codeOrder


get_Field'annotations :: U'.ReadCtx m msg => Field msg -> m (B'.List msg (Annotation msg))
get_Field'annotations (Field struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "annotations" (DC'.Get m (Field msg) ((B'.List msg (Annotation msg)))) where
    fromLabel = DC'.Get get_Field'annotations

has_Field'annotations :: U'.ReadCtx m msg => Field msg -> m Bool
has_Field'annotations(Field struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
instance U'.ReadCtx m msg => IsLabel "annotations" (DC'.Has m (Field msg)) where
    fromLabel = DC'.Has has_Field'annotations

set_Field'annotations :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Field (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (Annotation (M'.MutMsg s))) -> m ()
set_Field'annotations (Field struct) value = U'.setPtr (C'.toPtr value) 1 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "annotations" (DC'.Set m (Field (M'.MutMsg s)) ((B'.List (M'.MutMsg s) (Annotation (M'.MutMsg s))))) where
    fromLabel = DC'.Set set_Field'annotations


get_Field'discriminantValue :: U'.ReadCtx m msg => Field msg -> m Word16
get_Field'discriminantValue (Field struct) = C'.getWordField struct 0 16 65535
instance U'.ReadCtx m msg => IsLabel "discriminantValue" (DC'.Get m (Field msg) (Word16)) where
    fromLabel = DC'.Get get_Field'discriminantValue

has_Field'discriminantValue :: U'.ReadCtx m msg => Field msg -> m Bool
has_Field'discriminantValue(Field struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "discriminantValue" (DC'.Has m (Field msg)) where
    fromLabel = DC'.Has has_Field'discriminantValue

set_Field'discriminantValue :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Field (M'.MutMsg s) -> Word16 -> m ()
set_Field'discriminantValue (Field struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word16) 0 16 65535
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "discriminantValue" (DC'.Set m (Field (M'.MutMsg s)) (Word16)) where
    fromLabel = DC'.Set set_Field'discriminantValue


get_Field'ordinal :: U'.ReadCtx m msg => Field msg -> m (Field'ordinal msg)
get_Field'ordinal (Field struct) = C'.fromStruct struct
instance U'.ReadCtx m msg => IsLabel "ordinal" (DC'.Get m (Field msg) ((Field'ordinal msg))) where
    fromLabel = DC'.Get get_Field'ordinal

has_Field'ordinal :: U'.ReadCtx m msg => Field msg -> m Bool
has_Field'ordinal(Field struct) = pure True
instance U'.ReadCtx m msg => IsLabel "ordinal" (DC'.Has m (Field msg)) where
    fromLabel = DC'.Has has_Field'ordinal

set_Field'ordinal :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Field (M'.MutMsg s) -> (Field'ordinal (M'.MutMsg s)) -> m ()
set_Field'ordinal _ = error "TODO: generate more setters."
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "ordinal" (DC'.Set m (Field (M'.MutMsg s)) ((Field'ordinal (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Field'ordinal


get_Field'union' :: U'.ReadCtx m msg => Field msg -> m (Field' msg)
get_Field'union' (Field struct) = C'.fromStruct struct
instance U'.ReadCtx m msg => IsLabel "union'" (DC'.Get m (Field msg) ((Field' msg))) where
    fromLabel = DC'.Get get_Field'union'

has_Field'union' :: U'.ReadCtx m msg => Field msg -> m Bool
has_Field'union'(Field struct) = pure True
instance U'.ReadCtx m msg => IsLabel "union'" (DC'.Has m (Field msg)) where
    fromLabel = DC'.Has has_Field'union'

set_Field'union' :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Field (M'.MutMsg s) -> (Field' (M'.MutMsg s)) -> m ()
set_Field'union' _ = error "TODO: generate more setters."
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "union'" (DC'.Set m (Field (M'.MutMsg s)) ((Field' (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Field'union'


data Field' msg
    = Field'slot (Field'slot'group' msg)
    | Field'group (Field'group'group' msg)
    | Field'unknown' Word16
newtype Field'slot'group' msg = Field'slot'group' (U'.Struct msg)

instance C'.IsStruct msg (Field'slot'group' msg) where
    fromStruct = pure . Field'slot'group'
instance C'.IsPtr msg (Field'slot'group' msg) where
    fromPtr msg ptr = Field'slot'group' <$> C'.fromPtr msg ptr
    toPtr (Field'slot'group' struct) = C'.toPtr struct
instance B'.ListElem msg (Field'slot'group' msg) where
    newtype List msg (Field'slot'group' msg) = List_Field'slot'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Field'slot'group' l) = U'.length l
    index i (List_Field'slot'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Field'slot'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Field'slot'group' (M'.MutMsg s)) where
    setIndex (Field'slot'group' elt) i (List_Field'slot'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Field'slot'group' msg)) where
    fromPtr msg ptr = List_Field'slot'group' <$> C'.fromPtr msg ptr
    toPtr (List_Field'slot'group' l) = C'.toPtr l
get_Field'slot'offset :: U'.ReadCtx m msg => Field'slot'group' msg -> m Word32
get_Field'slot'offset (Field'slot'group' struct) = C'.getWordField struct 0 32 0
instance U'.ReadCtx m msg => IsLabel "offset" (DC'.Get m (Field'slot'group' msg) (Word32)) where
    fromLabel = DC'.Get get_Field'slot'offset

has_Field'slot'offset :: U'.ReadCtx m msg => Field'slot'group' msg -> m Bool
has_Field'slot'offset(Field'slot'group' struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "offset" (DC'.Has m (Field'slot'group' msg)) where
    fromLabel = DC'.Has has_Field'slot'offset

set_Field'slot'offset :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Field'slot'group' (M'.MutMsg s) -> Word32 -> m ()
set_Field'slot'offset (Field'slot'group' struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 32 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "offset" (DC'.Set m (Field'slot'group' (M'.MutMsg s)) (Word32)) where
    fromLabel = DC'.Set set_Field'slot'offset


get_Field'slot'type_ :: U'.ReadCtx m msg => Field'slot'group' msg -> m (Type msg)
get_Field'slot'type_ (Field'slot'group' struct) =
    U'.getPtr 2 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "type_" (DC'.Get m (Field'slot'group' msg) ((Type msg))) where
    fromLabel = DC'.Get get_Field'slot'type_

has_Field'slot'type_ :: U'.ReadCtx m msg => Field'slot'group' msg -> m Bool
has_Field'slot'type_(Field'slot'group' struct) = Data.Maybe.isJust <$> U'.getPtr 2 struct
instance U'.ReadCtx m msg => IsLabel "type_" (DC'.Has m (Field'slot'group' msg)) where
    fromLabel = DC'.Has has_Field'slot'type_

set_Field'slot'type_ :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Field'slot'group' (M'.MutMsg s) -> (Type (M'.MutMsg s)) -> m ()
set_Field'slot'type_ (Field'slot'group' struct) value = U'.setPtr (C'.toPtr value) 2 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "type_" (DC'.Set m (Field'slot'group' (M'.MutMsg s)) ((Type (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Field'slot'type_


get_Field'slot'defaultValue :: U'.ReadCtx m msg => Field'slot'group' msg -> m (Value msg)
get_Field'slot'defaultValue (Field'slot'group' struct) =
    U'.getPtr 3 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "defaultValue" (DC'.Get m (Field'slot'group' msg) ((Value msg))) where
    fromLabel = DC'.Get get_Field'slot'defaultValue

has_Field'slot'defaultValue :: U'.ReadCtx m msg => Field'slot'group' msg -> m Bool
has_Field'slot'defaultValue(Field'slot'group' struct) = Data.Maybe.isJust <$> U'.getPtr 3 struct
instance U'.ReadCtx m msg => IsLabel "defaultValue" (DC'.Has m (Field'slot'group' msg)) where
    fromLabel = DC'.Has has_Field'slot'defaultValue

set_Field'slot'defaultValue :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Field'slot'group' (M'.MutMsg s) -> (Value (M'.MutMsg s)) -> m ()
set_Field'slot'defaultValue (Field'slot'group' struct) value = U'.setPtr (C'.toPtr value) 3 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "defaultValue" (DC'.Set m (Field'slot'group' (M'.MutMsg s)) ((Value (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Field'slot'defaultValue


get_Field'slot'hadExplicitDefault :: U'.ReadCtx m msg => Field'slot'group' msg -> m Bool
get_Field'slot'hadExplicitDefault (Field'slot'group' struct) = C'.getWordField struct 2 0 0
instance U'.ReadCtx m msg => IsLabel "hadExplicitDefault" (DC'.Get m (Field'slot'group' msg) (Bool)) where
    fromLabel = DC'.Get get_Field'slot'hadExplicitDefault

has_Field'slot'hadExplicitDefault :: U'.ReadCtx m msg => Field'slot'group' msg -> m Bool
has_Field'slot'hadExplicitDefault(Field'slot'group' struct) = pure $ 2 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "hadExplicitDefault" (DC'.Has m (Field'slot'group' msg)) where
    fromLabel = DC'.Has has_Field'slot'hadExplicitDefault

set_Field'slot'hadExplicitDefault :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Field'slot'group' (M'.MutMsg s) -> Bool -> m ()
set_Field'slot'hadExplicitDefault (Field'slot'group' struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word1) 2 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "hadExplicitDefault" (DC'.Set m (Field'slot'group' (M'.MutMsg s)) (Bool)) where
    fromLabel = DC'.Set set_Field'slot'hadExplicitDefault


newtype Field'group'group' msg = Field'group'group' (U'.Struct msg)

instance C'.IsStruct msg (Field'group'group' msg) where
    fromStruct = pure . Field'group'group'
instance C'.IsPtr msg (Field'group'group' msg) where
    fromPtr msg ptr = Field'group'group' <$> C'.fromPtr msg ptr
    toPtr (Field'group'group' struct) = C'.toPtr struct
instance B'.ListElem msg (Field'group'group' msg) where
    newtype List msg (Field'group'group' msg) = List_Field'group'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Field'group'group' l) = U'.length l
    index i (List_Field'group'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Field'group'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Field'group'group' (M'.MutMsg s)) where
    setIndex (Field'group'group' elt) i (List_Field'group'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Field'group'group' msg)) where
    fromPtr msg ptr = List_Field'group'group' <$> C'.fromPtr msg ptr
    toPtr (List_Field'group'group' l) = C'.toPtr l
get_Field'group'typeId :: U'.ReadCtx m msg => Field'group'group' msg -> m Word64
get_Field'group'typeId (Field'group'group' struct) = C'.getWordField struct 2 0 0
instance U'.ReadCtx m msg => IsLabel "typeId" (DC'.Get m (Field'group'group' msg) (Word64)) where
    fromLabel = DC'.Get get_Field'group'typeId

has_Field'group'typeId :: U'.ReadCtx m msg => Field'group'group' msg -> m Bool
has_Field'group'typeId(Field'group'group' struct) = pure $ 2 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "typeId" (DC'.Has m (Field'group'group' msg)) where
    fromLabel = DC'.Has has_Field'group'typeId

set_Field'group'typeId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Field'group'group' (M'.MutMsg s) -> Word64 -> m ()
set_Field'group'typeId (Field'group'group' struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 2 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "typeId" (DC'.Set m (Field'group'group' (M'.MutMsg s)) (Word64)) where
    fromLabel = DC'.Set set_Field'group'typeId



instance C'.IsStruct msg (Field' msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 1 0 0
        case tag of
            1 -> Field'group <$> C'.fromStruct struct
            0 -> Field'slot <$> C'.fromStruct struct
            _ -> pure $ Field'unknown' tag
instance B'.ListElem msg (Field' msg) where
    newtype List msg (Field' msg) = List_Field' (U'.ListOf msg (U'.Struct msg))
    length (List_Field' l) = U'.length l
    index i (List_Field' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Field' msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (Field' msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Field' msg); go = C'.fromStruct} in go)

    toPtr = error "TODO: toPtr for non-newtype structs."

instance C'.IsPtr msg (B'.List msg (Field' msg)) where
    fromPtr msg ptr = List_Field' <$> C'.fromPtr msg ptr
    toPtr (List_Field' l) = C'.toPtr l

newtype Superclass msg = Superclass (U'.Struct msg)

instance C'.IsStruct msg (Superclass msg) where
    fromStruct = pure . Superclass
instance C'.IsPtr msg (Superclass msg) where
    fromPtr msg ptr = Superclass <$> C'.fromPtr msg ptr
    toPtr (Superclass struct) = C'.toPtr struct
instance B'.ListElem msg (Superclass msg) where
    newtype List msg (Superclass msg) = List_Superclass (U'.ListOf msg (U'.Struct msg))
    length (List_Superclass l) = U'.length l
    index i (List_Superclass l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Superclass msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Superclass (M'.MutMsg s)) where
    setIndex (Superclass elt) i (List_Superclass l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Superclass msg)) where
    fromPtr msg ptr = List_Superclass <$> C'.fromPtr msg ptr
    toPtr (List_Superclass l) = C'.toPtr l
get_Superclass'id :: U'.ReadCtx m msg => Superclass msg -> m Word64
get_Superclass'id (Superclass struct) = C'.getWordField struct 0 0 0
instance U'.ReadCtx m msg => IsLabel "id" (DC'.Get m (Superclass msg) (Word64)) where
    fromLabel = DC'.Get get_Superclass'id

has_Superclass'id :: U'.ReadCtx m msg => Superclass msg -> m Bool
has_Superclass'id(Superclass struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "id" (DC'.Has m (Superclass msg)) where
    fromLabel = DC'.Has has_Superclass'id

set_Superclass'id :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Superclass (M'.MutMsg s) -> Word64 -> m ()
set_Superclass'id (Superclass struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 0 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "id" (DC'.Set m (Superclass (M'.MutMsg s)) (Word64)) where
    fromLabel = DC'.Set set_Superclass'id


get_Superclass'brand :: U'.ReadCtx m msg => Superclass msg -> m (Brand msg)
get_Superclass'brand (Superclass struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "brand" (DC'.Get m (Superclass msg) ((Brand msg))) where
    fromLabel = DC'.Get get_Superclass'brand

has_Superclass'brand :: U'.ReadCtx m msg => Superclass msg -> m Bool
has_Superclass'brand(Superclass struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "brand" (DC'.Has m (Superclass msg)) where
    fromLabel = DC'.Has has_Superclass'brand

set_Superclass'brand :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Superclass (M'.MutMsg s) -> (Brand (M'.MutMsg s)) -> m ()
set_Superclass'brand (Superclass struct) value = U'.setPtr (C'.toPtr value) 0 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "brand" (DC'.Set m (Superclass (M'.MutMsg s)) ((Brand (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Superclass'brand


newtype Brand'Scope msg = Brand'Scope (U'.Struct msg)

instance C'.IsStruct msg (Brand'Scope msg) where
    fromStruct = pure . Brand'Scope
instance C'.IsPtr msg (Brand'Scope msg) where
    fromPtr msg ptr = Brand'Scope <$> C'.fromPtr msg ptr
    toPtr (Brand'Scope struct) = C'.toPtr struct
instance B'.ListElem msg (Brand'Scope msg) where
    newtype List msg (Brand'Scope msg) = List_Brand'Scope (U'.ListOf msg (U'.Struct msg))
    length (List_Brand'Scope l) = U'.length l
    index i (List_Brand'Scope l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Brand'Scope msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Brand'Scope (M'.MutMsg s)) where
    setIndex (Brand'Scope elt) i (List_Brand'Scope l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Brand'Scope msg)) where
    fromPtr msg ptr = List_Brand'Scope <$> C'.fromPtr msg ptr
    toPtr (List_Brand'Scope l) = C'.toPtr l
get_Brand'Scope'scopeId :: U'.ReadCtx m msg => Brand'Scope msg -> m Word64
get_Brand'Scope'scopeId (Brand'Scope struct) = C'.getWordField struct 0 0 0
instance U'.ReadCtx m msg => IsLabel "scopeId" (DC'.Get m (Brand'Scope msg) (Word64)) where
    fromLabel = DC'.Get get_Brand'Scope'scopeId

has_Brand'Scope'scopeId :: U'.ReadCtx m msg => Brand'Scope msg -> m Bool
has_Brand'Scope'scopeId(Brand'Scope struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "scopeId" (DC'.Has m (Brand'Scope msg)) where
    fromLabel = DC'.Has has_Brand'Scope'scopeId

set_Brand'Scope'scopeId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Brand'Scope (M'.MutMsg s) -> Word64 -> m ()
set_Brand'Scope'scopeId (Brand'Scope struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 0 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "scopeId" (DC'.Set m (Brand'Scope (M'.MutMsg s)) (Word64)) where
    fromLabel = DC'.Set set_Brand'Scope'scopeId


get_Brand'Scope'union' :: U'.ReadCtx m msg => Brand'Scope msg -> m (Brand'Scope' msg)
get_Brand'Scope'union' (Brand'Scope struct) = C'.fromStruct struct
instance U'.ReadCtx m msg => IsLabel "union'" (DC'.Get m (Brand'Scope msg) ((Brand'Scope' msg))) where
    fromLabel = DC'.Get get_Brand'Scope'union'

has_Brand'Scope'union' :: U'.ReadCtx m msg => Brand'Scope msg -> m Bool
has_Brand'Scope'union'(Brand'Scope struct) = pure True
instance U'.ReadCtx m msg => IsLabel "union'" (DC'.Has m (Brand'Scope msg)) where
    fromLabel = DC'.Has has_Brand'Scope'union'

set_Brand'Scope'union' :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Brand'Scope (M'.MutMsg s) -> (Brand'Scope' (M'.MutMsg s)) -> m ()
set_Brand'Scope'union' _ = error "TODO: generate more setters."
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "union'" (DC'.Set m (Brand'Scope (M'.MutMsg s)) ((Brand'Scope' (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Brand'Scope'union'


data Brand'Scope' msg
    = Brand'Scope'bind (B'.List msg (Brand'Binding msg))
    | Brand'Scope'inherit
    | Brand'Scope'unknown' Word16



instance C'.IsStruct msg (Brand'Scope' msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 1 0 0
        case tag of
            1 -> pure Brand'Scope'inherit
            0 -> Brand'Scope'bind <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            _ -> pure $ Brand'Scope'unknown' tag
instance B'.ListElem msg (Brand'Scope' msg) where
    newtype List msg (Brand'Scope' msg) = List_Brand'Scope' (U'.ListOf msg (U'.Struct msg))
    length (List_Brand'Scope' l) = U'.length l
    index i (List_Brand'Scope' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Brand'Scope' msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (Brand'Scope' msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Brand'Scope' msg); go = C'.fromStruct} in go)

    toPtr = error "TODO: toPtr for non-newtype structs."

instance C'.IsPtr msg (B'.List msg (Brand'Scope' msg)) where
    fromPtr msg ptr = List_Brand'Scope' <$> C'.fromPtr msg ptr
    toPtr (List_Brand'Scope' l) = C'.toPtr l

newtype CodeGeneratorRequest'RequestedFile'Import msg = CodeGeneratorRequest'RequestedFile'Import (U'.Struct msg)

instance C'.IsStruct msg (CodeGeneratorRequest'RequestedFile'Import msg) where
    fromStruct = pure . CodeGeneratorRequest'RequestedFile'Import
instance C'.IsPtr msg (CodeGeneratorRequest'RequestedFile'Import msg) where
    fromPtr msg ptr = CodeGeneratorRequest'RequestedFile'Import <$> C'.fromPtr msg ptr
    toPtr (CodeGeneratorRequest'RequestedFile'Import struct) = C'.toPtr struct
instance B'.ListElem msg (CodeGeneratorRequest'RequestedFile'Import msg) where
    newtype List msg (CodeGeneratorRequest'RequestedFile'Import msg) = List_CodeGeneratorRequest'RequestedFile'Import (U'.ListOf msg (U'.Struct msg))
    length (List_CodeGeneratorRequest'RequestedFile'Import l) = U'.length l
    index i (List_CodeGeneratorRequest'RequestedFile'Import l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (CodeGeneratorRequest'RequestedFile'Import msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (CodeGeneratorRequest'RequestedFile'Import (M'.MutMsg s)) where
    setIndex (CodeGeneratorRequest'RequestedFile'Import elt) i (List_CodeGeneratorRequest'RequestedFile'Import l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (CodeGeneratorRequest'RequestedFile'Import msg)) where
    fromPtr msg ptr = List_CodeGeneratorRequest'RequestedFile'Import <$> C'.fromPtr msg ptr
    toPtr (List_CodeGeneratorRequest'RequestedFile'Import l) = C'.toPtr l
get_CodeGeneratorRequest'RequestedFile'Import'id :: U'.ReadCtx m msg => CodeGeneratorRequest'RequestedFile'Import msg -> m Word64
get_CodeGeneratorRequest'RequestedFile'Import'id (CodeGeneratorRequest'RequestedFile'Import struct) = C'.getWordField struct 0 0 0
instance U'.ReadCtx m msg => IsLabel "id" (DC'.Get m (CodeGeneratorRequest'RequestedFile'Import msg) (Word64)) where
    fromLabel = DC'.Get get_CodeGeneratorRequest'RequestedFile'Import'id

has_CodeGeneratorRequest'RequestedFile'Import'id :: U'.ReadCtx m msg => CodeGeneratorRequest'RequestedFile'Import msg -> m Bool
has_CodeGeneratorRequest'RequestedFile'Import'id(CodeGeneratorRequest'RequestedFile'Import struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "id" (DC'.Has m (CodeGeneratorRequest'RequestedFile'Import msg)) where
    fromLabel = DC'.Has has_CodeGeneratorRequest'RequestedFile'Import'id

set_CodeGeneratorRequest'RequestedFile'Import'id :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => CodeGeneratorRequest'RequestedFile'Import (M'.MutMsg s) -> Word64 -> m ()
set_CodeGeneratorRequest'RequestedFile'Import'id (CodeGeneratorRequest'RequestedFile'Import struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 0 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "id" (DC'.Set m (CodeGeneratorRequest'RequestedFile'Import (M'.MutMsg s)) (Word64)) where
    fromLabel = DC'.Set set_CodeGeneratorRequest'RequestedFile'Import'id


get_CodeGeneratorRequest'RequestedFile'Import'name :: U'.ReadCtx m msg => CodeGeneratorRequest'RequestedFile'Import msg -> m (B'.Text msg)
get_CodeGeneratorRequest'RequestedFile'Import'name (CodeGeneratorRequest'RequestedFile'Import struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "name" (DC'.Get m (CodeGeneratorRequest'RequestedFile'Import msg) ((B'.Text msg))) where
    fromLabel = DC'.Get get_CodeGeneratorRequest'RequestedFile'Import'name

has_CodeGeneratorRequest'RequestedFile'Import'name :: U'.ReadCtx m msg => CodeGeneratorRequest'RequestedFile'Import msg -> m Bool
has_CodeGeneratorRequest'RequestedFile'Import'name(CodeGeneratorRequest'RequestedFile'Import struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "name" (DC'.Has m (CodeGeneratorRequest'RequestedFile'Import msg)) where
    fromLabel = DC'.Has has_CodeGeneratorRequest'RequestedFile'Import'name

set_CodeGeneratorRequest'RequestedFile'Import'name :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => CodeGeneratorRequest'RequestedFile'Import (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_CodeGeneratorRequest'RequestedFile'Import'name (CodeGeneratorRequest'RequestedFile'Import struct) value = U'.setPtr (C'.toPtr value) 0 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "name" (DC'.Set m (CodeGeneratorRequest'RequestedFile'Import (M'.MutMsg s)) ((B'.Text (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_CodeGeneratorRequest'RequestedFile'Import'name


newtype Node'Parameter msg = Node'Parameter (U'.Struct msg)

instance C'.IsStruct msg (Node'Parameter msg) where
    fromStruct = pure . Node'Parameter
instance C'.IsPtr msg (Node'Parameter msg) where
    fromPtr msg ptr = Node'Parameter <$> C'.fromPtr msg ptr
    toPtr (Node'Parameter struct) = C'.toPtr struct
instance B'.ListElem msg (Node'Parameter msg) where
    newtype List msg (Node'Parameter msg) = List_Node'Parameter (U'.ListOf msg (U'.Struct msg))
    length (List_Node'Parameter l) = U'.length l
    index i (List_Node'Parameter l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Node'Parameter msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Node'Parameter (M'.MutMsg s)) where
    setIndex (Node'Parameter elt) i (List_Node'Parameter l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Node'Parameter msg)) where
    fromPtr msg ptr = List_Node'Parameter <$> C'.fromPtr msg ptr
    toPtr (List_Node'Parameter l) = C'.toPtr l
get_Node'Parameter'name :: U'.ReadCtx m msg => Node'Parameter msg -> m (B'.Text msg)
get_Node'Parameter'name (Node'Parameter struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "name" (DC'.Get m (Node'Parameter msg) ((B'.Text msg))) where
    fromLabel = DC'.Get get_Node'Parameter'name

has_Node'Parameter'name :: U'.ReadCtx m msg => Node'Parameter msg -> m Bool
has_Node'Parameter'name(Node'Parameter struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "name" (DC'.Has m (Node'Parameter msg)) where
    fromLabel = DC'.Has has_Node'Parameter'name

set_Node'Parameter'name :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node'Parameter (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_Node'Parameter'name (Node'Parameter struct) value = U'.setPtr (C'.toPtr value) 0 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "name" (DC'.Set m (Node'Parameter (M'.MutMsg s)) ((B'.Text (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Node'Parameter'name


data Field'ordinal msg
    = Field'ordinal'implicit
    | Field'ordinal'explicit Word16
    | Field'ordinal'unknown' Word16



instance C'.IsStruct msg (Field'ordinal msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 1 16 0
        case tag of
            1 -> Field'ordinal'explicit <$>  C'.getWordField struct 1 32 0
            0 -> pure Field'ordinal'implicit
            _ -> pure $ Field'ordinal'unknown' tag
instance B'.ListElem msg (Field'ordinal msg) where
    newtype List msg (Field'ordinal msg) = List_Field'ordinal (U'.ListOf msg (U'.Struct msg))
    length (List_Field'ordinal l) = U'.length l
    index i (List_Field'ordinal l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Field'ordinal msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (Field'ordinal msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Field'ordinal msg); go = C'.fromStruct} in go)

    toPtr = error "TODO: toPtr for non-newtype structs."

instance C'.IsPtr msg (B'.List msg (Field'ordinal msg)) where
    fromPtr msg ptr = List_Field'ordinal <$> C'.fromPtr msg ptr
    toPtr (List_Field'ordinal l) = C'.toPtr l

newtype CodeGeneratorRequest msg = CodeGeneratorRequest (U'.Struct msg)

instance C'.IsStruct msg (CodeGeneratorRequest msg) where
    fromStruct = pure . CodeGeneratorRequest
instance C'.IsPtr msg (CodeGeneratorRequest msg) where
    fromPtr msg ptr = CodeGeneratorRequest <$> C'.fromPtr msg ptr
    toPtr (CodeGeneratorRequest struct) = C'.toPtr struct
instance B'.ListElem msg (CodeGeneratorRequest msg) where
    newtype List msg (CodeGeneratorRequest msg) = List_CodeGeneratorRequest (U'.ListOf msg (U'.Struct msg))
    length (List_CodeGeneratorRequest l) = U'.length l
    index i (List_CodeGeneratorRequest l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (CodeGeneratorRequest msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (CodeGeneratorRequest (M'.MutMsg s)) where
    setIndex (CodeGeneratorRequest elt) i (List_CodeGeneratorRequest l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (CodeGeneratorRequest msg)) where
    fromPtr msg ptr = List_CodeGeneratorRequest <$> C'.fromPtr msg ptr
    toPtr (List_CodeGeneratorRequest l) = C'.toPtr l
get_CodeGeneratorRequest'nodes :: U'.ReadCtx m msg => CodeGeneratorRequest msg -> m (B'.List msg (Node msg))
get_CodeGeneratorRequest'nodes (CodeGeneratorRequest struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "nodes" (DC'.Get m (CodeGeneratorRequest msg) ((B'.List msg (Node msg)))) where
    fromLabel = DC'.Get get_CodeGeneratorRequest'nodes

has_CodeGeneratorRequest'nodes :: U'.ReadCtx m msg => CodeGeneratorRequest msg -> m Bool
has_CodeGeneratorRequest'nodes(CodeGeneratorRequest struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "nodes" (DC'.Has m (CodeGeneratorRequest msg)) where
    fromLabel = DC'.Has has_CodeGeneratorRequest'nodes

set_CodeGeneratorRequest'nodes :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => CodeGeneratorRequest (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (Node (M'.MutMsg s))) -> m ()
set_CodeGeneratorRequest'nodes (CodeGeneratorRequest struct) value = U'.setPtr (C'.toPtr value) 0 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "nodes" (DC'.Set m (CodeGeneratorRequest (M'.MutMsg s)) ((B'.List (M'.MutMsg s) (Node (M'.MutMsg s))))) where
    fromLabel = DC'.Set set_CodeGeneratorRequest'nodes


get_CodeGeneratorRequest'requestedFiles :: U'.ReadCtx m msg => CodeGeneratorRequest msg -> m (B'.List msg (CodeGeneratorRequest'RequestedFile msg))
get_CodeGeneratorRequest'requestedFiles (CodeGeneratorRequest struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "requestedFiles" (DC'.Get m (CodeGeneratorRequest msg) ((B'.List msg (CodeGeneratorRequest'RequestedFile msg)))) where
    fromLabel = DC'.Get get_CodeGeneratorRequest'requestedFiles

has_CodeGeneratorRequest'requestedFiles :: U'.ReadCtx m msg => CodeGeneratorRequest msg -> m Bool
has_CodeGeneratorRequest'requestedFiles(CodeGeneratorRequest struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
instance U'.ReadCtx m msg => IsLabel "requestedFiles" (DC'.Has m (CodeGeneratorRequest msg)) where
    fromLabel = DC'.Has has_CodeGeneratorRequest'requestedFiles

set_CodeGeneratorRequest'requestedFiles :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => CodeGeneratorRequest (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (CodeGeneratorRequest'RequestedFile (M'.MutMsg s))) -> m ()
set_CodeGeneratorRequest'requestedFiles (CodeGeneratorRequest struct) value = U'.setPtr (C'.toPtr value) 1 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "requestedFiles" (DC'.Set m (CodeGeneratorRequest (M'.MutMsg s)) ((B'.List (M'.MutMsg s) (CodeGeneratorRequest'RequestedFile (M'.MutMsg s))))) where
    fromLabel = DC'.Set set_CodeGeneratorRequest'requestedFiles


get_CodeGeneratorRequest'capnpVersion :: U'.ReadCtx m msg => CodeGeneratorRequest msg -> m (CapnpVersion msg)
get_CodeGeneratorRequest'capnpVersion (CodeGeneratorRequest struct) =
    U'.getPtr 2 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "capnpVersion" (DC'.Get m (CodeGeneratorRequest msg) ((CapnpVersion msg))) where
    fromLabel = DC'.Get get_CodeGeneratorRequest'capnpVersion

has_CodeGeneratorRequest'capnpVersion :: U'.ReadCtx m msg => CodeGeneratorRequest msg -> m Bool
has_CodeGeneratorRequest'capnpVersion(CodeGeneratorRequest struct) = Data.Maybe.isJust <$> U'.getPtr 2 struct
instance U'.ReadCtx m msg => IsLabel "capnpVersion" (DC'.Has m (CodeGeneratorRequest msg)) where
    fromLabel = DC'.Has has_CodeGeneratorRequest'capnpVersion

set_CodeGeneratorRequest'capnpVersion :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => CodeGeneratorRequest (M'.MutMsg s) -> (CapnpVersion (M'.MutMsg s)) -> m ()
set_CodeGeneratorRequest'capnpVersion (CodeGeneratorRequest struct) value = U'.setPtr (C'.toPtr value) 2 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "capnpVersion" (DC'.Set m (CodeGeneratorRequest (M'.MutMsg s)) ((CapnpVersion (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_CodeGeneratorRequest'capnpVersion


data Type'anyPointer msg
    = Type'anyPointer'unconstrained (Type'anyPointer'unconstrained'group' msg)
    | Type'anyPointer'parameter (Type'anyPointer'parameter'group' msg)
    | Type'anyPointer'implicitMethodParameter (Type'anyPointer'implicitMethodParameter'group' msg)
    | Type'anyPointer'unknown' Word16
newtype Type'anyPointer'unconstrained'group' msg = Type'anyPointer'unconstrained'group' (U'.Struct msg)

instance C'.IsStruct msg (Type'anyPointer'unconstrained'group' msg) where
    fromStruct = pure . Type'anyPointer'unconstrained'group'
instance C'.IsPtr msg (Type'anyPointer'unconstrained'group' msg) where
    fromPtr msg ptr = Type'anyPointer'unconstrained'group' <$> C'.fromPtr msg ptr
    toPtr (Type'anyPointer'unconstrained'group' struct) = C'.toPtr struct
instance B'.ListElem msg (Type'anyPointer'unconstrained'group' msg) where
    newtype List msg (Type'anyPointer'unconstrained'group' msg) = List_Type'anyPointer'unconstrained'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Type'anyPointer'unconstrained'group' l) = U'.length l
    index i (List_Type'anyPointer'unconstrained'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Type'anyPointer'unconstrained'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Type'anyPointer'unconstrained'group' (M'.MutMsg s)) where
    setIndex (Type'anyPointer'unconstrained'group' elt) i (List_Type'anyPointer'unconstrained'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Type'anyPointer'unconstrained'group' msg)) where
    fromPtr msg ptr = List_Type'anyPointer'unconstrained'group' <$> C'.fromPtr msg ptr
    toPtr (List_Type'anyPointer'unconstrained'group' l) = C'.toPtr l
get_Type'anyPointer'unconstrained'union' :: U'.ReadCtx m msg => Type'anyPointer'unconstrained'group' msg -> m (Type'anyPointer'unconstrained msg)
get_Type'anyPointer'unconstrained'union' (Type'anyPointer'unconstrained'group' struct) = C'.fromStruct struct
instance U'.ReadCtx m msg => IsLabel "union'" (DC'.Get m (Type'anyPointer'unconstrained'group' msg) ((Type'anyPointer'unconstrained msg))) where
    fromLabel = DC'.Get get_Type'anyPointer'unconstrained'union'

has_Type'anyPointer'unconstrained'union' :: U'.ReadCtx m msg => Type'anyPointer'unconstrained'group' msg -> m Bool
has_Type'anyPointer'unconstrained'union'(Type'anyPointer'unconstrained'group' struct) = pure True
instance U'.ReadCtx m msg => IsLabel "union'" (DC'.Has m (Type'anyPointer'unconstrained'group' msg)) where
    fromLabel = DC'.Has has_Type'anyPointer'unconstrained'union'

set_Type'anyPointer'unconstrained'union' :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Type'anyPointer'unconstrained'group' (M'.MutMsg s) -> (Type'anyPointer'unconstrained (M'.MutMsg s)) -> m ()
set_Type'anyPointer'unconstrained'union' _ = error "TODO: generate more setters."
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "union'" (DC'.Set m (Type'anyPointer'unconstrained'group' (M'.MutMsg s)) ((Type'anyPointer'unconstrained (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Type'anyPointer'unconstrained'union'


newtype Type'anyPointer'parameter'group' msg = Type'anyPointer'parameter'group' (U'.Struct msg)

instance C'.IsStruct msg (Type'anyPointer'parameter'group' msg) where
    fromStruct = pure . Type'anyPointer'parameter'group'
instance C'.IsPtr msg (Type'anyPointer'parameter'group' msg) where
    fromPtr msg ptr = Type'anyPointer'parameter'group' <$> C'.fromPtr msg ptr
    toPtr (Type'anyPointer'parameter'group' struct) = C'.toPtr struct
instance B'.ListElem msg (Type'anyPointer'parameter'group' msg) where
    newtype List msg (Type'anyPointer'parameter'group' msg) = List_Type'anyPointer'parameter'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Type'anyPointer'parameter'group' l) = U'.length l
    index i (List_Type'anyPointer'parameter'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Type'anyPointer'parameter'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Type'anyPointer'parameter'group' (M'.MutMsg s)) where
    setIndex (Type'anyPointer'parameter'group' elt) i (List_Type'anyPointer'parameter'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Type'anyPointer'parameter'group' msg)) where
    fromPtr msg ptr = List_Type'anyPointer'parameter'group' <$> C'.fromPtr msg ptr
    toPtr (List_Type'anyPointer'parameter'group' l) = C'.toPtr l
get_Type'anyPointer'parameter'scopeId :: U'.ReadCtx m msg => Type'anyPointer'parameter'group' msg -> m Word64
get_Type'anyPointer'parameter'scopeId (Type'anyPointer'parameter'group' struct) = C'.getWordField struct 2 0 0
instance U'.ReadCtx m msg => IsLabel "scopeId" (DC'.Get m (Type'anyPointer'parameter'group' msg) (Word64)) where
    fromLabel = DC'.Get get_Type'anyPointer'parameter'scopeId

has_Type'anyPointer'parameter'scopeId :: U'.ReadCtx m msg => Type'anyPointer'parameter'group' msg -> m Bool
has_Type'anyPointer'parameter'scopeId(Type'anyPointer'parameter'group' struct) = pure $ 2 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "scopeId" (DC'.Has m (Type'anyPointer'parameter'group' msg)) where
    fromLabel = DC'.Has has_Type'anyPointer'parameter'scopeId

set_Type'anyPointer'parameter'scopeId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Type'anyPointer'parameter'group' (M'.MutMsg s) -> Word64 -> m ()
set_Type'anyPointer'parameter'scopeId (Type'anyPointer'parameter'group' struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 2 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "scopeId" (DC'.Set m (Type'anyPointer'parameter'group' (M'.MutMsg s)) (Word64)) where
    fromLabel = DC'.Set set_Type'anyPointer'parameter'scopeId


get_Type'anyPointer'parameter'parameterIndex :: U'.ReadCtx m msg => Type'anyPointer'parameter'group' msg -> m Word16
get_Type'anyPointer'parameter'parameterIndex (Type'anyPointer'parameter'group' struct) = C'.getWordField struct 1 16 0
instance U'.ReadCtx m msg => IsLabel "parameterIndex" (DC'.Get m (Type'anyPointer'parameter'group' msg) (Word16)) where
    fromLabel = DC'.Get get_Type'anyPointer'parameter'parameterIndex

has_Type'anyPointer'parameter'parameterIndex :: U'.ReadCtx m msg => Type'anyPointer'parameter'group' msg -> m Bool
has_Type'anyPointer'parameter'parameterIndex(Type'anyPointer'parameter'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "parameterIndex" (DC'.Has m (Type'anyPointer'parameter'group' msg)) where
    fromLabel = DC'.Has has_Type'anyPointer'parameter'parameterIndex

set_Type'anyPointer'parameter'parameterIndex :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Type'anyPointer'parameter'group' (M'.MutMsg s) -> Word16 -> m ()
set_Type'anyPointer'parameter'parameterIndex (Type'anyPointer'parameter'group' struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word16) 1 16 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "parameterIndex" (DC'.Set m (Type'anyPointer'parameter'group' (M'.MutMsg s)) (Word16)) where
    fromLabel = DC'.Set set_Type'anyPointer'parameter'parameterIndex


newtype Type'anyPointer'implicitMethodParameter'group' msg = Type'anyPointer'implicitMethodParameter'group' (U'.Struct msg)

instance C'.IsStruct msg (Type'anyPointer'implicitMethodParameter'group' msg) where
    fromStruct = pure . Type'anyPointer'implicitMethodParameter'group'
instance C'.IsPtr msg (Type'anyPointer'implicitMethodParameter'group' msg) where
    fromPtr msg ptr = Type'anyPointer'implicitMethodParameter'group' <$> C'.fromPtr msg ptr
    toPtr (Type'anyPointer'implicitMethodParameter'group' struct) = C'.toPtr struct
instance B'.ListElem msg (Type'anyPointer'implicitMethodParameter'group' msg) where
    newtype List msg (Type'anyPointer'implicitMethodParameter'group' msg) = List_Type'anyPointer'implicitMethodParameter'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Type'anyPointer'implicitMethodParameter'group' l) = U'.length l
    index i (List_Type'anyPointer'implicitMethodParameter'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Type'anyPointer'implicitMethodParameter'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Type'anyPointer'implicitMethodParameter'group' (M'.MutMsg s)) where
    setIndex (Type'anyPointer'implicitMethodParameter'group' elt) i (List_Type'anyPointer'implicitMethodParameter'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Type'anyPointer'implicitMethodParameter'group' msg)) where
    fromPtr msg ptr = List_Type'anyPointer'implicitMethodParameter'group' <$> C'.fromPtr msg ptr
    toPtr (List_Type'anyPointer'implicitMethodParameter'group' l) = C'.toPtr l
get_Type'anyPointer'implicitMethodParameter'parameterIndex :: U'.ReadCtx m msg => Type'anyPointer'implicitMethodParameter'group' msg -> m Word16
get_Type'anyPointer'implicitMethodParameter'parameterIndex (Type'anyPointer'implicitMethodParameter'group' struct) = C'.getWordField struct 1 16 0
instance U'.ReadCtx m msg => IsLabel "parameterIndex" (DC'.Get m (Type'anyPointer'implicitMethodParameter'group' msg) (Word16)) where
    fromLabel = DC'.Get get_Type'anyPointer'implicitMethodParameter'parameterIndex

has_Type'anyPointer'implicitMethodParameter'parameterIndex :: U'.ReadCtx m msg => Type'anyPointer'implicitMethodParameter'group' msg -> m Bool
has_Type'anyPointer'implicitMethodParameter'parameterIndex(Type'anyPointer'implicitMethodParameter'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "parameterIndex" (DC'.Has m (Type'anyPointer'implicitMethodParameter'group' msg)) where
    fromLabel = DC'.Has has_Type'anyPointer'implicitMethodParameter'parameterIndex

set_Type'anyPointer'implicitMethodParameter'parameterIndex :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Type'anyPointer'implicitMethodParameter'group' (M'.MutMsg s) -> Word16 -> m ()
set_Type'anyPointer'implicitMethodParameter'parameterIndex (Type'anyPointer'implicitMethodParameter'group' struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word16) 1 16 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "parameterIndex" (DC'.Set m (Type'anyPointer'implicitMethodParameter'group' (M'.MutMsg s)) (Word16)) where
    fromLabel = DC'.Set set_Type'anyPointer'implicitMethodParameter'parameterIndex



instance C'.IsStruct msg (Type'anyPointer msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 1 0 0
        case tag of
            2 -> Type'anyPointer'implicitMethodParameter <$> C'.fromStruct struct
            1 -> Type'anyPointer'parameter <$> C'.fromStruct struct
            0 -> Type'anyPointer'unconstrained <$> C'.fromStruct struct
            _ -> pure $ Type'anyPointer'unknown' tag
instance B'.ListElem msg (Type'anyPointer msg) where
    newtype List msg (Type'anyPointer msg) = List_Type'anyPointer (U'.ListOf msg (U'.Struct msg))
    length (List_Type'anyPointer l) = U'.length l
    index i (List_Type'anyPointer l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Type'anyPointer msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (Type'anyPointer msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Type'anyPointer msg); go = C'.fromStruct} in go)

    toPtr = error "TODO: toPtr for non-newtype structs."

instance C'.IsPtr msg (B'.List msg (Type'anyPointer msg)) where
    fromPtr msg ptr = List_Type'anyPointer <$> C'.fromPtr msg ptr
    toPtr (List_Type'anyPointer l) = C'.toPtr l

data Brand'Binding msg
    = Brand'Binding'unbound
    | Brand'Binding'type_ (Type msg)
    | Brand'Binding'unknown' Word16



instance C'.IsStruct msg (Brand'Binding msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 0 0 0
        case tag of
            1 -> Brand'Binding'type_ <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            0 -> pure Brand'Binding'unbound
            _ -> pure $ Brand'Binding'unknown' tag
instance B'.ListElem msg (Brand'Binding msg) where
    newtype List msg (Brand'Binding msg) = List_Brand'Binding (U'.ListOf msg (U'.Struct msg))
    length (List_Brand'Binding l) = U'.length l
    index i (List_Brand'Binding l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Brand'Binding msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (Brand'Binding msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Brand'Binding msg); go = C'.fromStruct} in go)

    toPtr = error "TODO: toPtr for non-newtype structs."

instance C'.IsPtr msg (B'.List msg (Brand'Binding msg)) where
    fromPtr msg ptr = List_Brand'Binding <$> C'.fromPtr msg ptr
    toPtr (List_Brand'Binding l) = C'.toPtr l

data Value msg
    = Value'void
    | Value'bool Bool
    | Value'int8 Int8
    | Value'int16 Int16
    | Value'int32 Int32
    | Value'int64 Int64
    | Value'uint8 Word8
    | Value'uint16 Word16
    | Value'uint32 Word32
    | Value'uint64 Word64
    | Value'float32 Float
    | Value'float64 Double
    | Value'text (B'.Text msg)
    | Value'data_ (B'.Data msg)
    | Value'list (Maybe (U'.Ptr msg))
    | Value'enum Word16
    | Value'struct (Maybe (U'.Ptr msg))
    | Value'interface
    | Value'anyPointer (Maybe (U'.Ptr msg))
    | Value'unknown' Word16




















instance C'.IsStruct msg (Value msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 0 0 0
        case tag of
            18 -> Value'anyPointer <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            17 -> pure Value'interface
            16 -> Value'struct <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            15 -> Value'enum <$>  C'.getWordField struct 0 16 0
            14 -> Value'list <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            13 -> Value'data_ <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            12 -> Value'text <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            11 -> Value'float64 <$>  C'.getWordField struct 1 0 0
            10 -> Value'float32 <$>  C'.getWordField struct 0 32 0
            9 -> Value'uint64 <$>  C'.getWordField struct 1 0 0
            8 -> Value'uint32 <$>  C'.getWordField struct 0 32 0
            7 -> Value'uint16 <$>  C'.getWordField struct 0 16 0
            6 -> Value'uint8 <$>  C'.getWordField struct 0 16 0
            5 -> Value'int64 <$>  C'.getWordField struct 1 0 0
            4 -> Value'int32 <$>  C'.getWordField struct 0 32 0
            3 -> Value'int16 <$>  C'.getWordField struct 0 16 0
            2 -> Value'int8 <$>  C'.getWordField struct 0 16 0
            1 -> Value'bool <$>  C'.getWordField struct 0 16 0
            0 -> pure Value'void
            _ -> pure $ Value'unknown' tag
instance B'.ListElem msg (Value msg) where
    newtype List msg (Value msg) = List_Value (U'.ListOf msg (U'.Struct msg))
    length (List_Value l) = U'.length l
    index i (List_Value l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Value msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (Value msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Value msg); go = C'.fromStruct} in go)

    toPtr = error "TODO: toPtr for non-newtype structs."

instance C'.IsPtr msg (B'.List msg (Value msg)) where
    fromPtr msg ptr = List_Value <$> C'.fromPtr msg ptr
    toPtr (List_Value l) = C'.toPtr l

newtype CodeGeneratorRequest'RequestedFile msg = CodeGeneratorRequest'RequestedFile (U'.Struct msg)

instance C'.IsStruct msg (CodeGeneratorRequest'RequestedFile msg) where
    fromStruct = pure . CodeGeneratorRequest'RequestedFile
instance C'.IsPtr msg (CodeGeneratorRequest'RequestedFile msg) where
    fromPtr msg ptr = CodeGeneratorRequest'RequestedFile <$> C'.fromPtr msg ptr
    toPtr (CodeGeneratorRequest'RequestedFile struct) = C'.toPtr struct
instance B'.ListElem msg (CodeGeneratorRequest'RequestedFile msg) where
    newtype List msg (CodeGeneratorRequest'RequestedFile msg) = List_CodeGeneratorRequest'RequestedFile (U'.ListOf msg (U'.Struct msg))
    length (List_CodeGeneratorRequest'RequestedFile l) = U'.length l
    index i (List_CodeGeneratorRequest'RequestedFile l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (CodeGeneratorRequest'RequestedFile msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (CodeGeneratorRequest'RequestedFile (M'.MutMsg s)) where
    setIndex (CodeGeneratorRequest'RequestedFile elt) i (List_CodeGeneratorRequest'RequestedFile l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (CodeGeneratorRequest'RequestedFile msg)) where
    fromPtr msg ptr = List_CodeGeneratorRequest'RequestedFile <$> C'.fromPtr msg ptr
    toPtr (List_CodeGeneratorRequest'RequestedFile l) = C'.toPtr l
get_CodeGeneratorRequest'RequestedFile'id :: U'.ReadCtx m msg => CodeGeneratorRequest'RequestedFile msg -> m Word64
get_CodeGeneratorRequest'RequestedFile'id (CodeGeneratorRequest'RequestedFile struct) = C'.getWordField struct 0 0 0
instance U'.ReadCtx m msg => IsLabel "id" (DC'.Get m (CodeGeneratorRequest'RequestedFile msg) (Word64)) where
    fromLabel = DC'.Get get_CodeGeneratorRequest'RequestedFile'id

has_CodeGeneratorRequest'RequestedFile'id :: U'.ReadCtx m msg => CodeGeneratorRequest'RequestedFile msg -> m Bool
has_CodeGeneratorRequest'RequestedFile'id(CodeGeneratorRequest'RequestedFile struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "id" (DC'.Has m (CodeGeneratorRequest'RequestedFile msg)) where
    fromLabel = DC'.Has has_CodeGeneratorRequest'RequestedFile'id

set_CodeGeneratorRequest'RequestedFile'id :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => CodeGeneratorRequest'RequestedFile (M'.MutMsg s) -> Word64 -> m ()
set_CodeGeneratorRequest'RequestedFile'id (CodeGeneratorRequest'RequestedFile struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 0 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "id" (DC'.Set m (CodeGeneratorRequest'RequestedFile (M'.MutMsg s)) (Word64)) where
    fromLabel = DC'.Set set_CodeGeneratorRequest'RequestedFile'id


get_CodeGeneratorRequest'RequestedFile'filename :: U'.ReadCtx m msg => CodeGeneratorRequest'RequestedFile msg -> m (B'.Text msg)
get_CodeGeneratorRequest'RequestedFile'filename (CodeGeneratorRequest'RequestedFile struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "filename" (DC'.Get m (CodeGeneratorRequest'RequestedFile msg) ((B'.Text msg))) where
    fromLabel = DC'.Get get_CodeGeneratorRequest'RequestedFile'filename

has_CodeGeneratorRequest'RequestedFile'filename :: U'.ReadCtx m msg => CodeGeneratorRequest'RequestedFile msg -> m Bool
has_CodeGeneratorRequest'RequestedFile'filename(CodeGeneratorRequest'RequestedFile struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "filename" (DC'.Has m (CodeGeneratorRequest'RequestedFile msg)) where
    fromLabel = DC'.Has has_CodeGeneratorRequest'RequestedFile'filename

set_CodeGeneratorRequest'RequestedFile'filename :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => CodeGeneratorRequest'RequestedFile (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_CodeGeneratorRequest'RequestedFile'filename (CodeGeneratorRequest'RequestedFile struct) value = U'.setPtr (C'.toPtr value) 0 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "filename" (DC'.Set m (CodeGeneratorRequest'RequestedFile (M'.MutMsg s)) ((B'.Text (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_CodeGeneratorRequest'RequestedFile'filename


get_CodeGeneratorRequest'RequestedFile'imports :: U'.ReadCtx m msg => CodeGeneratorRequest'RequestedFile msg -> m (B'.List msg (CodeGeneratorRequest'RequestedFile'Import msg))
get_CodeGeneratorRequest'RequestedFile'imports (CodeGeneratorRequest'RequestedFile struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "imports" (DC'.Get m (CodeGeneratorRequest'RequestedFile msg) ((B'.List msg (CodeGeneratorRequest'RequestedFile'Import msg)))) where
    fromLabel = DC'.Get get_CodeGeneratorRequest'RequestedFile'imports

has_CodeGeneratorRequest'RequestedFile'imports :: U'.ReadCtx m msg => CodeGeneratorRequest'RequestedFile msg -> m Bool
has_CodeGeneratorRequest'RequestedFile'imports(CodeGeneratorRequest'RequestedFile struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
instance U'.ReadCtx m msg => IsLabel "imports" (DC'.Has m (CodeGeneratorRequest'RequestedFile msg)) where
    fromLabel = DC'.Has has_CodeGeneratorRequest'RequestedFile'imports

set_CodeGeneratorRequest'RequestedFile'imports :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => CodeGeneratorRequest'RequestedFile (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (CodeGeneratorRequest'RequestedFile'Import (M'.MutMsg s))) -> m ()
set_CodeGeneratorRequest'RequestedFile'imports (CodeGeneratorRequest'RequestedFile struct) value = U'.setPtr (C'.toPtr value) 1 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "imports" (DC'.Set m (CodeGeneratorRequest'RequestedFile (M'.MutMsg s)) ((B'.List (M'.MutMsg s) (CodeGeneratorRequest'RequestedFile'Import (M'.MutMsg s))))) where
    fromLabel = DC'.Set set_CodeGeneratorRequest'RequestedFile'imports


data Type msg
    = Type'void
    | Type'bool
    | Type'int8
    | Type'int16
    | Type'int32
    | Type'int64
    | Type'uint8
    | Type'uint16
    | Type'uint32
    | Type'uint64
    | Type'float32
    | Type'float64
    | Type'text
    | Type'data_
    | Type'list (Type'list'group' msg)
    | Type'enum (Type'enum'group' msg)
    | Type'struct (Type'struct'group' msg)
    | Type'interface (Type'interface'group' msg)
    | Type'anyPointer (Type'anyPointer'group' msg)
    | Type'unknown' Word16














newtype Type'list'group' msg = Type'list'group' (U'.Struct msg)

instance C'.IsStruct msg (Type'list'group' msg) where
    fromStruct = pure . Type'list'group'
instance C'.IsPtr msg (Type'list'group' msg) where
    fromPtr msg ptr = Type'list'group' <$> C'.fromPtr msg ptr
    toPtr (Type'list'group' struct) = C'.toPtr struct
instance B'.ListElem msg (Type'list'group' msg) where
    newtype List msg (Type'list'group' msg) = List_Type'list'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Type'list'group' l) = U'.length l
    index i (List_Type'list'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Type'list'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Type'list'group' (M'.MutMsg s)) where
    setIndex (Type'list'group' elt) i (List_Type'list'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Type'list'group' msg)) where
    fromPtr msg ptr = List_Type'list'group' <$> C'.fromPtr msg ptr
    toPtr (List_Type'list'group' l) = C'.toPtr l
get_Type'list'elementType :: U'.ReadCtx m msg => Type'list'group' msg -> m (Type msg)
get_Type'list'elementType (Type'list'group' struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "elementType" (DC'.Get m (Type'list'group' msg) ((Type msg))) where
    fromLabel = DC'.Get get_Type'list'elementType

has_Type'list'elementType :: U'.ReadCtx m msg => Type'list'group' msg -> m Bool
has_Type'list'elementType(Type'list'group' struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "elementType" (DC'.Has m (Type'list'group' msg)) where
    fromLabel = DC'.Has has_Type'list'elementType

set_Type'list'elementType :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Type'list'group' (M'.MutMsg s) -> (Type (M'.MutMsg s)) -> m ()
set_Type'list'elementType (Type'list'group' struct) value = U'.setPtr (C'.toPtr value) 0 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "elementType" (DC'.Set m (Type'list'group' (M'.MutMsg s)) ((Type (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Type'list'elementType


newtype Type'enum'group' msg = Type'enum'group' (U'.Struct msg)

instance C'.IsStruct msg (Type'enum'group' msg) where
    fromStruct = pure . Type'enum'group'
instance C'.IsPtr msg (Type'enum'group' msg) where
    fromPtr msg ptr = Type'enum'group' <$> C'.fromPtr msg ptr
    toPtr (Type'enum'group' struct) = C'.toPtr struct
instance B'.ListElem msg (Type'enum'group' msg) where
    newtype List msg (Type'enum'group' msg) = List_Type'enum'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Type'enum'group' l) = U'.length l
    index i (List_Type'enum'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Type'enum'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Type'enum'group' (M'.MutMsg s)) where
    setIndex (Type'enum'group' elt) i (List_Type'enum'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Type'enum'group' msg)) where
    fromPtr msg ptr = List_Type'enum'group' <$> C'.fromPtr msg ptr
    toPtr (List_Type'enum'group' l) = C'.toPtr l
get_Type'enum'typeId :: U'.ReadCtx m msg => Type'enum'group' msg -> m Word64
get_Type'enum'typeId (Type'enum'group' struct) = C'.getWordField struct 1 0 0
instance U'.ReadCtx m msg => IsLabel "typeId" (DC'.Get m (Type'enum'group' msg) (Word64)) where
    fromLabel = DC'.Get get_Type'enum'typeId

has_Type'enum'typeId :: U'.ReadCtx m msg => Type'enum'group' msg -> m Bool
has_Type'enum'typeId(Type'enum'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "typeId" (DC'.Has m (Type'enum'group' msg)) where
    fromLabel = DC'.Has has_Type'enum'typeId

set_Type'enum'typeId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Type'enum'group' (M'.MutMsg s) -> Word64 -> m ()
set_Type'enum'typeId (Type'enum'group' struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 1 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "typeId" (DC'.Set m (Type'enum'group' (M'.MutMsg s)) (Word64)) where
    fromLabel = DC'.Set set_Type'enum'typeId


get_Type'enum'brand :: U'.ReadCtx m msg => Type'enum'group' msg -> m (Brand msg)
get_Type'enum'brand (Type'enum'group' struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "brand" (DC'.Get m (Type'enum'group' msg) ((Brand msg))) where
    fromLabel = DC'.Get get_Type'enum'brand

has_Type'enum'brand :: U'.ReadCtx m msg => Type'enum'group' msg -> m Bool
has_Type'enum'brand(Type'enum'group' struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "brand" (DC'.Has m (Type'enum'group' msg)) where
    fromLabel = DC'.Has has_Type'enum'brand

set_Type'enum'brand :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Type'enum'group' (M'.MutMsg s) -> (Brand (M'.MutMsg s)) -> m ()
set_Type'enum'brand (Type'enum'group' struct) value = U'.setPtr (C'.toPtr value) 0 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "brand" (DC'.Set m (Type'enum'group' (M'.MutMsg s)) ((Brand (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Type'enum'brand


newtype Type'struct'group' msg = Type'struct'group' (U'.Struct msg)

instance C'.IsStruct msg (Type'struct'group' msg) where
    fromStruct = pure . Type'struct'group'
instance C'.IsPtr msg (Type'struct'group' msg) where
    fromPtr msg ptr = Type'struct'group' <$> C'.fromPtr msg ptr
    toPtr (Type'struct'group' struct) = C'.toPtr struct
instance B'.ListElem msg (Type'struct'group' msg) where
    newtype List msg (Type'struct'group' msg) = List_Type'struct'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Type'struct'group' l) = U'.length l
    index i (List_Type'struct'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Type'struct'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Type'struct'group' (M'.MutMsg s)) where
    setIndex (Type'struct'group' elt) i (List_Type'struct'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Type'struct'group' msg)) where
    fromPtr msg ptr = List_Type'struct'group' <$> C'.fromPtr msg ptr
    toPtr (List_Type'struct'group' l) = C'.toPtr l
get_Type'struct'typeId :: U'.ReadCtx m msg => Type'struct'group' msg -> m Word64
get_Type'struct'typeId (Type'struct'group' struct) = C'.getWordField struct 1 0 0
instance U'.ReadCtx m msg => IsLabel "typeId" (DC'.Get m (Type'struct'group' msg) (Word64)) where
    fromLabel = DC'.Get get_Type'struct'typeId

has_Type'struct'typeId :: U'.ReadCtx m msg => Type'struct'group' msg -> m Bool
has_Type'struct'typeId(Type'struct'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "typeId" (DC'.Has m (Type'struct'group' msg)) where
    fromLabel = DC'.Has has_Type'struct'typeId

set_Type'struct'typeId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Type'struct'group' (M'.MutMsg s) -> Word64 -> m ()
set_Type'struct'typeId (Type'struct'group' struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 1 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "typeId" (DC'.Set m (Type'struct'group' (M'.MutMsg s)) (Word64)) where
    fromLabel = DC'.Set set_Type'struct'typeId


get_Type'struct'brand :: U'.ReadCtx m msg => Type'struct'group' msg -> m (Brand msg)
get_Type'struct'brand (Type'struct'group' struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "brand" (DC'.Get m (Type'struct'group' msg) ((Brand msg))) where
    fromLabel = DC'.Get get_Type'struct'brand

has_Type'struct'brand :: U'.ReadCtx m msg => Type'struct'group' msg -> m Bool
has_Type'struct'brand(Type'struct'group' struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "brand" (DC'.Has m (Type'struct'group' msg)) where
    fromLabel = DC'.Has has_Type'struct'brand

set_Type'struct'brand :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Type'struct'group' (M'.MutMsg s) -> (Brand (M'.MutMsg s)) -> m ()
set_Type'struct'brand (Type'struct'group' struct) value = U'.setPtr (C'.toPtr value) 0 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "brand" (DC'.Set m (Type'struct'group' (M'.MutMsg s)) ((Brand (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Type'struct'brand


newtype Type'interface'group' msg = Type'interface'group' (U'.Struct msg)

instance C'.IsStruct msg (Type'interface'group' msg) where
    fromStruct = pure . Type'interface'group'
instance C'.IsPtr msg (Type'interface'group' msg) where
    fromPtr msg ptr = Type'interface'group' <$> C'.fromPtr msg ptr
    toPtr (Type'interface'group' struct) = C'.toPtr struct
instance B'.ListElem msg (Type'interface'group' msg) where
    newtype List msg (Type'interface'group' msg) = List_Type'interface'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Type'interface'group' l) = U'.length l
    index i (List_Type'interface'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Type'interface'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Type'interface'group' (M'.MutMsg s)) where
    setIndex (Type'interface'group' elt) i (List_Type'interface'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Type'interface'group' msg)) where
    fromPtr msg ptr = List_Type'interface'group' <$> C'.fromPtr msg ptr
    toPtr (List_Type'interface'group' l) = C'.toPtr l
get_Type'interface'typeId :: U'.ReadCtx m msg => Type'interface'group' msg -> m Word64
get_Type'interface'typeId (Type'interface'group' struct) = C'.getWordField struct 1 0 0
instance U'.ReadCtx m msg => IsLabel "typeId" (DC'.Get m (Type'interface'group' msg) (Word64)) where
    fromLabel = DC'.Get get_Type'interface'typeId

has_Type'interface'typeId :: U'.ReadCtx m msg => Type'interface'group' msg -> m Bool
has_Type'interface'typeId(Type'interface'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "typeId" (DC'.Has m (Type'interface'group' msg)) where
    fromLabel = DC'.Has has_Type'interface'typeId

set_Type'interface'typeId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Type'interface'group' (M'.MutMsg s) -> Word64 -> m ()
set_Type'interface'typeId (Type'interface'group' struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 1 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "typeId" (DC'.Set m (Type'interface'group' (M'.MutMsg s)) (Word64)) where
    fromLabel = DC'.Set set_Type'interface'typeId


get_Type'interface'brand :: U'.ReadCtx m msg => Type'interface'group' msg -> m (Brand msg)
get_Type'interface'brand (Type'interface'group' struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "brand" (DC'.Get m (Type'interface'group' msg) ((Brand msg))) where
    fromLabel = DC'.Get get_Type'interface'brand

has_Type'interface'brand :: U'.ReadCtx m msg => Type'interface'group' msg -> m Bool
has_Type'interface'brand(Type'interface'group' struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "brand" (DC'.Has m (Type'interface'group' msg)) where
    fromLabel = DC'.Has has_Type'interface'brand

set_Type'interface'brand :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Type'interface'group' (M'.MutMsg s) -> (Brand (M'.MutMsg s)) -> m ()
set_Type'interface'brand (Type'interface'group' struct) value = U'.setPtr (C'.toPtr value) 0 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "brand" (DC'.Set m (Type'interface'group' (M'.MutMsg s)) ((Brand (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Type'interface'brand


newtype Type'anyPointer'group' msg = Type'anyPointer'group' (U'.Struct msg)

instance C'.IsStruct msg (Type'anyPointer'group' msg) where
    fromStruct = pure . Type'anyPointer'group'
instance C'.IsPtr msg (Type'anyPointer'group' msg) where
    fromPtr msg ptr = Type'anyPointer'group' <$> C'.fromPtr msg ptr
    toPtr (Type'anyPointer'group' struct) = C'.toPtr struct
instance B'.ListElem msg (Type'anyPointer'group' msg) where
    newtype List msg (Type'anyPointer'group' msg) = List_Type'anyPointer'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Type'anyPointer'group' l) = U'.length l
    index i (List_Type'anyPointer'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Type'anyPointer'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Type'anyPointer'group' (M'.MutMsg s)) where
    setIndex (Type'anyPointer'group' elt) i (List_Type'anyPointer'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Type'anyPointer'group' msg)) where
    fromPtr msg ptr = List_Type'anyPointer'group' <$> C'.fromPtr msg ptr
    toPtr (List_Type'anyPointer'group' l) = C'.toPtr l
get_Type'anyPointer'union' :: U'.ReadCtx m msg => Type'anyPointer'group' msg -> m (Type'anyPointer msg)
get_Type'anyPointer'union' (Type'anyPointer'group' struct) = C'.fromStruct struct
instance U'.ReadCtx m msg => IsLabel "union'" (DC'.Get m (Type'anyPointer'group' msg) ((Type'anyPointer msg))) where
    fromLabel = DC'.Get get_Type'anyPointer'union'

has_Type'anyPointer'union' :: U'.ReadCtx m msg => Type'anyPointer'group' msg -> m Bool
has_Type'anyPointer'union'(Type'anyPointer'group' struct) = pure True
instance U'.ReadCtx m msg => IsLabel "union'" (DC'.Has m (Type'anyPointer'group' msg)) where
    fromLabel = DC'.Has has_Type'anyPointer'union'

set_Type'anyPointer'union' :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Type'anyPointer'group' (M'.MutMsg s) -> (Type'anyPointer (M'.MutMsg s)) -> m ()
set_Type'anyPointer'union' _ = error "TODO: generate more setters."
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "union'" (DC'.Set m (Type'anyPointer'group' (M'.MutMsg s)) ((Type'anyPointer (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Type'anyPointer'union'



instance C'.IsStruct msg (Type msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 0 0 0
        case tag of
            18 -> Type'anyPointer <$> C'.fromStruct struct
            17 -> Type'interface <$> C'.fromStruct struct
            16 -> Type'struct <$> C'.fromStruct struct
            15 -> Type'enum <$> C'.fromStruct struct
            14 -> Type'list <$> C'.fromStruct struct
            13 -> pure Type'data_
            12 -> pure Type'text
            11 -> pure Type'float64
            10 -> pure Type'float32
            9 -> pure Type'uint64
            8 -> pure Type'uint32
            7 -> pure Type'uint16
            6 -> pure Type'uint8
            5 -> pure Type'int64
            4 -> pure Type'int32
            3 -> pure Type'int16
            2 -> pure Type'int8
            1 -> pure Type'bool
            0 -> pure Type'void
            _ -> pure $ Type'unknown' tag
instance B'.ListElem msg (Type msg) where
    newtype List msg (Type msg) = List_Type (U'.ListOf msg (U'.Struct msg))
    length (List_Type l) = U'.length l
    index i (List_Type l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Type msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (Type msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Type msg); go = C'.fromStruct} in go)

    toPtr = error "TODO: toPtr for non-newtype structs."

instance C'.IsPtr msg (B'.List msg (Type msg)) where
    fromPtr msg ptr = List_Type <$> C'.fromPtr msg ptr
    toPtr (List_Type l) = C'.toPtr l

data ElementSize
    = ElementSize'empty
    | ElementSize'bit
    | ElementSize'byte
    | ElementSize'twoBytes
    | ElementSize'fourBytes
    | ElementSize'eightBytes
    | ElementSize'pointer
    | ElementSize'inlineComposite
    | ElementSize'unknown' Word16
instance Enum ElementSize where
    toEnum = C'.fromWord . fromIntegral
    fromEnum = fromIntegral . C'.toWord


instance C'.IsWord ElementSize where
    fromWord n = go (fromIntegral n :: Word16)
      where
        go 7 = ElementSize'inlineComposite
        go 6 = ElementSize'pointer
        go 5 = ElementSize'eightBytes
        go 4 = ElementSize'fourBytes
        go 3 = ElementSize'twoBytes
        go 2 = ElementSize'byte
        go 1 = ElementSize'bit
        go 0 = ElementSize'empty
        go tag = ElementSize'unknown' (fromIntegral tag)
    toWord ElementSize'inlineComposite = 7
    toWord ElementSize'pointer = 6
    toWord ElementSize'eightBytes = 5
    toWord ElementSize'fourBytes = 4
    toWord ElementSize'twoBytes = 3
    toWord ElementSize'byte = 2
    toWord ElementSize'bit = 1
    toWord ElementSize'empty = 0
    toWord (ElementSize'unknown' tag) = fromIntegral tag
instance B'.ListElem msg ElementSize where
    newtype List msg ElementSize = List_ElementSize (U'.ListOf msg Word16)
    length (List_ElementSize l) = U'.length l
    index i (List_ElementSize l) = (C'.fromWord . fromIntegral) <$> U'.index i l
instance B'.MutListElem s ElementSize where
    setIndex elt i (List_ElementSize l) = error "TODO: generate code for setIndex"
instance C'.IsPtr msg (B'.List msg ElementSize) where
    fromPtr msg ptr = List_ElementSize <$> C'.fromPtr msg ptr
    toPtr (List_ElementSize l) = C'.toPtr l

newtype CapnpVersion msg = CapnpVersion (U'.Struct msg)

instance C'.IsStruct msg (CapnpVersion msg) where
    fromStruct = pure . CapnpVersion
instance C'.IsPtr msg (CapnpVersion msg) where
    fromPtr msg ptr = CapnpVersion <$> C'.fromPtr msg ptr
    toPtr (CapnpVersion struct) = C'.toPtr struct
instance B'.ListElem msg (CapnpVersion msg) where
    newtype List msg (CapnpVersion msg) = List_CapnpVersion (U'.ListOf msg (U'.Struct msg))
    length (List_CapnpVersion l) = U'.length l
    index i (List_CapnpVersion l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (CapnpVersion msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (CapnpVersion (M'.MutMsg s)) where
    setIndex (CapnpVersion elt) i (List_CapnpVersion l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (CapnpVersion msg)) where
    fromPtr msg ptr = List_CapnpVersion <$> C'.fromPtr msg ptr
    toPtr (List_CapnpVersion l) = C'.toPtr l
get_CapnpVersion'major :: U'.ReadCtx m msg => CapnpVersion msg -> m Word16
get_CapnpVersion'major (CapnpVersion struct) = C'.getWordField struct 0 0 0
instance U'.ReadCtx m msg => IsLabel "major" (DC'.Get m (CapnpVersion msg) (Word16)) where
    fromLabel = DC'.Get get_CapnpVersion'major

has_CapnpVersion'major :: U'.ReadCtx m msg => CapnpVersion msg -> m Bool
has_CapnpVersion'major(CapnpVersion struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "major" (DC'.Has m (CapnpVersion msg)) where
    fromLabel = DC'.Has has_CapnpVersion'major

set_CapnpVersion'major :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => CapnpVersion (M'.MutMsg s) -> Word16 -> m ()
set_CapnpVersion'major (CapnpVersion struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word16) 0 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "major" (DC'.Set m (CapnpVersion (M'.MutMsg s)) (Word16)) where
    fromLabel = DC'.Set set_CapnpVersion'major


get_CapnpVersion'minor :: U'.ReadCtx m msg => CapnpVersion msg -> m Word8
get_CapnpVersion'minor (CapnpVersion struct) = C'.getWordField struct 0 16 0
instance U'.ReadCtx m msg => IsLabel "minor" (DC'.Get m (CapnpVersion msg) (Word8)) where
    fromLabel = DC'.Get get_CapnpVersion'minor

has_CapnpVersion'minor :: U'.ReadCtx m msg => CapnpVersion msg -> m Bool
has_CapnpVersion'minor(CapnpVersion struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "minor" (DC'.Has m (CapnpVersion msg)) where
    fromLabel = DC'.Has has_CapnpVersion'minor

set_CapnpVersion'minor :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => CapnpVersion (M'.MutMsg s) -> Word8 -> m ()
set_CapnpVersion'minor (CapnpVersion struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word8) 0 16 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "minor" (DC'.Set m (CapnpVersion (M'.MutMsg s)) (Word8)) where
    fromLabel = DC'.Set set_CapnpVersion'minor


get_CapnpVersion'micro :: U'.ReadCtx m msg => CapnpVersion msg -> m Word8
get_CapnpVersion'micro (CapnpVersion struct) = C'.getWordField struct 0 24 0
instance U'.ReadCtx m msg => IsLabel "micro" (DC'.Get m (CapnpVersion msg) (Word8)) where
    fromLabel = DC'.Get get_CapnpVersion'micro

has_CapnpVersion'micro :: U'.ReadCtx m msg => CapnpVersion msg -> m Bool
has_CapnpVersion'micro(CapnpVersion struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "micro" (DC'.Has m (CapnpVersion msg)) where
    fromLabel = DC'.Has has_CapnpVersion'micro

set_CapnpVersion'micro :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => CapnpVersion (M'.MutMsg s) -> Word8 -> m ()
set_CapnpVersion'micro (CapnpVersion struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word8) 0 24 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "micro" (DC'.Set m (CapnpVersion (M'.MutMsg s)) (Word8)) where
    fromLabel = DC'.Set set_CapnpVersion'micro


newtype Node'NestedNode msg = Node'NestedNode (U'.Struct msg)

instance C'.IsStruct msg (Node'NestedNode msg) where
    fromStruct = pure . Node'NestedNode
instance C'.IsPtr msg (Node'NestedNode msg) where
    fromPtr msg ptr = Node'NestedNode <$> C'.fromPtr msg ptr
    toPtr (Node'NestedNode struct) = C'.toPtr struct
instance B'.ListElem msg (Node'NestedNode msg) where
    newtype List msg (Node'NestedNode msg) = List_Node'NestedNode (U'.ListOf msg (U'.Struct msg))
    length (List_Node'NestedNode l) = U'.length l
    index i (List_Node'NestedNode l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Node'NestedNode msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Node'NestedNode (M'.MutMsg s)) where
    setIndex (Node'NestedNode elt) i (List_Node'NestedNode l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Node'NestedNode msg)) where
    fromPtr msg ptr = List_Node'NestedNode <$> C'.fromPtr msg ptr
    toPtr (List_Node'NestedNode l) = C'.toPtr l
get_Node'NestedNode'name :: U'.ReadCtx m msg => Node'NestedNode msg -> m (B'.Text msg)
get_Node'NestedNode'name (Node'NestedNode struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "name" (DC'.Get m (Node'NestedNode msg) ((B'.Text msg))) where
    fromLabel = DC'.Get get_Node'NestedNode'name

has_Node'NestedNode'name :: U'.ReadCtx m msg => Node'NestedNode msg -> m Bool
has_Node'NestedNode'name(Node'NestedNode struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "name" (DC'.Has m (Node'NestedNode msg)) where
    fromLabel = DC'.Has has_Node'NestedNode'name

set_Node'NestedNode'name :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node'NestedNode (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_Node'NestedNode'name (Node'NestedNode struct) value = U'.setPtr (C'.toPtr value) 0 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "name" (DC'.Set m (Node'NestedNode (M'.MutMsg s)) ((B'.Text (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Node'NestedNode'name


get_Node'NestedNode'id :: U'.ReadCtx m msg => Node'NestedNode msg -> m Word64
get_Node'NestedNode'id (Node'NestedNode struct) = C'.getWordField struct 0 0 0
instance U'.ReadCtx m msg => IsLabel "id" (DC'.Get m (Node'NestedNode msg) (Word64)) where
    fromLabel = DC'.Get get_Node'NestedNode'id

has_Node'NestedNode'id :: U'.ReadCtx m msg => Node'NestedNode msg -> m Bool
has_Node'NestedNode'id(Node'NestedNode struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "id" (DC'.Has m (Node'NestedNode msg)) where
    fromLabel = DC'.Has has_Node'NestedNode'id

set_Node'NestedNode'id :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node'NestedNode (M'.MutMsg s) -> Word64 -> m ()
set_Node'NestedNode'id (Node'NestedNode struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 0 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "id" (DC'.Set m (Node'NestedNode (M'.MutMsg s)) (Word64)) where
    fromLabel = DC'.Set set_Node'NestedNode'id


newtype Node msg = Node (U'.Struct msg)

instance C'.IsStruct msg (Node msg) where
    fromStruct = pure . Node
instance C'.IsPtr msg (Node msg) where
    fromPtr msg ptr = Node <$> C'.fromPtr msg ptr
    toPtr (Node struct) = C'.toPtr struct
instance B'.ListElem msg (Node msg) where
    newtype List msg (Node msg) = List_Node (U'.ListOf msg (U'.Struct msg))
    length (List_Node l) = U'.length l
    index i (List_Node l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Node msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Node (M'.MutMsg s)) where
    setIndex (Node elt) i (List_Node l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Node msg)) where
    fromPtr msg ptr = List_Node <$> C'.fromPtr msg ptr
    toPtr (List_Node l) = C'.toPtr l
get_Node'id :: U'.ReadCtx m msg => Node msg -> m Word64
get_Node'id (Node struct) = C'.getWordField struct 0 0 0
instance U'.ReadCtx m msg => IsLabel "id" (DC'.Get m (Node msg) (Word64)) where
    fromLabel = DC'.Get get_Node'id

has_Node'id :: U'.ReadCtx m msg => Node msg -> m Bool
has_Node'id(Node struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "id" (DC'.Has m (Node msg)) where
    fromLabel = DC'.Has has_Node'id

set_Node'id :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node (M'.MutMsg s) -> Word64 -> m ()
set_Node'id (Node struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 0 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "id" (DC'.Set m (Node (M'.MutMsg s)) (Word64)) where
    fromLabel = DC'.Set set_Node'id


get_Node'displayName :: U'.ReadCtx m msg => Node msg -> m (B'.Text msg)
get_Node'displayName (Node struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "displayName" (DC'.Get m (Node msg) ((B'.Text msg))) where
    fromLabel = DC'.Get get_Node'displayName

has_Node'displayName :: U'.ReadCtx m msg => Node msg -> m Bool
has_Node'displayName(Node struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "displayName" (DC'.Has m (Node msg)) where
    fromLabel = DC'.Has has_Node'displayName

set_Node'displayName :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_Node'displayName (Node struct) value = U'.setPtr (C'.toPtr value) 0 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "displayName" (DC'.Set m (Node (M'.MutMsg s)) ((B'.Text (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Node'displayName


get_Node'displayNamePrefixLength :: U'.ReadCtx m msg => Node msg -> m Word32
get_Node'displayNamePrefixLength (Node struct) = C'.getWordField struct 1 0 0
instance U'.ReadCtx m msg => IsLabel "displayNamePrefixLength" (DC'.Get m (Node msg) (Word32)) where
    fromLabel = DC'.Get get_Node'displayNamePrefixLength

has_Node'displayNamePrefixLength :: U'.ReadCtx m msg => Node msg -> m Bool
has_Node'displayNamePrefixLength(Node struct) = pure $ 1 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "displayNamePrefixLength" (DC'.Has m (Node msg)) where
    fromLabel = DC'.Has has_Node'displayNamePrefixLength

set_Node'displayNamePrefixLength :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node (M'.MutMsg s) -> Word32 -> m ()
set_Node'displayNamePrefixLength (Node struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 1 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "displayNamePrefixLength" (DC'.Set m (Node (M'.MutMsg s)) (Word32)) where
    fromLabel = DC'.Set set_Node'displayNamePrefixLength


get_Node'scopeId :: U'.ReadCtx m msg => Node msg -> m Word64
get_Node'scopeId (Node struct) = C'.getWordField struct 2 0 0
instance U'.ReadCtx m msg => IsLabel "scopeId" (DC'.Get m (Node msg) (Word64)) where
    fromLabel = DC'.Get get_Node'scopeId

has_Node'scopeId :: U'.ReadCtx m msg => Node msg -> m Bool
has_Node'scopeId(Node struct) = pure $ 2 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "scopeId" (DC'.Has m (Node msg)) where
    fromLabel = DC'.Has has_Node'scopeId

set_Node'scopeId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node (M'.MutMsg s) -> Word64 -> m ()
set_Node'scopeId (Node struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 2 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "scopeId" (DC'.Set m (Node (M'.MutMsg s)) (Word64)) where
    fromLabel = DC'.Set set_Node'scopeId


get_Node'nestedNodes :: U'.ReadCtx m msg => Node msg -> m (B'.List msg (Node'NestedNode msg))
get_Node'nestedNodes (Node struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "nestedNodes" (DC'.Get m (Node msg) ((B'.List msg (Node'NestedNode msg)))) where
    fromLabel = DC'.Get get_Node'nestedNodes

has_Node'nestedNodes :: U'.ReadCtx m msg => Node msg -> m Bool
has_Node'nestedNodes(Node struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
instance U'.ReadCtx m msg => IsLabel "nestedNodes" (DC'.Has m (Node msg)) where
    fromLabel = DC'.Has has_Node'nestedNodes

set_Node'nestedNodes :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (Node'NestedNode (M'.MutMsg s))) -> m ()
set_Node'nestedNodes (Node struct) value = U'.setPtr (C'.toPtr value) 1 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "nestedNodes" (DC'.Set m (Node (M'.MutMsg s)) ((B'.List (M'.MutMsg s) (Node'NestedNode (M'.MutMsg s))))) where
    fromLabel = DC'.Set set_Node'nestedNodes


get_Node'annotations :: U'.ReadCtx m msg => Node msg -> m (B'.List msg (Annotation msg))
get_Node'annotations (Node struct) =
    U'.getPtr 2 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "annotations" (DC'.Get m (Node msg) ((B'.List msg (Annotation msg)))) where
    fromLabel = DC'.Get get_Node'annotations

has_Node'annotations :: U'.ReadCtx m msg => Node msg -> m Bool
has_Node'annotations(Node struct) = Data.Maybe.isJust <$> U'.getPtr 2 struct
instance U'.ReadCtx m msg => IsLabel "annotations" (DC'.Has m (Node msg)) where
    fromLabel = DC'.Has has_Node'annotations

set_Node'annotations :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (Annotation (M'.MutMsg s))) -> m ()
set_Node'annotations (Node struct) value = U'.setPtr (C'.toPtr value) 2 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "annotations" (DC'.Set m (Node (M'.MutMsg s)) ((B'.List (M'.MutMsg s) (Annotation (M'.MutMsg s))))) where
    fromLabel = DC'.Set set_Node'annotations


get_Node'parameters :: U'.ReadCtx m msg => Node msg -> m (B'.List msg (Node'Parameter msg))
get_Node'parameters (Node struct) =
    U'.getPtr 5 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "parameters" (DC'.Get m (Node msg) ((B'.List msg (Node'Parameter msg)))) where
    fromLabel = DC'.Get get_Node'parameters

has_Node'parameters :: U'.ReadCtx m msg => Node msg -> m Bool
has_Node'parameters(Node struct) = Data.Maybe.isJust <$> U'.getPtr 5 struct
instance U'.ReadCtx m msg => IsLabel "parameters" (DC'.Has m (Node msg)) where
    fromLabel = DC'.Has has_Node'parameters

set_Node'parameters :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (Node'Parameter (M'.MutMsg s))) -> m ()
set_Node'parameters (Node struct) value = U'.setPtr (C'.toPtr value) 5 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "parameters" (DC'.Set m (Node (M'.MutMsg s)) ((B'.List (M'.MutMsg s) (Node'Parameter (M'.MutMsg s))))) where
    fromLabel = DC'.Set set_Node'parameters


get_Node'isGeneric :: U'.ReadCtx m msg => Node msg -> m Bool
get_Node'isGeneric (Node struct) = C'.getWordField struct 4 32 0
instance U'.ReadCtx m msg => IsLabel "isGeneric" (DC'.Get m (Node msg) (Bool)) where
    fromLabel = DC'.Get get_Node'isGeneric

has_Node'isGeneric :: U'.ReadCtx m msg => Node msg -> m Bool
has_Node'isGeneric(Node struct) = pure $ 4 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "isGeneric" (DC'.Has m (Node msg)) where
    fromLabel = DC'.Has has_Node'isGeneric

set_Node'isGeneric :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node (M'.MutMsg s) -> Bool -> m ()
set_Node'isGeneric (Node struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word1) 4 32 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "isGeneric" (DC'.Set m (Node (M'.MutMsg s)) (Bool)) where
    fromLabel = DC'.Set set_Node'isGeneric


get_Node'union' :: U'.ReadCtx m msg => Node msg -> m (Node' msg)
get_Node'union' (Node struct) = C'.fromStruct struct
instance U'.ReadCtx m msg => IsLabel "union'" (DC'.Get m (Node msg) ((Node' msg))) where
    fromLabel = DC'.Get get_Node'union'

has_Node'union' :: U'.ReadCtx m msg => Node msg -> m Bool
has_Node'union'(Node struct) = pure True
instance U'.ReadCtx m msg => IsLabel "union'" (DC'.Has m (Node msg)) where
    fromLabel = DC'.Has has_Node'union'

set_Node'union' :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node (M'.MutMsg s) -> (Node' (M'.MutMsg s)) -> m ()
set_Node'union' _ = error "TODO: generate more setters."
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "union'" (DC'.Set m (Node (M'.MutMsg s)) ((Node' (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Node'union'


data Node' msg
    = Node'file
    | Node'struct (Node'struct'group' msg)
    | Node'enum (Node'enum'group' msg)
    | Node'interface (Node'interface'group' msg)
    | Node'const (Node'const'group' msg)
    | Node'annotation (Node'annotation'group' msg)
    | Node'unknown' Word16

newtype Node'struct'group' msg = Node'struct'group' (U'.Struct msg)

instance C'.IsStruct msg (Node'struct'group' msg) where
    fromStruct = pure . Node'struct'group'
instance C'.IsPtr msg (Node'struct'group' msg) where
    fromPtr msg ptr = Node'struct'group' <$> C'.fromPtr msg ptr
    toPtr (Node'struct'group' struct) = C'.toPtr struct
instance B'.ListElem msg (Node'struct'group' msg) where
    newtype List msg (Node'struct'group' msg) = List_Node'struct'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Node'struct'group' l) = U'.length l
    index i (List_Node'struct'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Node'struct'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Node'struct'group' (M'.MutMsg s)) where
    setIndex (Node'struct'group' elt) i (List_Node'struct'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Node'struct'group' msg)) where
    fromPtr msg ptr = List_Node'struct'group' <$> C'.fromPtr msg ptr
    toPtr (List_Node'struct'group' l) = C'.toPtr l
get_Node'struct'dataWordCount :: U'.ReadCtx m msg => Node'struct'group' msg -> m Word16
get_Node'struct'dataWordCount (Node'struct'group' struct) = C'.getWordField struct 1 48 0
instance U'.ReadCtx m msg => IsLabel "dataWordCount" (DC'.Get m (Node'struct'group' msg) (Word16)) where
    fromLabel = DC'.Get get_Node'struct'dataWordCount

has_Node'struct'dataWordCount :: U'.ReadCtx m msg => Node'struct'group' msg -> m Bool
has_Node'struct'dataWordCount(Node'struct'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "dataWordCount" (DC'.Has m (Node'struct'group' msg)) where
    fromLabel = DC'.Has has_Node'struct'dataWordCount

set_Node'struct'dataWordCount :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node'struct'group' (M'.MutMsg s) -> Word16 -> m ()
set_Node'struct'dataWordCount (Node'struct'group' struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word16) 1 48 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "dataWordCount" (DC'.Set m (Node'struct'group' (M'.MutMsg s)) (Word16)) where
    fromLabel = DC'.Set set_Node'struct'dataWordCount


get_Node'struct'pointerCount :: U'.ReadCtx m msg => Node'struct'group' msg -> m Word16
get_Node'struct'pointerCount (Node'struct'group' struct) = C'.getWordField struct 3 0 0
instance U'.ReadCtx m msg => IsLabel "pointerCount" (DC'.Get m (Node'struct'group' msg) (Word16)) where
    fromLabel = DC'.Get get_Node'struct'pointerCount

has_Node'struct'pointerCount :: U'.ReadCtx m msg => Node'struct'group' msg -> m Bool
has_Node'struct'pointerCount(Node'struct'group' struct) = pure $ 3 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "pointerCount" (DC'.Has m (Node'struct'group' msg)) where
    fromLabel = DC'.Has has_Node'struct'pointerCount

set_Node'struct'pointerCount :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node'struct'group' (M'.MutMsg s) -> Word16 -> m ()
set_Node'struct'pointerCount (Node'struct'group' struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word16) 3 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "pointerCount" (DC'.Set m (Node'struct'group' (M'.MutMsg s)) (Word16)) where
    fromLabel = DC'.Set set_Node'struct'pointerCount


get_Node'struct'preferredListEncoding :: U'.ReadCtx m msg => Node'struct'group' msg -> m ElementSize
get_Node'struct'preferredListEncoding (Node'struct'group' struct) = C'.getWordField struct 3 16 0
instance U'.ReadCtx m msg => IsLabel "preferredListEncoding" (DC'.Get m (Node'struct'group' msg) (ElementSize)) where
    fromLabel = DC'.Get get_Node'struct'preferredListEncoding

has_Node'struct'preferredListEncoding :: U'.ReadCtx m msg => Node'struct'group' msg -> m Bool
has_Node'struct'preferredListEncoding(Node'struct'group' struct) = pure $ 3 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "preferredListEncoding" (DC'.Has m (Node'struct'group' msg)) where
    fromLabel = DC'.Has has_Node'struct'preferredListEncoding

set_Node'struct'preferredListEncoding :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node'struct'group' (M'.MutMsg s) -> ElementSize -> m ()
set_Node'struct'preferredListEncoding (Node'struct'group' struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word16) 3 16 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "preferredListEncoding" (DC'.Set m (Node'struct'group' (M'.MutMsg s)) (ElementSize)) where
    fromLabel = DC'.Set set_Node'struct'preferredListEncoding


get_Node'struct'isGroup :: U'.ReadCtx m msg => Node'struct'group' msg -> m Bool
get_Node'struct'isGroup (Node'struct'group' struct) = C'.getWordField struct 3 32 0
instance U'.ReadCtx m msg => IsLabel "isGroup" (DC'.Get m (Node'struct'group' msg) (Bool)) where
    fromLabel = DC'.Get get_Node'struct'isGroup

has_Node'struct'isGroup :: U'.ReadCtx m msg => Node'struct'group' msg -> m Bool
has_Node'struct'isGroup(Node'struct'group' struct) = pure $ 3 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "isGroup" (DC'.Has m (Node'struct'group' msg)) where
    fromLabel = DC'.Has has_Node'struct'isGroup

set_Node'struct'isGroup :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node'struct'group' (M'.MutMsg s) -> Bool -> m ()
set_Node'struct'isGroup (Node'struct'group' struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word1) 3 32 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "isGroup" (DC'.Set m (Node'struct'group' (M'.MutMsg s)) (Bool)) where
    fromLabel = DC'.Set set_Node'struct'isGroup


get_Node'struct'discriminantCount :: U'.ReadCtx m msg => Node'struct'group' msg -> m Word16
get_Node'struct'discriminantCount (Node'struct'group' struct) = C'.getWordField struct 3 48 0
instance U'.ReadCtx m msg => IsLabel "discriminantCount" (DC'.Get m (Node'struct'group' msg) (Word16)) where
    fromLabel = DC'.Get get_Node'struct'discriminantCount

has_Node'struct'discriminantCount :: U'.ReadCtx m msg => Node'struct'group' msg -> m Bool
has_Node'struct'discriminantCount(Node'struct'group' struct) = pure $ 3 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "discriminantCount" (DC'.Has m (Node'struct'group' msg)) where
    fromLabel = DC'.Has has_Node'struct'discriminantCount

set_Node'struct'discriminantCount :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node'struct'group' (M'.MutMsg s) -> Word16 -> m ()
set_Node'struct'discriminantCount (Node'struct'group' struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word16) 3 48 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "discriminantCount" (DC'.Set m (Node'struct'group' (M'.MutMsg s)) (Word16)) where
    fromLabel = DC'.Set set_Node'struct'discriminantCount


get_Node'struct'discriminantOffset :: U'.ReadCtx m msg => Node'struct'group' msg -> m Word32
get_Node'struct'discriminantOffset (Node'struct'group' struct) = C'.getWordField struct 4 0 0
instance U'.ReadCtx m msg => IsLabel "discriminantOffset" (DC'.Get m (Node'struct'group' msg) (Word32)) where
    fromLabel = DC'.Get get_Node'struct'discriminantOffset

has_Node'struct'discriminantOffset :: U'.ReadCtx m msg => Node'struct'group' msg -> m Bool
has_Node'struct'discriminantOffset(Node'struct'group' struct) = pure $ 4 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "discriminantOffset" (DC'.Has m (Node'struct'group' msg)) where
    fromLabel = DC'.Has has_Node'struct'discriminantOffset

set_Node'struct'discriminantOffset :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node'struct'group' (M'.MutMsg s) -> Word32 -> m ()
set_Node'struct'discriminantOffset (Node'struct'group' struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 4 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "discriminantOffset" (DC'.Set m (Node'struct'group' (M'.MutMsg s)) (Word32)) where
    fromLabel = DC'.Set set_Node'struct'discriminantOffset


get_Node'struct'fields :: U'.ReadCtx m msg => Node'struct'group' msg -> m (B'.List msg (Field msg))
get_Node'struct'fields (Node'struct'group' struct) =
    U'.getPtr 3 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "fields" (DC'.Get m (Node'struct'group' msg) ((B'.List msg (Field msg)))) where
    fromLabel = DC'.Get get_Node'struct'fields

has_Node'struct'fields :: U'.ReadCtx m msg => Node'struct'group' msg -> m Bool
has_Node'struct'fields(Node'struct'group' struct) = Data.Maybe.isJust <$> U'.getPtr 3 struct
instance U'.ReadCtx m msg => IsLabel "fields" (DC'.Has m (Node'struct'group' msg)) where
    fromLabel = DC'.Has has_Node'struct'fields

set_Node'struct'fields :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node'struct'group' (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (Field (M'.MutMsg s))) -> m ()
set_Node'struct'fields (Node'struct'group' struct) value = U'.setPtr (C'.toPtr value) 3 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "fields" (DC'.Set m (Node'struct'group' (M'.MutMsg s)) ((B'.List (M'.MutMsg s) (Field (M'.MutMsg s))))) where
    fromLabel = DC'.Set set_Node'struct'fields


newtype Node'enum'group' msg = Node'enum'group' (U'.Struct msg)

instance C'.IsStruct msg (Node'enum'group' msg) where
    fromStruct = pure . Node'enum'group'
instance C'.IsPtr msg (Node'enum'group' msg) where
    fromPtr msg ptr = Node'enum'group' <$> C'.fromPtr msg ptr
    toPtr (Node'enum'group' struct) = C'.toPtr struct
instance B'.ListElem msg (Node'enum'group' msg) where
    newtype List msg (Node'enum'group' msg) = List_Node'enum'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Node'enum'group' l) = U'.length l
    index i (List_Node'enum'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Node'enum'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Node'enum'group' (M'.MutMsg s)) where
    setIndex (Node'enum'group' elt) i (List_Node'enum'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Node'enum'group' msg)) where
    fromPtr msg ptr = List_Node'enum'group' <$> C'.fromPtr msg ptr
    toPtr (List_Node'enum'group' l) = C'.toPtr l
get_Node'enum'enumerants :: U'.ReadCtx m msg => Node'enum'group' msg -> m (B'.List msg (Enumerant msg))
get_Node'enum'enumerants (Node'enum'group' struct) =
    U'.getPtr 3 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "enumerants" (DC'.Get m (Node'enum'group' msg) ((B'.List msg (Enumerant msg)))) where
    fromLabel = DC'.Get get_Node'enum'enumerants

has_Node'enum'enumerants :: U'.ReadCtx m msg => Node'enum'group' msg -> m Bool
has_Node'enum'enumerants(Node'enum'group' struct) = Data.Maybe.isJust <$> U'.getPtr 3 struct
instance U'.ReadCtx m msg => IsLabel "enumerants" (DC'.Has m (Node'enum'group' msg)) where
    fromLabel = DC'.Has has_Node'enum'enumerants

set_Node'enum'enumerants :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node'enum'group' (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (Enumerant (M'.MutMsg s))) -> m ()
set_Node'enum'enumerants (Node'enum'group' struct) value = U'.setPtr (C'.toPtr value) 3 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "enumerants" (DC'.Set m (Node'enum'group' (M'.MutMsg s)) ((B'.List (M'.MutMsg s) (Enumerant (M'.MutMsg s))))) where
    fromLabel = DC'.Set set_Node'enum'enumerants


newtype Node'interface'group' msg = Node'interface'group' (U'.Struct msg)

instance C'.IsStruct msg (Node'interface'group' msg) where
    fromStruct = pure . Node'interface'group'
instance C'.IsPtr msg (Node'interface'group' msg) where
    fromPtr msg ptr = Node'interface'group' <$> C'.fromPtr msg ptr
    toPtr (Node'interface'group' struct) = C'.toPtr struct
instance B'.ListElem msg (Node'interface'group' msg) where
    newtype List msg (Node'interface'group' msg) = List_Node'interface'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Node'interface'group' l) = U'.length l
    index i (List_Node'interface'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Node'interface'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Node'interface'group' (M'.MutMsg s)) where
    setIndex (Node'interface'group' elt) i (List_Node'interface'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Node'interface'group' msg)) where
    fromPtr msg ptr = List_Node'interface'group' <$> C'.fromPtr msg ptr
    toPtr (List_Node'interface'group' l) = C'.toPtr l
get_Node'interface'methods :: U'.ReadCtx m msg => Node'interface'group' msg -> m (B'.List msg (Method msg))
get_Node'interface'methods (Node'interface'group' struct) =
    U'.getPtr 3 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "methods" (DC'.Get m (Node'interface'group' msg) ((B'.List msg (Method msg)))) where
    fromLabel = DC'.Get get_Node'interface'methods

has_Node'interface'methods :: U'.ReadCtx m msg => Node'interface'group' msg -> m Bool
has_Node'interface'methods(Node'interface'group' struct) = Data.Maybe.isJust <$> U'.getPtr 3 struct
instance U'.ReadCtx m msg => IsLabel "methods" (DC'.Has m (Node'interface'group' msg)) where
    fromLabel = DC'.Has has_Node'interface'methods

set_Node'interface'methods :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node'interface'group' (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (Method (M'.MutMsg s))) -> m ()
set_Node'interface'methods (Node'interface'group' struct) value = U'.setPtr (C'.toPtr value) 3 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "methods" (DC'.Set m (Node'interface'group' (M'.MutMsg s)) ((B'.List (M'.MutMsg s) (Method (M'.MutMsg s))))) where
    fromLabel = DC'.Set set_Node'interface'methods


get_Node'interface'superclasses :: U'.ReadCtx m msg => Node'interface'group' msg -> m (B'.List msg (Superclass msg))
get_Node'interface'superclasses (Node'interface'group' struct) =
    U'.getPtr 4 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "superclasses" (DC'.Get m (Node'interface'group' msg) ((B'.List msg (Superclass msg)))) where
    fromLabel = DC'.Get get_Node'interface'superclasses

has_Node'interface'superclasses :: U'.ReadCtx m msg => Node'interface'group' msg -> m Bool
has_Node'interface'superclasses(Node'interface'group' struct) = Data.Maybe.isJust <$> U'.getPtr 4 struct
instance U'.ReadCtx m msg => IsLabel "superclasses" (DC'.Has m (Node'interface'group' msg)) where
    fromLabel = DC'.Has has_Node'interface'superclasses

set_Node'interface'superclasses :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node'interface'group' (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (Superclass (M'.MutMsg s))) -> m ()
set_Node'interface'superclasses (Node'interface'group' struct) value = U'.setPtr (C'.toPtr value) 4 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "superclasses" (DC'.Set m (Node'interface'group' (M'.MutMsg s)) ((B'.List (M'.MutMsg s) (Superclass (M'.MutMsg s))))) where
    fromLabel = DC'.Set set_Node'interface'superclasses


newtype Node'const'group' msg = Node'const'group' (U'.Struct msg)

instance C'.IsStruct msg (Node'const'group' msg) where
    fromStruct = pure . Node'const'group'
instance C'.IsPtr msg (Node'const'group' msg) where
    fromPtr msg ptr = Node'const'group' <$> C'.fromPtr msg ptr
    toPtr (Node'const'group' struct) = C'.toPtr struct
instance B'.ListElem msg (Node'const'group' msg) where
    newtype List msg (Node'const'group' msg) = List_Node'const'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Node'const'group' l) = U'.length l
    index i (List_Node'const'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Node'const'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Node'const'group' (M'.MutMsg s)) where
    setIndex (Node'const'group' elt) i (List_Node'const'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Node'const'group' msg)) where
    fromPtr msg ptr = List_Node'const'group' <$> C'.fromPtr msg ptr
    toPtr (List_Node'const'group' l) = C'.toPtr l
get_Node'const'type_ :: U'.ReadCtx m msg => Node'const'group' msg -> m (Type msg)
get_Node'const'type_ (Node'const'group' struct) =
    U'.getPtr 3 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "type_" (DC'.Get m (Node'const'group' msg) ((Type msg))) where
    fromLabel = DC'.Get get_Node'const'type_

has_Node'const'type_ :: U'.ReadCtx m msg => Node'const'group' msg -> m Bool
has_Node'const'type_(Node'const'group' struct) = Data.Maybe.isJust <$> U'.getPtr 3 struct
instance U'.ReadCtx m msg => IsLabel "type_" (DC'.Has m (Node'const'group' msg)) where
    fromLabel = DC'.Has has_Node'const'type_

set_Node'const'type_ :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node'const'group' (M'.MutMsg s) -> (Type (M'.MutMsg s)) -> m ()
set_Node'const'type_ (Node'const'group' struct) value = U'.setPtr (C'.toPtr value) 3 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "type_" (DC'.Set m (Node'const'group' (M'.MutMsg s)) ((Type (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Node'const'type_


get_Node'const'value :: U'.ReadCtx m msg => Node'const'group' msg -> m (Value msg)
get_Node'const'value (Node'const'group' struct) =
    U'.getPtr 4 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "value" (DC'.Get m (Node'const'group' msg) ((Value msg))) where
    fromLabel = DC'.Get get_Node'const'value

has_Node'const'value :: U'.ReadCtx m msg => Node'const'group' msg -> m Bool
has_Node'const'value(Node'const'group' struct) = Data.Maybe.isJust <$> U'.getPtr 4 struct
instance U'.ReadCtx m msg => IsLabel "value" (DC'.Has m (Node'const'group' msg)) where
    fromLabel = DC'.Has has_Node'const'value

set_Node'const'value :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node'const'group' (M'.MutMsg s) -> (Value (M'.MutMsg s)) -> m ()
set_Node'const'value (Node'const'group' struct) value = U'.setPtr (C'.toPtr value) 4 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "value" (DC'.Set m (Node'const'group' (M'.MutMsg s)) ((Value (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Node'const'value


newtype Node'annotation'group' msg = Node'annotation'group' (U'.Struct msg)

instance C'.IsStruct msg (Node'annotation'group' msg) where
    fromStruct = pure . Node'annotation'group'
instance C'.IsPtr msg (Node'annotation'group' msg) where
    fromPtr msg ptr = Node'annotation'group' <$> C'.fromPtr msg ptr
    toPtr (Node'annotation'group' struct) = C'.toPtr struct
instance B'.ListElem msg (Node'annotation'group' msg) where
    newtype List msg (Node'annotation'group' msg) = List_Node'annotation'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Node'annotation'group' l) = U'.length l
    index i (List_Node'annotation'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Node'annotation'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Node'annotation'group' (M'.MutMsg s)) where
    setIndex (Node'annotation'group' elt) i (List_Node'annotation'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Node'annotation'group' msg)) where
    fromPtr msg ptr = List_Node'annotation'group' <$> C'.fromPtr msg ptr
    toPtr (List_Node'annotation'group' l) = C'.toPtr l
get_Node'annotation'type_ :: U'.ReadCtx m msg => Node'annotation'group' msg -> m (Type msg)
get_Node'annotation'type_ (Node'annotation'group' struct) =
    U'.getPtr 3 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "type_" (DC'.Get m (Node'annotation'group' msg) ((Type msg))) where
    fromLabel = DC'.Get get_Node'annotation'type_

has_Node'annotation'type_ :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
has_Node'annotation'type_(Node'annotation'group' struct) = Data.Maybe.isJust <$> U'.getPtr 3 struct
instance U'.ReadCtx m msg => IsLabel "type_" (DC'.Has m (Node'annotation'group' msg)) where
    fromLabel = DC'.Has has_Node'annotation'type_

set_Node'annotation'type_ :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node'annotation'group' (M'.MutMsg s) -> (Type (M'.MutMsg s)) -> m ()
set_Node'annotation'type_ (Node'annotation'group' struct) value = U'.setPtr (C'.toPtr value) 3 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "type_" (DC'.Set m (Node'annotation'group' (M'.MutMsg s)) ((Type (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Node'annotation'type_


get_Node'annotation'targetsFile :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
get_Node'annotation'targetsFile (Node'annotation'group' struct) = C'.getWordField struct 1 48 0
instance U'.ReadCtx m msg => IsLabel "targetsFile" (DC'.Get m (Node'annotation'group' msg) (Bool)) where
    fromLabel = DC'.Get get_Node'annotation'targetsFile

has_Node'annotation'targetsFile :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
has_Node'annotation'targetsFile(Node'annotation'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "targetsFile" (DC'.Has m (Node'annotation'group' msg)) where
    fromLabel = DC'.Has has_Node'annotation'targetsFile

set_Node'annotation'targetsFile :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node'annotation'group' (M'.MutMsg s) -> Bool -> m ()
set_Node'annotation'targetsFile (Node'annotation'group' struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word1) 1 48 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "targetsFile" (DC'.Set m (Node'annotation'group' (M'.MutMsg s)) (Bool)) where
    fromLabel = DC'.Set set_Node'annotation'targetsFile


get_Node'annotation'targetsConst :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
get_Node'annotation'targetsConst (Node'annotation'group' struct) = C'.getWordField struct 1 49 0
instance U'.ReadCtx m msg => IsLabel "targetsConst" (DC'.Get m (Node'annotation'group' msg) (Bool)) where
    fromLabel = DC'.Get get_Node'annotation'targetsConst

has_Node'annotation'targetsConst :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
has_Node'annotation'targetsConst(Node'annotation'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "targetsConst" (DC'.Has m (Node'annotation'group' msg)) where
    fromLabel = DC'.Has has_Node'annotation'targetsConst

set_Node'annotation'targetsConst :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node'annotation'group' (M'.MutMsg s) -> Bool -> m ()
set_Node'annotation'targetsConst (Node'annotation'group' struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word1) 1 49 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "targetsConst" (DC'.Set m (Node'annotation'group' (M'.MutMsg s)) (Bool)) where
    fromLabel = DC'.Set set_Node'annotation'targetsConst


get_Node'annotation'targetsEnum :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
get_Node'annotation'targetsEnum (Node'annotation'group' struct) = C'.getWordField struct 1 50 0
instance U'.ReadCtx m msg => IsLabel "targetsEnum" (DC'.Get m (Node'annotation'group' msg) (Bool)) where
    fromLabel = DC'.Get get_Node'annotation'targetsEnum

has_Node'annotation'targetsEnum :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
has_Node'annotation'targetsEnum(Node'annotation'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "targetsEnum" (DC'.Has m (Node'annotation'group' msg)) where
    fromLabel = DC'.Has has_Node'annotation'targetsEnum

set_Node'annotation'targetsEnum :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node'annotation'group' (M'.MutMsg s) -> Bool -> m ()
set_Node'annotation'targetsEnum (Node'annotation'group' struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word1) 1 50 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "targetsEnum" (DC'.Set m (Node'annotation'group' (M'.MutMsg s)) (Bool)) where
    fromLabel = DC'.Set set_Node'annotation'targetsEnum


get_Node'annotation'targetsEnumerant :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
get_Node'annotation'targetsEnumerant (Node'annotation'group' struct) = C'.getWordField struct 1 51 0
instance U'.ReadCtx m msg => IsLabel "targetsEnumerant" (DC'.Get m (Node'annotation'group' msg) (Bool)) where
    fromLabel = DC'.Get get_Node'annotation'targetsEnumerant

has_Node'annotation'targetsEnumerant :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
has_Node'annotation'targetsEnumerant(Node'annotation'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "targetsEnumerant" (DC'.Has m (Node'annotation'group' msg)) where
    fromLabel = DC'.Has has_Node'annotation'targetsEnumerant

set_Node'annotation'targetsEnumerant :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node'annotation'group' (M'.MutMsg s) -> Bool -> m ()
set_Node'annotation'targetsEnumerant (Node'annotation'group' struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word1) 1 51 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "targetsEnumerant" (DC'.Set m (Node'annotation'group' (M'.MutMsg s)) (Bool)) where
    fromLabel = DC'.Set set_Node'annotation'targetsEnumerant


get_Node'annotation'targetsStruct :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
get_Node'annotation'targetsStruct (Node'annotation'group' struct) = C'.getWordField struct 1 52 0
instance U'.ReadCtx m msg => IsLabel "targetsStruct" (DC'.Get m (Node'annotation'group' msg) (Bool)) where
    fromLabel = DC'.Get get_Node'annotation'targetsStruct

has_Node'annotation'targetsStruct :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
has_Node'annotation'targetsStruct(Node'annotation'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "targetsStruct" (DC'.Has m (Node'annotation'group' msg)) where
    fromLabel = DC'.Has has_Node'annotation'targetsStruct

set_Node'annotation'targetsStruct :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node'annotation'group' (M'.MutMsg s) -> Bool -> m ()
set_Node'annotation'targetsStruct (Node'annotation'group' struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word1) 1 52 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "targetsStruct" (DC'.Set m (Node'annotation'group' (M'.MutMsg s)) (Bool)) where
    fromLabel = DC'.Set set_Node'annotation'targetsStruct


get_Node'annotation'targetsField :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
get_Node'annotation'targetsField (Node'annotation'group' struct) = C'.getWordField struct 1 53 0
instance U'.ReadCtx m msg => IsLabel "targetsField" (DC'.Get m (Node'annotation'group' msg) (Bool)) where
    fromLabel = DC'.Get get_Node'annotation'targetsField

has_Node'annotation'targetsField :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
has_Node'annotation'targetsField(Node'annotation'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "targetsField" (DC'.Has m (Node'annotation'group' msg)) where
    fromLabel = DC'.Has has_Node'annotation'targetsField

set_Node'annotation'targetsField :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node'annotation'group' (M'.MutMsg s) -> Bool -> m ()
set_Node'annotation'targetsField (Node'annotation'group' struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word1) 1 53 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "targetsField" (DC'.Set m (Node'annotation'group' (M'.MutMsg s)) (Bool)) where
    fromLabel = DC'.Set set_Node'annotation'targetsField


get_Node'annotation'targetsUnion :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
get_Node'annotation'targetsUnion (Node'annotation'group' struct) = C'.getWordField struct 1 54 0
instance U'.ReadCtx m msg => IsLabel "targetsUnion" (DC'.Get m (Node'annotation'group' msg) (Bool)) where
    fromLabel = DC'.Get get_Node'annotation'targetsUnion

has_Node'annotation'targetsUnion :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
has_Node'annotation'targetsUnion(Node'annotation'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "targetsUnion" (DC'.Has m (Node'annotation'group' msg)) where
    fromLabel = DC'.Has has_Node'annotation'targetsUnion

set_Node'annotation'targetsUnion :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node'annotation'group' (M'.MutMsg s) -> Bool -> m ()
set_Node'annotation'targetsUnion (Node'annotation'group' struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word1) 1 54 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "targetsUnion" (DC'.Set m (Node'annotation'group' (M'.MutMsg s)) (Bool)) where
    fromLabel = DC'.Set set_Node'annotation'targetsUnion


get_Node'annotation'targetsGroup :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
get_Node'annotation'targetsGroup (Node'annotation'group' struct) = C'.getWordField struct 1 55 0
instance U'.ReadCtx m msg => IsLabel "targetsGroup" (DC'.Get m (Node'annotation'group' msg) (Bool)) where
    fromLabel = DC'.Get get_Node'annotation'targetsGroup

has_Node'annotation'targetsGroup :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
has_Node'annotation'targetsGroup(Node'annotation'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "targetsGroup" (DC'.Has m (Node'annotation'group' msg)) where
    fromLabel = DC'.Has has_Node'annotation'targetsGroup

set_Node'annotation'targetsGroup :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node'annotation'group' (M'.MutMsg s) -> Bool -> m ()
set_Node'annotation'targetsGroup (Node'annotation'group' struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word1) 1 55 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "targetsGroup" (DC'.Set m (Node'annotation'group' (M'.MutMsg s)) (Bool)) where
    fromLabel = DC'.Set set_Node'annotation'targetsGroup


get_Node'annotation'targetsInterface :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
get_Node'annotation'targetsInterface (Node'annotation'group' struct) = C'.getWordField struct 1 56 0
instance U'.ReadCtx m msg => IsLabel "targetsInterface" (DC'.Get m (Node'annotation'group' msg) (Bool)) where
    fromLabel = DC'.Get get_Node'annotation'targetsInterface

has_Node'annotation'targetsInterface :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
has_Node'annotation'targetsInterface(Node'annotation'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "targetsInterface" (DC'.Has m (Node'annotation'group' msg)) where
    fromLabel = DC'.Has has_Node'annotation'targetsInterface

set_Node'annotation'targetsInterface :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node'annotation'group' (M'.MutMsg s) -> Bool -> m ()
set_Node'annotation'targetsInterface (Node'annotation'group' struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word1) 1 56 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "targetsInterface" (DC'.Set m (Node'annotation'group' (M'.MutMsg s)) (Bool)) where
    fromLabel = DC'.Set set_Node'annotation'targetsInterface


get_Node'annotation'targetsMethod :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
get_Node'annotation'targetsMethod (Node'annotation'group' struct) = C'.getWordField struct 1 57 0
instance U'.ReadCtx m msg => IsLabel "targetsMethod" (DC'.Get m (Node'annotation'group' msg) (Bool)) where
    fromLabel = DC'.Get get_Node'annotation'targetsMethod

has_Node'annotation'targetsMethod :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
has_Node'annotation'targetsMethod(Node'annotation'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "targetsMethod" (DC'.Has m (Node'annotation'group' msg)) where
    fromLabel = DC'.Has has_Node'annotation'targetsMethod

set_Node'annotation'targetsMethod :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node'annotation'group' (M'.MutMsg s) -> Bool -> m ()
set_Node'annotation'targetsMethod (Node'annotation'group' struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word1) 1 57 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "targetsMethod" (DC'.Set m (Node'annotation'group' (M'.MutMsg s)) (Bool)) where
    fromLabel = DC'.Set set_Node'annotation'targetsMethod


get_Node'annotation'targetsParam :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
get_Node'annotation'targetsParam (Node'annotation'group' struct) = C'.getWordField struct 1 58 0
instance U'.ReadCtx m msg => IsLabel "targetsParam" (DC'.Get m (Node'annotation'group' msg) (Bool)) where
    fromLabel = DC'.Get get_Node'annotation'targetsParam

has_Node'annotation'targetsParam :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
has_Node'annotation'targetsParam(Node'annotation'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "targetsParam" (DC'.Has m (Node'annotation'group' msg)) where
    fromLabel = DC'.Has has_Node'annotation'targetsParam

set_Node'annotation'targetsParam :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node'annotation'group' (M'.MutMsg s) -> Bool -> m ()
set_Node'annotation'targetsParam (Node'annotation'group' struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word1) 1 58 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "targetsParam" (DC'.Set m (Node'annotation'group' (M'.MutMsg s)) (Bool)) where
    fromLabel = DC'.Set set_Node'annotation'targetsParam


get_Node'annotation'targetsAnnotation :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
get_Node'annotation'targetsAnnotation (Node'annotation'group' struct) = C'.getWordField struct 1 59 0
instance U'.ReadCtx m msg => IsLabel "targetsAnnotation" (DC'.Get m (Node'annotation'group' msg) (Bool)) where
    fromLabel = DC'.Get get_Node'annotation'targetsAnnotation

has_Node'annotation'targetsAnnotation :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
has_Node'annotation'targetsAnnotation(Node'annotation'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "targetsAnnotation" (DC'.Has m (Node'annotation'group' msg)) where
    fromLabel = DC'.Has has_Node'annotation'targetsAnnotation

set_Node'annotation'targetsAnnotation :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Node'annotation'group' (M'.MutMsg s) -> Bool -> m ()
set_Node'annotation'targetsAnnotation (Node'annotation'group' struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word1) 1 59 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "targetsAnnotation" (DC'.Set m (Node'annotation'group' (M'.MutMsg s)) (Bool)) where
    fromLabel = DC'.Set set_Node'annotation'targetsAnnotation



instance C'.IsStruct msg (Node' msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 1 32 0
        case tag of
            5 -> Node'annotation <$> C'.fromStruct struct
            4 -> Node'const <$> C'.fromStruct struct
            3 -> Node'interface <$> C'.fromStruct struct
            2 -> Node'enum <$> C'.fromStruct struct
            1 -> Node'struct <$> C'.fromStruct struct
            0 -> pure Node'file
            _ -> pure $ Node'unknown' tag
instance B'.ListElem msg (Node' msg) where
    newtype List msg (Node' msg) = List_Node' (U'.ListOf msg (U'.Struct msg))
    length (List_Node' l) = U'.length l
    index i (List_Node' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Node' msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (Node' msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Node' msg); go = C'.fromStruct} in go)

    toPtr = error "TODO: toPtr for non-newtype structs."

instance C'.IsPtr msg (B'.List msg (Node' msg)) where
    fromPtr msg ptr = List_Node' <$> C'.fromPtr msg ptr
    toPtr (List_Node' l) = C'.toPtr l

newtype Annotation msg = Annotation (U'.Struct msg)

instance C'.IsStruct msg (Annotation msg) where
    fromStruct = pure . Annotation
instance C'.IsPtr msg (Annotation msg) where
    fromPtr msg ptr = Annotation <$> C'.fromPtr msg ptr
    toPtr (Annotation struct) = C'.toPtr struct
instance B'.ListElem msg (Annotation msg) where
    newtype List msg (Annotation msg) = List_Annotation (U'.ListOf msg (U'.Struct msg))
    length (List_Annotation l) = U'.length l
    index i (List_Annotation l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Annotation msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Annotation (M'.MutMsg s)) where
    setIndex (Annotation elt) i (List_Annotation l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Annotation msg)) where
    fromPtr msg ptr = List_Annotation <$> C'.fromPtr msg ptr
    toPtr (List_Annotation l) = C'.toPtr l
get_Annotation'id :: U'.ReadCtx m msg => Annotation msg -> m Word64
get_Annotation'id (Annotation struct) = C'.getWordField struct 0 0 0
instance U'.ReadCtx m msg => IsLabel "id" (DC'.Get m (Annotation msg) (Word64)) where
    fromLabel = DC'.Get get_Annotation'id

has_Annotation'id :: U'.ReadCtx m msg => Annotation msg -> m Bool
has_Annotation'id(Annotation struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "id" (DC'.Has m (Annotation msg)) where
    fromLabel = DC'.Has has_Annotation'id

set_Annotation'id :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Annotation (M'.MutMsg s) -> Word64 -> m ()
set_Annotation'id (Annotation struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 0 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "id" (DC'.Set m (Annotation (M'.MutMsg s)) (Word64)) where
    fromLabel = DC'.Set set_Annotation'id


get_Annotation'value :: U'.ReadCtx m msg => Annotation msg -> m (Value msg)
get_Annotation'value (Annotation struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "value" (DC'.Get m (Annotation msg) ((Value msg))) where
    fromLabel = DC'.Get get_Annotation'value

has_Annotation'value :: U'.ReadCtx m msg => Annotation msg -> m Bool
has_Annotation'value(Annotation struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "value" (DC'.Has m (Annotation msg)) where
    fromLabel = DC'.Has has_Annotation'value

set_Annotation'value :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Annotation (M'.MutMsg s) -> (Value (M'.MutMsg s)) -> m ()
set_Annotation'value (Annotation struct) value = U'.setPtr (C'.toPtr value) 0 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "value" (DC'.Set m (Annotation (M'.MutMsg s)) ((Value (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Annotation'value


get_Annotation'brand :: U'.ReadCtx m msg => Annotation msg -> m (Brand msg)
get_Annotation'brand (Annotation struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "brand" (DC'.Get m (Annotation msg) ((Brand msg))) where
    fromLabel = DC'.Get get_Annotation'brand

has_Annotation'brand :: U'.ReadCtx m msg => Annotation msg -> m Bool
has_Annotation'brand(Annotation struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
instance U'.ReadCtx m msg => IsLabel "brand" (DC'.Has m (Annotation msg)) where
    fromLabel = DC'.Has has_Annotation'brand

set_Annotation'brand :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Annotation (M'.MutMsg s) -> (Brand (M'.MutMsg s)) -> m ()
set_Annotation'brand (Annotation struct) value = U'.setPtr (C'.toPtr value) 1 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "brand" (DC'.Set m (Annotation (M'.MutMsg s)) ((Brand (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Annotation'brand

