{-# OPTIONS_GHC -Wno-unused-imports #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeFamilies #-}
module Capnp.Capnp.Schema where

-- Code generated by capnpc-haskell. DO NOT EDIT.
-- Generated from schema file: capnp/schema.capnp

import Data.Int
import Data.Word
import qualified Data.Bits
import qualified Data.Maybe
import qualified Codec.Capnp as C'
import qualified Data.Capnp.Basics as B'
import qualified Data.Capnp.TraversalLimit as TL'
import qualified Data.Capnp.Untyped as U'
import qualified Data.Capnp.Message.Mutable as MM'

import qualified Capnp.ById.Xbdf87d7bb8304e81

data Type'anyPointer'unconstrained msg
    = Type'anyPointer'unconstrained'anyKind
    | Type'anyPointer'unconstrained'struct
    | Type'anyPointer'unconstrained'list
    | Type'anyPointer'unconstrained'capability
    | Type'anyPointer'unconstrained'unknown' Word16





instance C'.IsStruct msg (Type'anyPointer'unconstrained msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 1 16 0
        case tag of
            3 -> pure Type'anyPointer'unconstrained'capability
            2 -> pure Type'anyPointer'unconstrained'list
            1 -> pure Type'anyPointer'unconstrained'struct
            0 -> pure Type'anyPointer'unconstrained'anyKind
            _ -> pure $ Type'anyPointer'unconstrained'unknown' tag
instance B'.ListElem msg (Type'anyPointer'unconstrained msg) where
    newtype List msg (Type'anyPointer'unconstrained msg) = List_Type'anyPointer'unconstrained (U'.ListOf msg (U'.Struct msg))
    length (List_Type'anyPointer'unconstrained l) = U'.length l
    index i (List_Type'anyPointer'unconstrained l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Type'anyPointer'unconstrained msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (Type'anyPointer'unconstrained msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Type'anyPointer'unconstrained msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (B'.List msg (Type'anyPointer'unconstrained msg)) where
    fromPtr msg ptr = List_Type'anyPointer'unconstrained <$> C'.fromPtr msg ptr

newtype Brand msg = Brand (U'.Struct msg)

instance C'.IsStruct msg (Brand msg) where
    fromStruct = pure . Brand
instance C'.IsPtr msg (Brand msg) where
    fromPtr msg ptr = Brand <$> C'.fromPtr msg ptr
instance B'.ListElem msg (Brand msg) where
    newtype List msg (Brand msg) = List_Brand (U'.ListOf msg (U'.Struct msg))
    length (List_Brand l) = U'.length l
    index i (List_Brand l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Brand msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Brand (MM'.Message s)) where
    setIndex (Brand elt) i (List_Brand l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Brand msg)) where
    fromPtr msg ptr = List_Brand <$> C'.fromPtr msg ptr
get_Brand'scopes :: U'.ReadCtx m msg => Brand msg -> m (B'.List msg (Brand'Scope msg))
get_Brand'scopes (Brand struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)


has_Brand'scopes :: U'.ReadCtx m msg => Brand msg -> m Bool
has_Brand'scopes(Brand struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
newtype Method msg = Method (U'.Struct msg)

instance C'.IsStruct msg (Method msg) where
    fromStruct = pure . Method
instance C'.IsPtr msg (Method msg) where
    fromPtr msg ptr = Method <$> C'.fromPtr msg ptr
instance B'.ListElem msg (Method msg) where
    newtype List msg (Method msg) = List_Method (U'.ListOf msg (U'.Struct msg))
    length (List_Method l) = U'.length l
    index i (List_Method l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Method msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Method (MM'.Message s)) where
    setIndex (Method elt) i (List_Method l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Method msg)) where
    fromPtr msg ptr = List_Method <$> C'.fromPtr msg ptr
get_Method'name :: U'.ReadCtx m msg => Method msg -> m (B'.Text msg)
get_Method'name (Method struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)


has_Method'name :: U'.ReadCtx m msg => Method msg -> m Bool
has_Method'name(Method struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
get_Method'codeOrder :: U'.ReadCtx m msg => Method msg -> m Word16
get_Method'codeOrder (Method struct) = C'.getWordField struct 0 0 0

has_Method'codeOrder :: U'.ReadCtx m msg => Method msg -> m Bool
has_Method'codeOrder(Method struct) = pure $ 0 < U'.length (U'.dataSection struct)
get_Method'paramStructType :: U'.ReadCtx m msg => Method msg -> m Word64
get_Method'paramStructType (Method struct) = C'.getWordField struct 1 0 0

has_Method'paramStructType :: U'.ReadCtx m msg => Method msg -> m Bool
has_Method'paramStructType(Method struct) = pure $ 1 < U'.length (U'.dataSection struct)
get_Method'resultStructType :: U'.ReadCtx m msg => Method msg -> m Word64
get_Method'resultStructType (Method struct) = C'.getWordField struct 2 0 0

has_Method'resultStructType :: U'.ReadCtx m msg => Method msg -> m Bool
has_Method'resultStructType(Method struct) = pure $ 2 < U'.length (U'.dataSection struct)
get_Method'annotations :: U'.ReadCtx m msg => Method msg -> m (B'.List msg (Annotation msg))
get_Method'annotations (Method struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)


has_Method'annotations :: U'.ReadCtx m msg => Method msg -> m Bool
has_Method'annotations(Method struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
get_Method'paramBrand :: U'.ReadCtx m msg => Method msg -> m (Brand msg)
get_Method'paramBrand (Method struct) =
    U'.getPtr 2 struct
    >>= C'.fromPtr (U'.message struct)


has_Method'paramBrand :: U'.ReadCtx m msg => Method msg -> m Bool
has_Method'paramBrand(Method struct) = Data.Maybe.isJust <$> U'.getPtr 2 struct
get_Method'resultBrand :: U'.ReadCtx m msg => Method msg -> m (Brand msg)
get_Method'resultBrand (Method struct) =
    U'.getPtr 3 struct
    >>= C'.fromPtr (U'.message struct)


has_Method'resultBrand :: U'.ReadCtx m msg => Method msg -> m Bool
has_Method'resultBrand(Method struct) = Data.Maybe.isJust <$> U'.getPtr 3 struct
get_Method'implicitParameters :: U'.ReadCtx m msg => Method msg -> m (B'.List msg (Node'Parameter msg))
get_Method'implicitParameters (Method struct) =
    U'.getPtr 4 struct
    >>= C'.fromPtr (U'.message struct)


has_Method'implicitParameters :: U'.ReadCtx m msg => Method msg -> m Bool
has_Method'implicitParameters(Method struct) = Data.Maybe.isJust <$> U'.getPtr 4 struct
newtype Enumerant msg = Enumerant (U'.Struct msg)

instance C'.IsStruct msg (Enumerant msg) where
    fromStruct = pure . Enumerant
instance C'.IsPtr msg (Enumerant msg) where
    fromPtr msg ptr = Enumerant <$> C'.fromPtr msg ptr
instance B'.ListElem msg (Enumerant msg) where
    newtype List msg (Enumerant msg) = List_Enumerant (U'.ListOf msg (U'.Struct msg))
    length (List_Enumerant l) = U'.length l
    index i (List_Enumerant l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Enumerant msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Enumerant (MM'.Message s)) where
    setIndex (Enumerant elt) i (List_Enumerant l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Enumerant msg)) where
    fromPtr msg ptr = List_Enumerant <$> C'.fromPtr msg ptr
get_Enumerant'name :: U'.ReadCtx m msg => Enumerant msg -> m (B'.Text msg)
get_Enumerant'name (Enumerant struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)


has_Enumerant'name :: U'.ReadCtx m msg => Enumerant msg -> m Bool
has_Enumerant'name(Enumerant struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
get_Enumerant'codeOrder :: U'.ReadCtx m msg => Enumerant msg -> m Word16
get_Enumerant'codeOrder (Enumerant struct) = C'.getWordField struct 0 0 0

has_Enumerant'codeOrder :: U'.ReadCtx m msg => Enumerant msg -> m Bool
has_Enumerant'codeOrder(Enumerant struct) = pure $ 0 < U'.length (U'.dataSection struct)
get_Enumerant'annotations :: U'.ReadCtx m msg => Enumerant msg -> m (B'.List msg (Annotation msg))
get_Enumerant'annotations (Enumerant struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)


has_Enumerant'annotations :: U'.ReadCtx m msg => Enumerant msg -> m Bool
has_Enumerant'annotations(Enumerant struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
field'noDiscriminant :: Word16
field'noDiscriminant = C'.fromWord 65535

newtype Field msg = Field (U'.Struct msg)

instance C'.IsStruct msg (Field msg) where
    fromStruct = pure . Field
instance C'.IsPtr msg (Field msg) where
    fromPtr msg ptr = Field <$> C'.fromPtr msg ptr
instance B'.ListElem msg (Field msg) where
    newtype List msg (Field msg) = List_Field (U'.ListOf msg (U'.Struct msg))
    length (List_Field l) = U'.length l
    index i (List_Field l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Field msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Field (MM'.Message s)) where
    setIndex (Field elt) i (List_Field l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Field msg)) where
    fromPtr msg ptr = List_Field <$> C'.fromPtr msg ptr
get_Field''name :: U'.ReadCtx m msg => Field msg -> m (B'.Text msg)
get_Field''name (Field struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)


has_Field''name :: U'.ReadCtx m msg => Field msg -> m Bool
has_Field''name(Field struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
get_Field''codeOrder :: U'.ReadCtx m msg => Field msg -> m Word16
get_Field''codeOrder (Field struct) = C'.getWordField struct 0 0 0

has_Field''codeOrder :: U'.ReadCtx m msg => Field msg -> m Bool
has_Field''codeOrder(Field struct) = pure $ 0 < U'.length (U'.dataSection struct)
get_Field''annotations :: U'.ReadCtx m msg => Field msg -> m (B'.List msg (Annotation msg))
get_Field''annotations (Field struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)


has_Field''annotations :: U'.ReadCtx m msg => Field msg -> m Bool
has_Field''annotations(Field struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
get_Field''discriminantValue :: U'.ReadCtx m msg => Field msg -> m Word16
get_Field''discriminantValue (Field struct) = C'.getWordField struct 0 16 65535

has_Field''discriminantValue :: U'.ReadCtx m msg => Field msg -> m Bool
has_Field''discriminantValue(Field struct) = pure $ 0 < U'.length (U'.dataSection struct)
get_Field''ordinal :: U'.ReadCtx m msg => Field msg -> m (Field'ordinal msg)
get_Field''ordinal (Field struct) = C'.fromStruct struct

has_Field''ordinal :: U'.ReadCtx m msg => Field msg -> m Bool
has_Field''ordinal(Field struct) = pure True
get_Field''union' :: U'.ReadCtx m msg => Field msg -> m (Field' msg)
get_Field''union' (Field struct) = C'.fromStruct struct

has_Field''union' :: U'.ReadCtx m msg => Field msg -> m Bool
has_Field''union'(Field struct) = pure True
data Field' msg
    = Field'slot (Field'slot'group' msg)
    | Field'group (Field'group'group' msg)
    | Field'unknown' Word16
newtype Field'slot'group' msg = Field'slot'group' (U'.Struct msg)

instance C'.IsStruct msg (Field'slot'group' msg) where
    fromStruct = pure . Field'slot'group'
instance C'.IsPtr msg (Field'slot'group' msg) where
    fromPtr msg ptr = Field'slot'group' <$> C'.fromPtr msg ptr
instance B'.ListElem msg (Field'slot'group' msg) where
    newtype List msg (Field'slot'group' msg) = List_Field'slot'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Field'slot'group' l) = U'.length l
    index i (List_Field'slot'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Field'slot'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Field'slot'group' (MM'.Message s)) where
    setIndex (Field'slot'group' elt) i (List_Field'slot'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Field'slot'group' msg)) where
    fromPtr msg ptr = List_Field'slot'group' <$> C'.fromPtr msg ptr
get_Field'slot'offset :: U'.ReadCtx m msg => Field'slot'group' msg -> m Word32
get_Field'slot'offset (Field'slot'group' struct) = C'.getWordField struct 0 32 0

has_Field'slot'offset :: U'.ReadCtx m msg => Field'slot'group' msg -> m Bool
has_Field'slot'offset(Field'slot'group' struct) = pure $ 0 < U'.length (U'.dataSection struct)
get_Field'slot'type_ :: U'.ReadCtx m msg => Field'slot'group' msg -> m (Type msg)
get_Field'slot'type_ (Field'slot'group' struct) =
    U'.getPtr 2 struct
    >>= C'.fromPtr (U'.message struct)


has_Field'slot'type_ :: U'.ReadCtx m msg => Field'slot'group' msg -> m Bool
has_Field'slot'type_(Field'slot'group' struct) = Data.Maybe.isJust <$> U'.getPtr 2 struct
get_Field'slot'defaultValue :: U'.ReadCtx m msg => Field'slot'group' msg -> m (Value msg)
get_Field'slot'defaultValue (Field'slot'group' struct) =
    U'.getPtr 3 struct
    >>= C'.fromPtr (U'.message struct)


has_Field'slot'defaultValue :: U'.ReadCtx m msg => Field'slot'group' msg -> m Bool
has_Field'slot'defaultValue(Field'slot'group' struct) = Data.Maybe.isJust <$> U'.getPtr 3 struct
get_Field'slot'hadExplicitDefault :: U'.ReadCtx m msg => Field'slot'group' msg -> m Bool
get_Field'slot'hadExplicitDefault (Field'slot'group' struct) = C'.getWordField struct 2 0 0

has_Field'slot'hadExplicitDefault :: U'.ReadCtx m msg => Field'slot'group' msg -> m Bool
has_Field'slot'hadExplicitDefault(Field'slot'group' struct) = pure $ 2 < U'.length (U'.dataSection struct)
newtype Field'group'group' msg = Field'group'group' (U'.Struct msg)

instance C'.IsStruct msg (Field'group'group' msg) where
    fromStruct = pure . Field'group'group'
instance C'.IsPtr msg (Field'group'group' msg) where
    fromPtr msg ptr = Field'group'group' <$> C'.fromPtr msg ptr
instance B'.ListElem msg (Field'group'group' msg) where
    newtype List msg (Field'group'group' msg) = List_Field'group'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Field'group'group' l) = U'.length l
    index i (List_Field'group'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Field'group'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Field'group'group' (MM'.Message s)) where
    setIndex (Field'group'group' elt) i (List_Field'group'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Field'group'group' msg)) where
    fromPtr msg ptr = List_Field'group'group' <$> C'.fromPtr msg ptr
get_Field'group'typeId :: U'.ReadCtx m msg => Field'group'group' msg -> m Word64
get_Field'group'typeId (Field'group'group' struct) = C'.getWordField struct 2 0 0

has_Field'group'typeId :: U'.ReadCtx m msg => Field'group'group' msg -> m Bool
has_Field'group'typeId(Field'group'group' struct) = pure $ 2 < U'.length (U'.dataSection struct)

instance C'.IsStruct msg (Field' msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 1 0 0
        case tag of
            1 -> Field'group <$> C'.fromStruct struct
            0 -> Field'slot <$> C'.fromStruct struct
            _ -> pure $ Field'unknown' tag
instance B'.ListElem msg (Field' msg) where
    newtype List msg (Field' msg) = List_Field' (U'.ListOf msg (U'.Struct msg))
    length (List_Field' l) = U'.length l
    index i (List_Field' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Field' msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (Field' msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Field' msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (B'.List msg (Field' msg)) where
    fromPtr msg ptr = List_Field' <$> C'.fromPtr msg ptr

newtype Superclass msg = Superclass (U'.Struct msg)

instance C'.IsStruct msg (Superclass msg) where
    fromStruct = pure . Superclass
instance C'.IsPtr msg (Superclass msg) where
    fromPtr msg ptr = Superclass <$> C'.fromPtr msg ptr
instance B'.ListElem msg (Superclass msg) where
    newtype List msg (Superclass msg) = List_Superclass (U'.ListOf msg (U'.Struct msg))
    length (List_Superclass l) = U'.length l
    index i (List_Superclass l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Superclass msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Superclass (MM'.Message s)) where
    setIndex (Superclass elt) i (List_Superclass l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Superclass msg)) where
    fromPtr msg ptr = List_Superclass <$> C'.fromPtr msg ptr
get_Superclass'id :: U'.ReadCtx m msg => Superclass msg -> m Word64
get_Superclass'id (Superclass struct) = C'.getWordField struct 0 0 0

has_Superclass'id :: U'.ReadCtx m msg => Superclass msg -> m Bool
has_Superclass'id(Superclass struct) = pure $ 0 < U'.length (U'.dataSection struct)
get_Superclass'brand :: U'.ReadCtx m msg => Superclass msg -> m (Brand msg)
get_Superclass'brand (Superclass struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)


has_Superclass'brand :: U'.ReadCtx m msg => Superclass msg -> m Bool
has_Superclass'brand(Superclass struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
newtype Brand'Scope msg = Brand'Scope (U'.Struct msg)

instance C'.IsStruct msg (Brand'Scope msg) where
    fromStruct = pure . Brand'Scope
instance C'.IsPtr msg (Brand'Scope msg) where
    fromPtr msg ptr = Brand'Scope <$> C'.fromPtr msg ptr
instance B'.ListElem msg (Brand'Scope msg) where
    newtype List msg (Brand'Scope msg) = List_Brand'Scope (U'.ListOf msg (U'.Struct msg))
    length (List_Brand'Scope l) = U'.length l
    index i (List_Brand'Scope l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Brand'Scope msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Brand'Scope (MM'.Message s)) where
    setIndex (Brand'Scope elt) i (List_Brand'Scope l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Brand'Scope msg)) where
    fromPtr msg ptr = List_Brand'Scope <$> C'.fromPtr msg ptr
get_Brand'Scope''scopeId :: U'.ReadCtx m msg => Brand'Scope msg -> m Word64
get_Brand'Scope''scopeId (Brand'Scope struct) = C'.getWordField struct 0 0 0

has_Brand'Scope''scopeId :: U'.ReadCtx m msg => Brand'Scope msg -> m Bool
has_Brand'Scope''scopeId(Brand'Scope struct) = pure $ 0 < U'.length (U'.dataSection struct)
get_Brand'Scope''union' :: U'.ReadCtx m msg => Brand'Scope msg -> m (Brand'Scope' msg)
get_Brand'Scope''union' (Brand'Scope struct) = C'.fromStruct struct

has_Brand'Scope''union' :: U'.ReadCtx m msg => Brand'Scope msg -> m Bool
has_Brand'Scope''union'(Brand'Scope struct) = pure True
data Brand'Scope' msg
    = Brand'Scope'bind (B'.List msg (Brand'Binding msg))
    | Brand'Scope'inherit
    | Brand'Scope'unknown' Word16



instance C'.IsStruct msg (Brand'Scope' msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 1 0 0
        case tag of
            1 -> pure Brand'Scope'inherit
            0 -> Brand'Scope'bind <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            _ -> pure $ Brand'Scope'unknown' tag
instance B'.ListElem msg (Brand'Scope' msg) where
    newtype List msg (Brand'Scope' msg) = List_Brand'Scope' (U'.ListOf msg (U'.Struct msg))
    length (List_Brand'Scope' l) = U'.length l
    index i (List_Brand'Scope' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Brand'Scope' msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (Brand'Scope' msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Brand'Scope' msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (B'.List msg (Brand'Scope' msg)) where
    fromPtr msg ptr = List_Brand'Scope' <$> C'.fromPtr msg ptr

newtype CodeGeneratorRequest'RequestedFile'Import msg = CodeGeneratorRequest'RequestedFile'Import (U'.Struct msg)

instance C'.IsStruct msg (CodeGeneratorRequest'RequestedFile'Import msg) where
    fromStruct = pure . CodeGeneratorRequest'RequestedFile'Import
instance C'.IsPtr msg (CodeGeneratorRequest'RequestedFile'Import msg) where
    fromPtr msg ptr = CodeGeneratorRequest'RequestedFile'Import <$> C'.fromPtr msg ptr
instance B'.ListElem msg (CodeGeneratorRequest'RequestedFile'Import msg) where
    newtype List msg (CodeGeneratorRequest'RequestedFile'Import msg) = List_CodeGeneratorRequest'RequestedFile'Import (U'.ListOf msg (U'.Struct msg))
    length (List_CodeGeneratorRequest'RequestedFile'Import l) = U'.length l
    index i (List_CodeGeneratorRequest'RequestedFile'Import l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (CodeGeneratorRequest'RequestedFile'Import msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (CodeGeneratorRequest'RequestedFile'Import (MM'.Message s)) where
    setIndex (CodeGeneratorRequest'RequestedFile'Import elt) i (List_CodeGeneratorRequest'RequestedFile'Import l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (CodeGeneratorRequest'RequestedFile'Import msg)) where
    fromPtr msg ptr = List_CodeGeneratorRequest'RequestedFile'Import <$> C'.fromPtr msg ptr
get_CodeGeneratorRequest'RequestedFile'Import'id :: U'.ReadCtx m msg => CodeGeneratorRequest'RequestedFile'Import msg -> m Word64
get_CodeGeneratorRequest'RequestedFile'Import'id (CodeGeneratorRequest'RequestedFile'Import struct) = C'.getWordField struct 0 0 0

has_CodeGeneratorRequest'RequestedFile'Import'id :: U'.ReadCtx m msg => CodeGeneratorRequest'RequestedFile'Import msg -> m Bool
has_CodeGeneratorRequest'RequestedFile'Import'id(CodeGeneratorRequest'RequestedFile'Import struct) = pure $ 0 < U'.length (U'.dataSection struct)
get_CodeGeneratorRequest'RequestedFile'Import'name :: U'.ReadCtx m msg => CodeGeneratorRequest'RequestedFile'Import msg -> m (B'.Text msg)
get_CodeGeneratorRequest'RequestedFile'Import'name (CodeGeneratorRequest'RequestedFile'Import struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)


has_CodeGeneratorRequest'RequestedFile'Import'name :: U'.ReadCtx m msg => CodeGeneratorRequest'RequestedFile'Import msg -> m Bool
has_CodeGeneratorRequest'RequestedFile'Import'name(CodeGeneratorRequest'RequestedFile'Import struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
newtype Node'Parameter msg = Node'Parameter (U'.Struct msg)

instance C'.IsStruct msg (Node'Parameter msg) where
    fromStruct = pure . Node'Parameter
instance C'.IsPtr msg (Node'Parameter msg) where
    fromPtr msg ptr = Node'Parameter <$> C'.fromPtr msg ptr
instance B'.ListElem msg (Node'Parameter msg) where
    newtype List msg (Node'Parameter msg) = List_Node'Parameter (U'.ListOf msg (U'.Struct msg))
    length (List_Node'Parameter l) = U'.length l
    index i (List_Node'Parameter l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Node'Parameter msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Node'Parameter (MM'.Message s)) where
    setIndex (Node'Parameter elt) i (List_Node'Parameter l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Node'Parameter msg)) where
    fromPtr msg ptr = List_Node'Parameter <$> C'.fromPtr msg ptr
get_Node'Parameter'name :: U'.ReadCtx m msg => Node'Parameter msg -> m (B'.Text msg)
get_Node'Parameter'name (Node'Parameter struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)


has_Node'Parameter'name :: U'.ReadCtx m msg => Node'Parameter msg -> m Bool
has_Node'Parameter'name(Node'Parameter struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
data Field'ordinal msg
    = Field'ordinal'implicit
    | Field'ordinal'explicit Word16
    | Field'ordinal'unknown' Word16



instance C'.IsStruct msg (Field'ordinal msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 1 16 0
        case tag of
            1 -> Field'ordinal'explicit <$>  C'.getWordField struct 1 32 0
            0 -> pure Field'ordinal'implicit
            _ -> pure $ Field'ordinal'unknown' tag
instance B'.ListElem msg (Field'ordinal msg) where
    newtype List msg (Field'ordinal msg) = List_Field'ordinal (U'.ListOf msg (U'.Struct msg))
    length (List_Field'ordinal l) = U'.length l
    index i (List_Field'ordinal l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Field'ordinal msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (Field'ordinal msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Field'ordinal msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (B'.List msg (Field'ordinal msg)) where
    fromPtr msg ptr = List_Field'ordinal <$> C'.fromPtr msg ptr

newtype CodeGeneratorRequest msg = CodeGeneratorRequest (U'.Struct msg)

instance C'.IsStruct msg (CodeGeneratorRequest msg) where
    fromStruct = pure . CodeGeneratorRequest
instance C'.IsPtr msg (CodeGeneratorRequest msg) where
    fromPtr msg ptr = CodeGeneratorRequest <$> C'.fromPtr msg ptr
instance B'.ListElem msg (CodeGeneratorRequest msg) where
    newtype List msg (CodeGeneratorRequest msg) = List_CodeGeneratorRequest (U'.ListOf msg (U'.Struct msg))
    length (List_CodeGeneratorRequest l) = U'.length l
    index i (List_CodeGeneratorRequest l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (CodeGeneratorRequest msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (CodeGeneratorRequest (MM'.Message s)) where
    setIndex (CodeGeneratorRequest elt) i (List_CodeGeneratorRequest l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (CodeGeneratorRequest msg)) where
    fromPtr msg ptr = List_CodeGeneratorRequest <$> C'.fromPtr msg ptr
get_CodeGeneratorRequest'nodes :: U'.ReadCtx m msg => CodeGeneratorRequest msg -> m (B'.List msg (Node msg))
get_CodeGeneratorRequest'nodes (CodeGeneratorRequest struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)


has_CodeGeneratorRequest'nodes :: U'.ReadCtx m msg => CodeGeneratorRequest msg -> m Bool
has_CodeGeneratorRequest'nodes(CodeGeneratorRequest struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
get_CodeGeneratorRequest'requestedFiles :: U'.ReadCtx m msg => CodeGeneratorRequest msg -> m (B'.List msg (CodeGeneratorRequest'RequestedFile msg))
get_CodeGeneratorRequest'requestedFiles (CodeGeneratorRequest struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)


has_CodeGeneratorRequest'requestedFiles :: U'.ReadCtx m msg => CodeGeneratorRequest msg -> m Bool
has_CodeGeneratorRequest'requestedFiles(CodeGeneratorRequest struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
get_CodeGeneratorRequest'capnpVersion :: U'.ReadCtx m msg => CodeGeneratorRequest msg -> m (CapnpVersion msg)
get_CodeGeneratorRequest'capnpVersion (CodeGeneratorRequest struct) =
    U'.getPtr 2 struct
    >>= C'.fromPtr (U'.message struct)


has_CodeGeneratorRequest'capnpVersion :: U'.ReadCtx m msg => CodeGeneratorRequest msg -> m Bool
has_CodeGeneratorRequest'capnpVersion(CodeGeneratorRequest struct) = Data.Maybe.isJust <$> U'.getPtr 2 struct
data Type'anyPointer msg
    = Type'anyPointer'unconstrained (Type'anyPointer'unconstrained'group' msg)
    | Type'anyPointer'parameter (Type'anyPointer'parameter'group' msg)
    | Type'anyPointer'implicitMethodParameter (Type'anyPointer'implicitMethodParameter'group' msg)
    | Type'anyPointer'unknown' Word16
newtype Type'anyPointer'unconstrained'group' msg = Type'anyPointer'unconstrained'group' (U'.Struct msg)

instance C'.IsStruct msg (Type'anyPointer'unconstrained'group' msg) where
    fromStruct = pure . Type'anyPointer'unconstrained'group'
instance C'.IsPtr msg (Type'anyPointer'unconstrained'group' msg) where
    fromPtr msg ptr = Type'anyPointer'unconstrained'group' <$> C'.fromPtr msg ptr
instance B'.ListElem msg (Type'anyPointer'unconstrained'group' msg) where
    newtype List msg (Type'anyPointer'unconstrained'group' msg) = List_Type'anyPointer'unconstrained'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Type'anyPointer'unconstrained'group' l) = U'.length l
    index i (List_Type'anyPointer'unconstrained'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Type'anyPointer'unconstrained'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Type'anyPointer'unconstrained'group' (MM'.Message s)) where
    setIndex (Type'anyPointer'unconstrained'group' elt) i (List_Type'anyPointer'unconstrained'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Type'anyPointer'unconstrained'group' msg)) where
    fromPtr msg ptr = List_Type'anyPointer'unconstrained'group' <$> C'.fromPtr msg ptr
get_Type'anyPointer'unconstrained'union' :: U'.ReadCtx m msg => Type'anyPointer'unconstrained'group' msg -> m (Type'anyPointer'unconstrained msg)
get_Type'anyPointer'unconstrained'union' (Type'anyPointer'unconstrained'group' struct) = C'.fromStruct struct

has_Type'anyPointer'unconstrained'union' :: U'.ReadCtx m msg => Type'anyPointer'unconstrained'group' msg -> m Bool
has_Type'anyPointer'unconstrained'union'(Type'anyPointer'unconstrained'group' struct) = pure True
newtype Type'anyPointer'parameter'group' msg = Type'anyPointer'parameter'group' (U'.Struct msg)

instance C'.IsStruct msg (Type'anyPointer'parameter'group' msg) where
    fromStruct = pure . Type'anyPointer'parameter'group'
instance C'.IsPtr msg (Type'anyPointer'parameter'group' msg) where
    fromPtr msg ptr = Type'anyPointer'parameter'group' <$> C'.fromPtr msg ptr
instance B'.ListElem msg (Type'anyPointer'parameter'group' msg) where
    newtype List msg (Type'anyPointer'parameter'group' msg) = List_Type'anyPointer'parameter'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Type'anyPointer'parameter'group' l) = U'.length l
    index i (List_Type'anyPointer'parameter'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Type'anyPointer'parameter'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Type'anyPointer'parameter'group' (MM'.Message s)) where
    setIndex (Type'anyPointer'parameter'group' elt) i (List_Type'anyPointer'parameter'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Type'anyPointer'parameter'group' msg)) where
    fromPtr msg ptr = List_Type'anyPointer'parameter'group' <$> C'.fromPtr msg ptr
get_Type'anyPointer'parameter'scopeId :: U'.ReadCtx m msg => Type'anyPointer'parameter'group' msg -> m Word64
get_Type'anyPointer'parameter'scopeId (Type'anyPointer'parameter'group' struct) = C'.getWordField struct 2 0 0

has_Type'anyPointer'parameter'scopeId :: U'.ReadCtx m msg => Type'anyPointer'parameter'group' msg -> m Bool
has_Type'anyPointer'parameter'scopeId(Type'anyPointer'parameter'group' struct) = pure $ 2 < U'.length (U'.dataSection struct)
get_Type'anyPointer'parameter'parameterIndex :: U'.ReadCtx m msg => Type'anyPointer'parameter'group' msg -> m Word16
get_Type'anyPointer'parameter'parameterIndex (Type'anyPointer'parameter'group' struct) = C'.getWordField struct 1 16 0

has_Type'anyPointer'parameter'parameterIndex :: U'.ReadCtx m msg => Type'anyPointer'parameter'group' msg -> m Bool
has_Type'anyPointer'parameter'parameterIndex(Type'anyPointer'parameter'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
newtype Type'anyPointer'implicitMethodParameter'group' msg = Type'anyPointer'implicitMethodParameter'group' (U'.Struct msg)

instance C'.IsStruct msg (Type'anyPointer'implicitMethodParameter'group' msg) where
    fromStruct = pure . Type'anyPointer'implicitMethodParameter'group'
instance C'.IsPtr msg (Type'anyPointer'implicitMethodParameter'group' msg) where
    fromPtr msg ptr = Type'anyPointer'implicitMethodParameter'group' <$> C'.fromPtr msg ptr
instance B'.ListElem msg (Type'anyPointer'implicitMethodParameter'group' msg) where
    newtype List msg (Type'anyPointer'implicitMethodParameter'group' msg) = List_Type'anyPointer'implicitMethodParameter'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Type'anyPointer'implicitMethodParameter'group' l) = U'.length l
    index i (List_Type'anyPointer'implicitMethodParameter'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Type'anyPointer'implicitMethodParameter'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Type'anyPointer'implicitMethodParameter'group' (MM'.Message s)) where
    setIndex (Type'anyPointer'implicitMethodParameter'group' elt) i (List_Type'anyPointer'implicitMethodParameter'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Type'anyPointer'implicitMethodParameter'group' msg)) where
    fromPtr msg ptr = List_Type'anyPointer'implicitMethodParameter'group' <$> C'.fromPtr msg ptr
get_Type'anyPointer'implicitMethodParameter'parameterIndex :: U'.ReadCtx m msg => Type'anyPointer'implicitMethodParameter'group' msg -> m Word16
get_Type'anyPointer'implicitMethodParameter'parameterIndex (Type'anyPointer'implicitMethodParameter'group' struct) = C'.getWordField struct 1 16 0

has_Type'anyPointer'implicitMethodParameter'parameterIndex :: U'.ReadCtx m msg => Type'anyPointer'implicitMethodParameter'group' msg -> m Bool
has_Type'anyPointer'implicitMethodParameter'parameterIndex(Type'anyPointer'implicitMethodParameter'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)

instance C'.IsStruct msg (Type'anyPointer msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 1 0 0
        case tag of
            2 -> Type'anyPointer'implicitMethodParameter <$> C'.fromStruct struct
            1 -> Type'anyPointer'parameter <$> C'.fromStruct struct
            0 -> Type'anyPointer'unconstrained <$> C'.fromStruct struct
            _ -> pure $ Type'anyPointer'unknown' tag
instance B'.ListElem msg (Type'anyPointer msg) where
    newtype List msg (Type'anyPointer msg) = List_Type'anyPointer (U'.ListOf msg (U'.Struct msg))
    length (List_Type'anyPointer l) = U'.length l
    index i (List_Type'anyPointer l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Type'anyPointer msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (Type'anyPointer msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Type'anyPointer msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (B'.List msg (Type'anyPointer msg)) where
    fromPtr msg ptr = List_Type'anyPointer <$> C'.fromPtr msg ptr

data Brand'Binding msg
    = Brand'Binding'unbound
    | Brand'Binding'type_ (Type msg)
    | Brand'Binding'unknown' Word16



instance C'.IsStruct msg (Brand'Binding msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 0 0 0
        case tag of
            1 -> Brand'Binding'type_ <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            0 -> pure Brand'Binding'unbound
            _ -> pure $ Brand'Binding'unknown' tag
instance B'.ListElem msg (Brand'Binding msg) where
    newtype List msg (Brand'Binding msg) = List_Brand'Binding (U'.ListOf msg (U'.Struct msg))
    length (List_Brand'Binding l) = U'.length l
    index i (List_Brand'Binding l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Brand'Binding msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (Brand'Binding msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Brand'Binding msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (B'.List msg (Brand'Binding msg)) where
    fromPtr msg ptr = List_Brand'Binding <$> C'.fromPtr msg ptr

data Value msg
    = Value'void
    | Value'bool Bool
    | Value'int8 Int8
    | Value'int16 Int16
    | Value'int32 Int32
    | Value'int64 Int64
    | Value'uint8 Word8
    | Value'uint16 Word16
    | Value'uint32 Word32
    | Value'uint64 Word64
    | Value'float32 Float
    | Value'float64 Double
    | Value'text (B'.Text msg)
    | Value'data_ (B'.Data msg)
    | Value'list (Maybe (U'.Ptr msg))
    | Value'enum Word16
    | Value'struct (Maybe (U'.Ptr msg))
    | Value'interface
    | Value'anyPointer (Maybe (U'.Ptr msg))
    | Value'unknown' Word16




















instance C'.IsStruct msg (Value msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 0 0 0
        case tag of
            18 -> Value'anyPointer <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            17 -> pure Value'interface
            16 -> Value'struct <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            15 -> Value'enum <$>  C'.getWordField struct 0 16 0
            14 -> Value'list <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            13 -> Value'data_ <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            12 -> Value'text <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            11 -> Value'float64 <$>  C'.getWordField struct 1 0 0
            10 -> Value'float32 <$>  C'.getWordField struct 0 32 0
            9 -> Value'uint64 <$>  C'.getWordField struct 1 0 0
            8 -> Value'uint32 <$>  C'.getWordField struct 0 32 0
            7 -> Value'uint16 <$>  C'.getWordField struct 0 16 0
            6 -> Value'uint8 <$>  C'.getWordField struct 0 16 0
            5 -> Value'int64 <$>  C'.getWordField struct 1 0 0
            4 -> Value'int32 <$>  C'.getWordField struct 0 32 0
            3 -> Value'int16 <$>  C'.getWordField struct 0 16 0
            2 -> Value'int8 <$>  C'.getWordField struct 0 16 0
            1 -> Value'bool <$>  C'.getWordField struct 0 16 0
            0 -> pure Value'void
            _ -> pure $ Value'unknown' tag
instance B'.ListElem msg (Value msg) where
    newtype List msg (Value msg) = List_Value (U'.ListOf msg (U'.Struct msg))
    length (List_Value l) = U'.length l
    index i (List_Value l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Value msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (Value msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Value msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (B'.List msg (Value msg)) where
    fromPtr msg ptr = List_Value <$> C'.fromPtr msg ptr

newtype CodeGeneratorRequest'RequestedFile msg = CodeGeneratorRequest'RequestedFile (U'.Struct msg)

instance C'.IsStruct msg (CodeGeneratorRequest'RequestedFile msg) where
    fromStruct = pure . CodeGeneratorRequest'RequestedFile
instance C'.IsPtr msg (CodeGeneratorRequest'RequestedFile msg) where
    fromPtr msg ptr = CodeGeneratorRequest'RequestedFile <$> C'.fromPtr msg ptr
instance B'.ListElem msg (CodeGeneratorRequest'RequestedFile msg) where
    newtype List msg (CodeGeneratorRequest'RequestedFile msg) = List_CodeGeneratorRequest'RequestedFile (U'.ListOf msg (U'.Struct msg))
    length (List_CodeGeneratorRequest'RequestedFile l) = U'.length l
    index i (List_CodeGeneratorRequest'RequestedFile l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (CodeGeneratorRequest'RequestedFile msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (CodeGeneratorRequest'RequestedFile (MM'.Message s)) where
    setIndex (CodeGeneratorRequest'RequestedFile elt) i (List_CodeGeneratorRequest'RequestedFile l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (CodeGeneratorRequest'RequestedFile msg)) where
    fromPtr msg ptr = List_CodeGeneratorRequest'RequestedFile <$> C'.fromPtr msg ptr
get_CodeGeneratorRequest'RequestedFile'id :: U'.ReadCtx m msg => CodeGeneratorRequest'RequestedFile msg -> m Word64
get_CodeGeneratorRequest'RequestedFile'id (CodeGeneratorRequest'RequestedFile struct) = C'.getWordField struct 0 0 0

has_CodeGeneratorRequest'RequestedFile'id :: U'.ReadCtx m msg => CodeGeneratorRequest'RequestedFile msg -> m Bool
has_CodeGeneratorRequest'RequestedFile'id(CodeGeneratorRequest'RequestedFile struct) = pure $ 0 < U'.length (U'.dataSection struct)
get_CodeGeneratorRequest'RequestedFile'filename :: U'.ReadCtx m msg => CodeGeneratorRequest'RequestedFile msg -> m (B'.Text msg)
get_CodeGeneratorRequest'RequestedFile'filename (CodeGeneratorRequest'RequestedFile struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)


has_CodeGeneratorRequest'RequestedFile'filename :: U'.ReadCtx m msg => CodeGeneratorRequest'RequestedFile msg -> m Bool
has_CodeGeneratorRequest'RequestedFile'filename(CodeGeneratorRequest'RequestedFile struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
get_CodeGeneratorRequest'RequestedFile'imports :: U'.ReadCtx m msg => CodeGeneratorRequest'RequestedFile msg -> m (B'.List msg (CodeGeneratorRequest'RequestedFile'Import msg))
get_CodeGeneratorRequest'RequestedFile'imports (CodeGeneratorRequest'RequestedFile struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)


has_CodeGeneratorRequest'RequestedFile'imports :: U'.ReadCtx m msg => CodeGeneratorRequest'RequestedFile msg -> m Bool
has_CodeGeneratorRequest'RequestedFile'imports(CodeGeneratorRequest'RequestedFile struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
data Type msg
    = Type'void
    | Type'bool
    | Type'int8
    | Type'int16
    | Type'int32
    | Type'int64
    | Type'uint8
    | Type'uint16
    | Type'uint32
    | Type'uint64
    | Type'float32
    | Type'float64
    | Type'text
    | Type'data_
    | Type'list (Type'list'group' msg)
    | Type'enum (Type'enum'group' msg)
    | Type'struct (Type'struct'group' msg)
    | Type'interface (Type'interface'group' msg)
    | Type'anyPointer (Type'anyPointer'group' msg)
    | Type'unknown' Word16














newtype Type'list'group' msg = Type'list'group' (U'.Struct msg)

instance C'.IsStruct msg (Type'list'group' msg) where
    fromStruct = pure . Type'list'group'
instance C'.IsPtr msg (Type'list'group' msg) where
    fromPtr msg ptr = Type'list'group' <$> C'.fromPtr msg ptr
instance B'.ListElem msg (Type'list'group' msg) where
    newtype List msg (Type'list'group' msg) = List_Type'list'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Type'list'group' l) = U'.length l
    index i (List_Type'list'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Type'list'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Type'list'group' (MM'.Message s)) where
    setIndex (Type'list'group' elt) i (List_Type'list'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Type'list'group' msg)) where
    fromPtr msg ptr = List_Type'list'group' <$> C'.fromPtr msg ptr
get_Type'list'elementType :: U'.ReadCtx m msg => Type'list'group' msg -> m (Type msg)
get_Type'list'elementType (Type'list'group' struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)


has_Type'list'elementType :: U'.ReadCtx m msg => Type'list'group' msg -> m Bool
has_Type'list'elementType(Type'list'group' struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
newtype Type'enum'group' msg = Type'enum'group' (U'.Struct msg)

instance C'.IsStruct msg (Type'enum'group' msg) where
    fromStruct = pure . Type'enum'group'
instance C'.IsPtr msg (Type'enum'group' msg) where
    fromPtr msg ptr = Type'enum'group' <$> C'.fromPtr msg ptr
instance B'.ListElem msg (Type'enum'group' msg) where
    newtype List msg (Type'enum'group' msg) = List_Type'enum'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Type'enum'group' l) = U'.length l
    index i (List_Type'enum'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Type'enum'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Type'enum'group' (MM'.Message s)) where
    setIndex (Type'enum'group' elt) i (List_Type'enum'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Type'enum'group' msg)) where
    fromPtr msg ptr = List_Type'enum'group' <$> C'.fromPtr msg ptr
get_Type'enum'typeId :: U'.ReadCtx m msg => Type'enum'group' msg -> m Word64
get_Type'enum'typeId (Type'enum'group' struct) = C'.getWordField struct 1 0 0

has_Type'enum'typeId :: U'.ReadCtx m msg => Type'enum'group' msg -> m Bool
has_Type'enum'typeId(Type'enum'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
get_Type'enum'brand :: U'.ReadCtx m msg => Type'enum'group' msg -> m (Brand msg)
get_Type'enum'brand (Type'enum'group' struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)


has_Type'enum'brand :: U'.ReadCtx m msg => Type'enum'group' msg -> m Bool
has_Type'enum'brand(Type'enum'group' struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
newtype Type'struct'group' msg = Type'struct'group' (U'.Struct msg)

instance C'.IsStruct msg (Type'struct'group' msg) where
    fromStruct = pure . Type'struct'group'
instance C'.IsPtr msg (Type'struct'group' msg) where
    fromPtr msg ptr = Type'struct'group' <$> C'.fromPtr msg ptr
instance B'.ListElem msg (Type'struct'group' msg) where
    newtype List msg (Type'struct'group' msg) = List_Type'struct'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Type'struct'group' l) = U'.length l
    index i (List_Type'struct'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Type'struct'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Type'struct'group' (MM'.Message s)) where
    setIndex (Type'struct'group' elt) i (List_Type'struct'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Type'struct'group' msg)) where
    fromPtr msg ptr = List_Type'struct'group' <$> C'.fromPtr msg ptr
get_Type'struct'typeId :: U'.ReadCtx m msg => Type'struct'group' msg -> m Word64
get_Type'struct'typeId (Type'struct'group' struct) = C'.getWordField struct 1 0 0

has_Type'struct'typeId :: U'.ReadCtx m msg => Type'struct'group' msg -> m Bool
has_Type'struct'typeId(Type'struct'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
get_Type'struct'brand :: U'.ReadCtx m msg => Type'struct'group' msg -> m (Brand msg)
get_Type'struct'brand (Type'struct'group' struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)


has_Type'struct'brand :: U'.ReadCtx m msg => Type'struct'group' msg -> m Bool
has_Type'struct'brand(Type'struct'group' struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
newtype Type'interface'group' msg = Type'interface'group' (U'.Struct msg)

instance C'.IsStruct msg (Type'interface'group' msg) where
    fromStruct = pure . Type'interface'group'
instance C'.IsPtr msg (Type'interface'group' msg) where
    fromPtr msg ptr = Type'interface'group' <$> C'.fromPtr msg ptr
instance B'.ListElem msg (Type'interface'group' msg) where
    newtype List msg (Type'interface'group' msg) = List_Type'interface'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Type'interface'group' l) = U'.length l
    index i (List_Type'interface'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Type'interface'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Type'interface'group' (MM'.Message s)) where
    setIndex (Type'interface'group' elt) i (List_Type'interface'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Type'interface'group' msg)) where
    fromPtr msg ptr = List_Type'interface'group' <$> C'.fromPtr msg ptr
get_Type'interface'typeId :: U'.ReadCtx m msg => Type'interface'group' msg -> m Word64
get_Type'interface'typeId (Type'interface'group' struct) = C'.getWordField struct 1 0 0

has_Type'interface'typeId :: U'.ReadCtx m msg => Type'interface'group' msg -> m Bool
has_Type'interface'typeId(Type'interface'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
get_Type'interface'brand :: U'.ReadCtx m msg => Type'interface'group' msg -> m (Brand msg)
get_Type'interface'brand (Type'interface'group' struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)


has_Type'interface'brand :: U'.ReadCtx m msg => Type'interface'group' msg -> m Bool
has_Type'interface'brand(Type'interface'group' struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
newtype Type'anyPointer'group' msg = Type'anyPointer'group' (U'.Struct msg)

instance C'.IsStruct msg (Type'anyPointer'group' msg) where
    fromStruct = pure . Type'anyPointer'group'
instance C'.IsPtr msg (Type'anyPointer'group' msg) where
    fromPtr msg ptr = Type'anyPointer'group' <$> C'.fromPtr msg ptr
instance B'.ListElem msg (Type'anyPointer'group' msg) where
    newtype List msg (Type'anyPointer'group' msg) = List_Type'anyPointer'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Type'anyPointer'group' l) = U'.length l
    index i (List_Type'anyPointer'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Type'anyPointer'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Type'anyPointer'group' (MM'.Message s)) where
    setIndex (Type'anyPointer'group' elt) i (List_Type'anyPointer'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Type'anyPointer'group' msg)) where
    fromPtr msg ptr = List_Type'anyPointer'group' <$> C'.fromPtr msg ptr
get_Type'anyPointer'union' :: U'.ReadCtx m msg => Type'anyPointer'group' msg -> m (Type'anyPointer msg)
get_Type'anyPointer'union' (Type'anyPointer'group' struct) = C'.fromStruct struct

has_Type'anyPointer'union' :: U'.ReadCtx m msg => Type'anyPointer'group' msg -> m Bool
has_Type'anyPointer'union'(Type'anyPointer'group' struct) = pure True

instance C'.IsStruct msg (Type msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 0 0 0
        case tag of
            18 -> Type'anyPointer <$> C'.fromStruct struct
            17 -> Type'interface <$> C'.fromStruct struct
            16 -> Type'struct <$> C'.fromStruct struct
            15 -> Type'enum <$> C'.fromStruct struct
            14 -> Type'list <$> C'.fromStruct struct
            13 -> pure Type'data_
            12 -> pure Type'text
            11 -> pure Type'float64
            10 -> pure Type'float32
            9 -> pure Type'uint64
            8 -> pure Type'uint32
            7 -> pure Type'uint16
            6 -> pure Type'uint8
            5 -> pure Type'int64
            4 -> pure Type'int32
            3 -> pure Type'int16
            2 -> pure Type'int8
            1 -> pure Type'bool
            0 -> pure Type'void
            _ -> pure $ Type'unknown' tag
instance B'.ListElem msg (Type msg) where
    newtype List msg (Type msg) = List_Type (U'.ListOf msg (U'.Struct msg))
    length (List_Type l) = U'.length l
    index i (List_Type l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Type msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (Type msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Type msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (B'.List msg (Type msg)) where
    fromPtr msg ptr = List_Type <$> C'.fromPtr msg ptr

data ElementSize
    = ElementSize'empty
    | ElementSize'bit
    | ElementSize'byte
    | ElementSize'twoBytes
    | ElementSize'fourBytes
    | ElementSize'eightBytes
    | ElementSize'pointer
    | ElementSize'inlineComposite
    | ElementSize'unknown' Word16
instance Enum ElementSize where
    toEnum = C'.fromWord . fromIntegral
    fromEnum = fromIntegral . C'.toWord


instance C'.IsWord ElementSize where
    fromWord n = go (fromIntegral n :: Word16)
      where
        go 7 = ElementSize'inlineComposite
        go 6 = ElementSize'pointer
        go 5 = ElementSize'eightBytes
        go 4 = ElementSize'fourBytes
        go 3 = ElementSize'twoBytes
        go 2 = ElementSize'byte
        go 1 = ElementSize'bit
        go 0 = ElementSize'empty
        go tag = ElementSize'unknown' (fromIntegral tag)
    toWord ElementSize'inlineComposite = 7
    toWord ElementSize'pointer = 6
    toWord ElementSize'eightBytes = 5
    toWord ElementSize'fourBytes = 4
    toWord ElementSize'twoBytes = 3
    toWord ElementSize'byte = 2
    toWord ElementSize'bit = 1
    toWord ElementSize'empty = 0
    toWord (ElementSize'unknown' tag) = fromIntegral tag
instance B'.ListElem msg ElementSize where
    newtype List msg ElementSize = List_ElementSize (U'.ListOf msg Word16)
    length (List_ElementSize l) = U'.length l
    index i (List_ElementSize l) = (C'.fromWord . fromIntegral) <$> U'.index i l
instance B'.MutListElem s ElementSize where
    setIndex elt i (List_ElementSize l) = error "TODO: generate code for setIndex"
instance C'.IsPtr msg (B'.List msg ElementSize) where
    fromPtr msg ptr = List_ElementSize <$> C'.fromPtr msg ptr

newtype CapnpVersion msg = CapnpVersion (U'.Struct msg)

instance C'.IsStruct msg (CapnpVersion msg) where
    fromStruct = pure . CapnpVersion
instance C'.IsPtr msg (CapnpVersion msg) where
    fromPtr msg ptr = CapnpVersion <$> C'.fromPtr msg ptr
instance B'.ListElem msg (CapnpVersion msg) where
    newtype List msg (CapnpVersion msg) = List_CapnpVersion (U'.ListOf msg (U'.Struct msg))
    length (List_CapnpVersion l) = U'.length l
    index i (List_CapnpVersion l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (CapnpVersion msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (CapnpVersion (MM'.Message s)) where
    setIndex (CapnpVersion elt) i (List_CapnpVersion l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (CapnpVersion msg)) where
    fromPtr msg ptr = List_CapnpVersion <$> C'.fromPtr msg ptr
get_CapnpVersion'major :: U'.ReadCtx m msg => CapnpVersion msg -> m Word16
get_CapnpVersion'major (CapnpVersion struct) = C'.getWordField struct 0 0 0

has_CapnpVersion'major :: U'.ReadCtx m msg => CapnpVersion msg -> m Bool
has_CapnpVersion'major(CapnpVersion struct) = pure $ 0 < U'.length (U'.dataSection struct)
get_CapnpVersion'minor :: U'.ReadCtx m msg => CapnpVersion msg -> m Word8
get_CapnpVersion'minor (CapnpVersion struct) = C'.getWordField struct 0 16 0

has_CapnpVersion'minor :: U'.ReadCtx m msg => CapnpVersion msg -> m Bool
has_CapnpVersion'minor(CapnpVersion struct) = pure $ 0 < U'.length (U'.dataSection struct)
get_CapnpVersion'micro :: U'.ReadCtx m msg => CapnpVersion msg -> m Word8
get_CapnpVersion'micro (CapnpVersion struct) = C'.getWordField struct 0 24 0

has_CapnpVersion'micro :: U'.ReadCtx m msg => CapnpVersion msg -> m Bool
has_CapnpVersion'micro(CapnpVersion struct) = pure $ 0 < U'.length (U'.dataSection struct)
newtype Node'NestedNode msg = Node'NestedNode (U'.Struct msg)

instance C'.IsStruct msg (Node'NestedNode msg) where
    fromStruct = pure . Node'NestedNode
instance C'.IsPtr msg (Node'NestedNode msg) where
    fromPtr msg ptr = Node'NestedNode <$> C'.fromPtr msg ptr
instance B'.ListElem msg (Node'NestedNode msg) where
    newtype List msg (Node'NestedNode msg) = List_Node'NestedNode (U'.ListOf msg (U'.Struct msg))
    length (List_Node'NestedNode l) = U'.length l
    index i (List_Node'NestedNode l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Node'NestedNode msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Node'NestedNode (MM'.Message s)) where
    setIndex (Node'NestedNode elt) i (List_Node'NestedNode l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Node'NestedNode msg)) where
    fromPtr msg ptr = List_Node'NestedNode <$> C'.fromPtr msg ptr
get_Node'NestedNode'name :: U'.ReadCtx m msg => Node'NestedNode msg -> m (B'.Text msg)
get_Node'NestedNode'name (Node'NestedNode struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)


has_Node'NestedNode'name :: U'.ReadCtx m msg => Node'NestedNode msg -> m Bool
has_Node'NestedNode'name(Node'NestedNode struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
get_Node'NestedNode'id :: U'.ReadCtx m msg => Node'NestedNode msg -> m Word64
get_Node'NestedNode'id (Node'NestedNode struct) = C'.getWordField struct 0 0 0

has_Node'NestedNode'id :: U'.ReadCtx m msg => Node'NestedNode msg -> m Bool
has_Node'NestedNode'id(Node'NestedNode struct) = pure $ 0 < U'.length (U'.dataSection struct)
newtype Node msg = Node (U'.Struct msg)

instance C'.IsStruct msg (Node msg) where
    fromStruct = pure . Node
instance C'.IsPtr msg (Node msg) where
    fromPtr msg ptr = Node <$> C'.fromPtr msg ptr
instance B'.ListElem msg (Node msg) where
    newtype List msg (Node msg) = List_Node (U'.ListOf msg (U'.Struct msg))
    length (List_Node l) = U'.length l
    index i (List_Node l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Node msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Node (MM'.Message s)) where
    setIndex (Node elt) i (List_Node l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Node msg)) where
    fromPtr msg ptr = List_Node <$> C'.fromPtr msg ptr
get_Node''id :: U'.ReadCtx m msg => Node msg -> m Word64
get_Node''id (Node struct) = C'.getWordField struct 0 0 0

has_Node''id :: U'.ReadCtx m msg => Node msg -> m Bool
has_Node''id(Node struct) = pure $ 0 < U'.length (U'.dataSection struct)
get_Node''displayName :: U'.ReadCtx m msg => Node msg -> m (B'.Text msg)
get_Node''displayName (Node struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)


has_Node''displayName :: U'.ReadCtx m msg => Node msg -> m Bool
has_Node''displayName(Node struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
get_Node''displayNamePrefixLength :: U'.ReadCtx m msg => Node msg -> m Word32
get_Node''displayNamePrefixLength (Node struct) = C'.getWordField struct 1 0 0

has_Node''displayNamePrefixLength :: U'.ReadCtx m msg => Node msg -> m Bool
has_Node''displayNamePrefixLength(Node struct) = pure $ 1 < U'.length (U'.dataSection struct)
get_Node''scopeId :: U'.ReadCtx m msg => Node msg -> m Word64
get_Node''scopeId (Node struct) = C'.getWordField struct 2 0 0

has_Node''scopeId :: U'.ReadCtx m msg => Node msg -> m Bool
has_Node''scopeId(Node struct) = pure $ 2 < U'.length (U'.dataSection struct)
get_Node''nestedNodes :: U'.ReadCtx m msg => Node msg -> m (B'.List msg (Node'NestedNode msg))
get_Node''nestedNodes (Node struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)


has_Node''nestedNodes :: U'.ReadCtx m msg => Node msg -> m Bool
has_Node''nestedNodes(Node struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
get_Node''annotations :: U'.ReadCtx m msg => Node msg -> m (B'.List msg (Annotation msg))
get_Node''annotations (Node struct) =
    U'.getPtr 2 struct
    >>= C'.fromPtr (U'.message struct)


has_Node''annotations :: U'.ReadCtx m msg => Node msg -> m Bool
has_Node''annotations(Node struct) = Data.Maybe.isJust <$> U'.getPtr 2 struct
get_Node''parameters :: U'.ReadCtx m msg => Node msg -> m (B'.List msg (Node'Parameter msg))
get_Node''parameters (Node struct) =
    U'.getPtr 5 struct
    >>= C'.fromPtr (U'.message struct)


has_Node''parameters :: U'.ReadCtx m msg => Node msg -> m Bool
has_Node''parameters(Node struct) = Data.Maybe.isJust <$> U'.getPtr 5 struct
get_Node''isGeneric :: U'.ReadCtx m msg => Node msg -> m Bool
get_Node''isGeneric (Node struct) = C'.getWordField struct 4 32 0

has_Node''isGeneric :: U'.ReadCtx m msg => Node msg -> m Bool
has_Node''isGeneric(Node struct) = pure $ 4 < U'.length (U'.dataSection struct)
get_Node''union' :: U'.ReadCtx m msg => Node msg -> m (Node' msg)
get_Node''union' (Node struct) = C'.fromStruct struct

has_Node''union' :: U'.ReadCtx m msg => Node msg -> m Bool
has_Node''union'(Node struct) = pure True
data Node' msg
    = Node'file
    | Node'struct (Node'struct'group' msg)
    | Node'enum (Node'enum'group' msg)
    | Node'interface (Node'interface'group' msg)
    | Node'const (Node'const'group' msg)
    | Node'annotation (Node'annotation'group' msg)
    | Node'unknown' Word16

newtype Node'struct'group' msg = Node'struct'group' (U'.Struct msg)

instance C'.IsStruct msg (Node'struct'group' msg) where
    fromStruct = pure . Node'struct'group'
instance C'.IsPtr msg (Node'struct'group' msg) where
    fromPtr msg ptr = Node'struct'group' <$> C'.fromPtr msg ptr
instance B'.ListElem msg (Node'struct'group' msg) where
    newtype List msg (Node'struct'group' msg) = List_Node'struct'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Node'struct'group' l) = U'.length l
    index i (List_Node'struct'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Node'struct'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Node'struct'group' (MM'.Message s)) where
    setIndex (Node'struct'group' elt) i (List_Node'struct'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Node'struct'group' msg)) where
    fromPtr msg ptr = List_Node'struct'group' <$> C'.fromPtr msg ptr
get_Node'struct'dataWordCount :: U'.ReadCtx m msg => Node'struct'group' msg -> m Word16
get_Node'struct'dataWordCount (Node'struct'group' struct) = C'.getWordField struct 1 48 0

has_Node'struct'dataWordCount :: U'.ReadCtx m msg => Node'struct'group' msg -> m Bool
has_Node'struct'dataWordCount(Node'struct'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
get_Node'struct'pointerCount :: U'.ReadCtx m msg => Node'struct'group' msg -> m Word16
get_Node'struct'pointerCount (Node'struct'group' struct) = C'.getWordField struct 3 0 0

has_Node'struct'pointerCount :: U'.ReadCtx m msg => Node'struct'group' msg -> m Bool
has_Node'struct'pointerCount(Node'struct'group' struct) = pure $ 3 < U'.length (U'.dataSection struct)
get_Node'struct'preferredListEncoding :: U'.ReadCtx m msg => Node'struct'group' msg -> m ElementSize
get_Node'struct'preferredListEncoding (Node'struct'group' struct) = C'.getWordField struct 3 16 0

has_Node'struct'preferredListEncoding :: U'.ReadCtx m msg => Node'struct'group' msg -> m Bool
has_Node'struct'preferredListEncoding(Node'struct'group' struct) = pure $ 3 < U'.length (U'.dataSection struct)
get_Node'struct'isGroup :: U'.ReadCtx m msg => Node'struct'group' msg -> m Bool
get_Node'struct'isGroup (Node'struct'group' struct) = C'.getWordField struct 3 32 0

has_Node'struct'isGroup :: U'.ReadCtx m msg => Node'struct'group' msg -> m Bool
has_Node'struct'isGroup(Node'struct'group' struct) = pure $ 3 < U'.length (U'.dataSection struct)
get_Node'struct'discriminantCount :: U'.ReadCtx m msg => Node'struct'group' msg -> m Word16
get_Node'struct'discriminantCount (Node'struct'group' struct) = C'.getWordField struct 3 48 0

has_Node'struct'discriminantCount :: U'.ReadCtx m msg => Node'struct'group' msg -> m Bool
has_Node'struct'discriminantCount(Node'struct'group' struct) = pure $ 3 < U'.length (U'.dataSection struct)
get_Node'struct'discriminantOffset :: U'.ReadCtx m msg => Node'struct'group' msg -> m Word32
get_Node'struct'discriminantOffset (Node'struct'group' struct) = C'.getWordField struct 4 0 0

has_Node'struct'discriminantOffset :: U'.ReadCtx m msg => Node'struct'group' msg -> m Bool
has_Node'struct'discriminantOffset(Node'struct'group' struct) = pure $ 4 < U'.length (U'.dataSection struct)
get_Node'struct'fields :: U'.ReadCtx m msg => Node'struct'group' msg -> m (B'.List msg (Field msg))
get_Node'struct'fields (Node'struct'group' struct) =
    U'.getPtr 3 struct
    >>= C'.fromPtr (U'.message struct)


has_Node'struct'fields :: U'.ReadCtx m msg => Node'struct'group' msg -> m Bool
has_Node'struct'fields(Node'struct'group' struct) = Data.Maybe.isJust <$> U'.getPtr 3 struct
newtype Node'enum'group' msg = Node'enum'group' (U'.Struct msg)

instance C'.IsStruct msg (Node'enum'group' msg) where
    fromStruct = pure . Node'enum'group'
instance C'.IsPtr msg (Node'enum'group' msg) where
    fromPtr msg ptr = Node'enum'group' <$> C'.fromPtr msg ptr
instance B'.ListElem msg (Node'enum'group' msg) where
    newtype List msg (Node'enum'group' msg) = List_Node'enum'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Node'enum'group' l) = U'.length l
    index i (List_Node'enum'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Node'enum'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Node'enum'group' (MM'.Message s)) where
    setIndex (Node'enum'group' elt) i (List_Node'enum'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Node'enum'group' msg)) where
    fromPtr msg ptr = List_Node'enum'group' <$> C'.fromPtr msg ptr
get_Node'enum'enumerants :: U'.ReadCtx m msg => Node'enum'group' msg -> m (B'.List msg (Enumerant msg))
get_Node'enum'enumerants (Node'enum'group' struct) =
    U'.getPtr 3 struct
    >>= C'.fromPtr (U'.message struct)


has_Node'enum'enumerants :: U'.ReadCtx m msg => Node'enum'group' msg -> m Bool
has_Node'enum'enumerants(Node'enum'group' struct) = Data.Maybe.isJust <$> U'.getPtr 3 struct
newtype Node'interface'group' msg = Node'interface'group' (U'.Struct msg)

instance C'.IsStruct msg (Node'interface'group' msg) where
    fromStruct = pure . Node'interface'group'
instance C'.IsPtr msg (Node'interface'group' msg) where
    fromPtr msg ptr = Node'interface'group' <$> C'.fromPtr msg ptr
instance B'.ListElem msg (Node'interface'group' msg) where
    newtype List msg (Node'interface'group' msg) = List_Node'interface'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Node'interface'group' l) = U'.length l
    index i (List_Node'interface'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Node'interface'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Node'interface'group' (MM'.Message s)) where
    setIndex (Node'interface'group' elt) i (List_Node'interface'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Node'interface'group' msg)) where
    fromPtr msg ptr = List_Node'interface'group' <$> C'.fromPtr msg ptr
get_Node'interface'methods :: U'.ReadCtx m msg => Node'interface'group' msg -> m (B'.List msg (Method msg))
get_Node'interface'methods (Node'interface'group' struct) =
    U'.getPtr 3 struct
    >>= C'.fromPtr (U'.message struct)


has_Node'interface'methods :: U'.ReadCtx m msg => Node'interface'group' msg -> m Bool
has_Node'interface'methods(Node'interface'group' struct) = Data.Maybe.isJust <$> U'.getPtr 3 struct
get_Node'interface'superclasses :: U'.ReadCtx m msg => Node'interface'group' msg -> m (B'.List msg (Superclass msg))
get_Node'interface'superclasses (Node'interface'group' struct) =
    U'.getPtr 4 struct
    >>= C'.fromPtr (U'.message struct)


has_Node'interface'superclasses :: U'.ReadCtx m msg => Node'interface'group' msg -> m Bool
has_Node'interface'superclasses(Node'interface'group' struct) = Data.Maybe.isJust <$> U'.getPtr 4 struct
newtype Node'const'group' msg = Node'const'group' (U'.Struct msg)

instance C'.IsStruct msg (Node'const'group' msg) where
    fromStruct = pure . Node'const'group'
instance C'.IsPtr msg (Node'const'group' msg) where
    fromPtr msg ptr = Node'const'group' <$> C'.fromPtr msg ptr
instance B'.ListElem msg (Node'const'group' msg) where
    newtype List msg (Node'const'group' msg) = List_Node'const'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Node'const'group' l) = U'.length l
    index i (List_Node'const'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Node'const'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Node'const'group' (MM'.Message s)) where
    setIndex (Node'const'group' elt) i (List_Node'const'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Node'const'group' msg)) where
    fromPtr msg ptr = List_Node'const'group' <$> C'.fromPtr msg ptr
get_Node'const'type_ :: U'.ReadCtx m msg => Node'const'group' msg -> m (Type msg)
get_Node'const'type_ (Node'const'group' struct) =
    U'.getPtr 3 struct
    >>= C'.fromPtr (U'.message struct)


has_Node'const'type_ :: U'.ReadCtx m msg => Node'const'group' msg -> m Bool
has_Node'const'type_(Node'const'group' struct) = Data.Maybe.isJust <$> U'.getPtr 3 struct
get_Node'const'value :: U'.ReadCtx m msg => Node'const'group' msg -> m (Value msg)
get_Node'const'value (Node'const'group' struct) =
    U'.getPtr 4 struct
    >>= C'.fromPtr (U'.message struct)


has_Node'const'value :: U'.ReadCtx m msg => Node'const'group' msg -> m Bool
has_Node'const'value(Node'const'group' struct) = Data.Maybe.isJust <$> U'.getPtr 4 struct
newtype Node'annotation'group' msg = Node'annotation'group' (U'.Struct msg)

instance C'.IsStruct msg (Node'annotation'group' msg) where
    fromStruct = pure . Node'annotation'group'
instance C'.IsPtr msg (Node'annotation'group' msg) where
    fromPtr msg ptr = Node'annotation'group' <$> C'.fromPtr msg ptr
instance B'.ListElem msg (Node'annotation'group' msg) where
    newtype List msg (Node'annotation'group' msg) = List_Node'annotation'group' (U'.ListOf msg (U'.Struct msg))
    length (List_Node'annotation'group' l) = U'.length l
    index i (List_Node'annotation'group' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Node'annotation'group' msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Node'annotation'group' (MM'.Message s)) where
    setIndex (Node'annotation'group' elt) i (List_Node'annotation'group' l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Node'annotation'group' msg)) where
    fromPtr msg ptr = List_Node'annotation'group' <$> C'.fromPtr msg ptr
get_Node'annotation'type_ :: U'.ReadCtx m msg => Node'annotation'group' msg -> m (Type msg)
get_Node'annotation'type_ (Node'annotation'group' struct) =
    U'.getPtr 3 struct
    >>= C'.fromPtr (U'.message struct)


has_Node'annotation'type_ :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
has_Node'annotation'type_(Node'annotation'group' struct) = Data.Maybe.isJust <$> U'.getPtr 3 struct
get_Node'annotation'targetsFile :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
get_Node'annotation'targetsFile (Node'annotation'group' struct) = C'.getWordField struct 1 48 0

has_Node'annotation'targetsFile :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
has_Node'annotation'targetsFile(Node'annotation'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
get_Node'annotation'targetsConst :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
get_Node'annotation'targetsConst (Node'annotation'group' struct) = C'.getWordField struct 1 49 0

has_Node'annotation'targetsConst :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
has_Node'annotation'targetsConst(Node'annotation'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
get_Node'annotation'targetsEnum :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
get_Node'annotation'targetsEnum (Node'annotation'group' struct) = C'.getWordField struct 1 50 0

has_Node'annotation'targetsEnum :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
has_Node'annotation'targetsEnum(Node'annotation'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
get_Node'annotation'targetsEnumerant :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
get_Node'annotation'targetsEnumerant (Node'annotation'group' struct) = C'.getWordField struct 1 51 0

has_Node'annotation'targetsEnumerant :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
has_Node'annotation'targetsEnumerant(Node'annotation'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
get_Node'annotation'targetsStruct :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
get_Node'annotation'targetsStruct (Node'annotation'group' struct) = C'.getWordField struct 1 52 0

has_Node'annotation'targetsStruct :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
has_Node'annotation'targetsStruct(Node'annotation'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
get_Node'annotation'targetsField :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
get_Node'annotation'targetsField (Node'annotation'group' struct) = C'.getWordField struct 1 53 0

has_Node'annotation'targetsField :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
has_Node'annotation'targetsField(Node'annotation'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
get_Node'annotation'targetsUnion :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
get_Node'annotation'targetsUnion (Node'annotation'group' struct) = C'.getWordField struct 1 54 0

has_Node'annotation'targetsUnion :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
has_Node'annotation'targetsUnion(Node'annotation'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
get_Node'annotation'targetsGroup :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
get_Node'annotation'targetsGroup (Node'annotation'group' struct) = C'.getWordField struct 1 55 0

has_Node'annotation'targetsGroup :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
has_Node'annotation'targetsGroup(Node'annotation'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
get_Node'annotation'targetsInterface :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
get_Node'annotation'targetsInterface (Node'annotation'group' struct) = C'.getWordField struct 1 56 0

has_Node'annotation'targetsInterface :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
has_Node'annotation'targetsInterface(Node'annotation'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
get_Node'annotation'targetsMethod :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
get_Node'annotation'targetsMethod (Node'annotation'group' struct) = C'.getWordField struct 1 57 0

has_Node'annotation'targetsMethod :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
has_Node'annotation'targetsMethod(Node'annotation'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
get_Node'annotation'targetsParam :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
get_Node'annotation'targetsParam (Node'annotation'group' struct) = C'.getWordField struct 1 58 0

has_Node'annotation'targetsParam :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
has_Node'annotation'targetsParam(Node'annotation'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)
get_Node'annotation'targetsAnnotation :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
get_Node'annotation'targetsAnnotation (Node'annotation'group' struct) = C'.getWordField struct 1 59 0

has_Node'annotation'targetsAnnotation :: U'.ReadCtx m msg => Node'annotation'group' msg -> m Bool
has_Node'annotation'targetsAnnotation(Node'annotation'group' struct) = pure $ 1 < U'.length (U'.dataSection struct)

instance C'.IsStruct msg (Node' msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 1 32 0
        case tag of
            5 -> Node'annotation <$> C'.fromStruct struct
            4 -> Node'const <$> C'.fromStruct struct
            3 -> Node'interface <$> C'.fromStruct struct
            2 -> Node'enum <$> C'.fromStruct struct
            1 -> Node'struct <$> C'.fromStruct struct
            0 -> pure Node'file
            _ -> pure $ Node'unknown' tag
instance B'.ListElem msg (Node' msg) where
    newtype List msg (Node' msg) = List_Node' (U'.ListOf msg (U'.Struct msg))
    length (List_Node' l) = U'.length l
    index i (List_Node' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Node' msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (Node' msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Node' msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (B'.List msg (Node' msg)) where
    fromPtr msg ptr = List_Node' <$> C'.fromPtr msg ptr

newtype Annotation msg = Annotation (U'.Struct msg)

instance C'.IsStruct msg (Annotation msg) where
    fromStruct = pure . Annotation
instance C'.IsPtr msg (Annotation msg) where
    fromPtr msg ptr = Annotation <$> C'.fromPtr msg ptr
instance B'.ListElem msg (Annotation msg) where
    newtype List msg (Annotation msg) = List_Annotation (U'.ListOf msg (U'.Struct msg))
    length (List_Annotation l) = U'.length l
    index i (List_Annotation l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Annotation msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Annotation (MM'.Message s)) where
    setIndex (Annotation elt) i (List_Annotation l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Annotation msg)) where
    fromPtr msg ptr = List_Annotation <$> C'.fromPtr msg ptr
get_Annotation'id :: U'.ReadCtx m msg => Annotation msg -> m Word64
get_Annotation'id (Annotation struct) = C'.getWordField struct 0 0 0

has_Annotation'id :: U'.ReadCtx m msg => Annotation msg -> m Bool
has_Annotation'id(Annotation struct) = pure $ 0 < U'.length (U'.dataSection struct)
get_Annotation'value :: U'.ReadCtx m msg => Annotation msg -> m (Value msg)
get_Annotation'value (Annotation struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)


has_Annotation'value :: U'.ReadCtx m msg => Annotation msg -> m Bool
has_Annotation'value(Annotation struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
get_Annotation'brand :: U'.ReadCtx m msg => Annotation msg -> m (Brand msg)
get_Annotation'brand (Annotation struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)


has_Annotation'brand :: U'.ReadCtx m msg => Annotation msg -> m Bool
has_Annotation'brand(Annotation struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct