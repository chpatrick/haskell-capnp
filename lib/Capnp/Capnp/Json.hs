{-# OPTIONS_GHC -Wno-unused-imports #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE DataKinds #-}
module Capnp.Capnp.Json where

-- Code generated by capnpc-haskell. DO NOT EDIT.
-- Generated from schema file: capnp/json.capnp

import Data.Int
import Data.Word

import GHC.OverloadedLabels

import qualified Data.Capnp as DC'
import Data.Capnp.Bits (Word1)

import qualified Data.Bits
import qualified Data.Maybe
import qualified Codec.Capnp as C'
import qualified Data.Capnp.Basics as B'
import qualified Data.Capnp.TraversalLimit as TL'
import qualified Data.Capnp.Untyped as U'
import qualified Data.Capnp.Message as M'

import qualified Capnp.ById.Xbdf87d7bb8304e81

data JsonValue msg
    = JsonValue'null
    | JsonValue'boolean Bool
    | JsonValue'number Double
    | JsonValue'string (B'.Text msg)
    | JsonValue'array (B'.List msg (JsonValue msg))
    | JsonValue'object (B'.List msg (JsonValue'Field msg))
    | JsonValue'call (JsonValue'Call msg)
    | JsonValue'unknown' Word16








instance C'.IsStruct msg (JsonValue msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 0 0 0
        case tag of
            6 -> JsonValue'call <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            5 -> JsonValue'object <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            4 -> JsonValue'array <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            3 -> JsonValue'string <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            2 -> JsonValue'number <$>  C'.getWordField struct 1 0 0
            1 -> JsonValue'boolean <$>  C'.getWordField struct 0 16 0
            0 -> pure JsonValue'null
            _ -> pure $ JsonValue'unknown' tag
instance B'.ListElem msg (JsonValue msg) where
    newtype List msg (JsonValue msg) = List_JsonValue (U'.ListOf msg (U'.Struct msg))
    length (List_JsonValue l) = U'.length l
    index i (List_JsonValue l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (JsonValue msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (JsonValue msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (JsonValue msg); go = C'.fromStruct} in go)

    toPtr = error "TODO: toPtr for non-newtype structs."

instance C'.IsPtr msg (B'.List msg (JsonValue msg)) where
    fromPtr msg ptr = List_JsonValue <$> C'.fromPtr msg ptr
    toPtr (List_JsonValue l) = C'.toPtr l

newtype JsonValue'Call msg = JsonValue'Call_newtype_ (U'.Struct msg)

instance C'.IsStruct msg (JsonValue'Call msg) where
    fromStruct = pure . JsonValue'Call_newtype_
instance C'.IsPtr msg (JsonValue'Call msg) where
    fromPtr msg ptr = JsonValue'Call_newtype_ <$> C'.fromPtr msg ptr
    toPtr (JsonValue'Call_newtype_ struct) = C'.toPtr struct
instance B'.ListElem msg (JsonValue'Call msg) where
    newtype List msg (JsonValue'Call msg) = List_JsonValue'Call (U'.ListOf msg (U'.Struct msg))
    length (List_JsonValue'Call l) = U'.length l
    index i (List_JsonValue'Call l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (JsonValue'Call msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (JsonValue'Call (M'.MutMsg s)) where
    setIndex (JsonValue'Call_newtype_ elt) i (List_JsonValue'Call l) = U'.setIndex elt i l
    allocList msg len = List_JsonValue'Call <$> U'.allocCompositeList msg 0 2 len
instance U'.HasMessage (JsonValue'Call msg) msg where
    message (JsonValue'Call_newtype_ struct) = U'.message struct
instance U'.MessageDefault (JsonValue'Call msg) msg where
    messageDefault = JsonValue'Call_newtype_ . U'.messageDefault

-- | Allocate a new 'JsonValue'Call' inside the message.
new_JsonValue'Call :: M'.WriteCtx m s => M'.MutMsg s -> m (JsonValue'Call (M'.MutMsg s))
new_JsonValue'Call msg = JsonValue'Call_newtype_ <$> U'.allocStruct msg 0 2
instance C'.IsPtr msg (B'.List msg (JsonValue'Call msg)) where
    fromPtr msg ptr = List_JsonValue'Call <$> C'.fromPtr msg ptr
    toPtr (List_JsonValue'Call l) = C'.toPtr l
get_JsonValue'Call'function :: U'.ReadCtx m msg => JsonValue'Call msg -> m (B'.Text msg)
get_JsonValue'Call'function (JsonValue'Call_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "function" (DC'.Get (JsonValue'Call msg -> m (B'.Text msg))) where
    fromLabel = DC'.Get get_JsonValue'Call'function

has_JsonValue'Call'function :: U'.ReadCtx m msg => JsonValue'Call msg -> m Bool
has_JsonValue'Call'function(JsonValue'Call_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "function" (DC'.Has (JsonValue'Call msg -> m Bool)) where
    fromLabel = DC'.Has has_JsonValue'Call'function

set_JsonValue'Call'function :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => JsonValue'Call (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_JsonValue'Call'function (JsonValue'Call_newtype_ struct) value = U'.setPtr (C'.toPtr value) 0 struct
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "function" (DC'.Set (JsonValue'Call (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ())) where
    fromLabel = DC'.Set set_JsonValue'Call'function



get_JsonValue'Call'params :: U'.ReadCtx m msg => JsonValue'Call msg -> m (B'.List msg (JsonValue msg))
get_JsonValue'Call'params (JsonValue'Call_newtype_ struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "params" (DC'.Get (JsonValue'Call msg -> m (B'.List msg (JsonValue msg)))) where
    fromLabel = DC'.Get get_JsonValue'Call'params

has_JsonValue'Call'params :: U'.ReadCtx m msg => JsonValue'Call msg -> m Bool
has_JsonValue'Call'params(JsonValue'Call_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
instance U'.ReadCtx m msg => IsLabel "params" (DC'.Has (JsonValue'Call msg -> m Bool)) where
    fromLabel = DC'.Has has_JsonValue'Call'params

set_JsonValue'Call'params :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => JsonValue'Call (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (JsonValue (M'.MutMsg s))) -> m ()
set_JsonValue'Call'params (JsonValue'Call_newtype_ struct) value = U'.setPtr (C'.toPtr value) 1 struct
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "params" (DC'.Set (JsonValue'Call (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (JsonValue (M'.MutMsg s))) -> m ())) where
    fromLabel = DC'.Set set_JsonValue'Call'params



newtype JsonValue'Field msg = JsonValue'Field_newtype_ (U'.Struct msg)

instance C'.IsStruct msg (JsonValue'Field msg) where
    fromStruct = pure . JsonValue'Field_newtype_
instance C'.IsPtr msg (JsonValue'Field msg) where
    fromPtr msg ptr = JsonValue'Field_newtype_ <$> C'.fromPtr msg ptr
    toPtr (JsonValue'Field_newtype_ struct) = C'.toPtr struct
instance B'.ListElem msg (JsonValue'Field msg) where
    newtype List msg (JsonValue'Field msg) = List_JsonValue'Field (U'.ListOf msg (U'.Struct msg))
    length (List_JsonValue'Field l) = U'.length l
    index i (List_JsonValue'Field l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (JsonValue'Field msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (JsonValue'Field (M'.MutMsg s)) where
    setIndex (JsonValue'Field_newtype_ elt) i (List_JsonValue'Field l) = U'.setIndex elt i l
    allocList msg len = List_JsonValue'Field <$> U'.allocCompositeList msg 0 2 len
instance U'.HasMessage (JsonValue'Field msg) msg where
    message (JsonValue'Field_newtype_ struct) = U'.message struct
instance U'.MessageDefault (JsonValue'Field msg) msg where
    messageDefault = JsonValue'Field_newtype_ . U'.messageDefault

-- | Allocate a new 'JsonValue'Field' inside the message.
new_JsonValue'Field :: M'.WriteCtx m s => M'.MutMsg s -> m (JsonValue'Field (M'.MutMsg s))
new_JsonValue'Field msg = JsonValue'Field_newtype_ <$> U'.allocStruct msg 0 2
instance C'.IsPtr msg (B'.List msg (JsonValue'Field msg)) where
    fromPtr msg ptr = List_JsonValue'Field <$> C'.fromPtr msg ptr
    toPtr (List_JsonValue'Field l) = C'.toPtr l
get_JsonValue'Field'name :: U'.ReadCtx m msg => JsonValue'Field msg -> m (B'.Text msg)
get_JsonValue'Field'name (JsonValue'Field_newtype_ struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "name" (DC'.Get (JsonValue'Field msg -> m (B'.Text msg))) where
    fromLabel = DC'.Get get_JsonValue'Field'name

has_JsonValue'Field'name :: U'.ReadCtx m msg => JsonValue'Field msg -> m Bool
has_JsonValue'Field'name(JsonValue'Field_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "name" (DC'.Has (JsonValue'Field msg -> m Bool)) where
    fromLabel = DC'.Has has_JsonValue'Field'name

set_JsonValue'Field'name :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => JsonValue'Field (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_JsonValue'Field'name (JsonValue'Field_newtype_ struct) value = U'.setPtr (C'.toPtr value) 0 struct
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "name" (DC'.Set (JsonValue'Field (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ())) where
    fromLabel = DC'.Set set_JsonValue'Field'name



get_JsonValue'Field'value :: U'.ReadCtx m msg => JsonValue'Field msg -> m (JsonValue msg)
get_JsonValue'Field'value (JsonValue'Field_newtype_ struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "value" (DC'.Get (JsonValue'Field msg -> m (JsonValue msg))) where
    fromLabel = DC'.Get get_JsonValue'Field'value

has_JsonValue'Field'value :: U'.ReadCtx m msg => JsonValue'Field msg -> m Bool
has_JsonValue'Field'value(JsonValue'Field_newtype_ struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
instance U'.ReadCtx m msg => IsLabel "value" (DC'.Has (JsonValue'Field msg -> m Bool)) where
    fromLabel = DC'.Has has_JsonValue'Field'value

set_JsonValue'Field'value :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => JsonValue'Field (M'.MutMsg s) -> (JsonValue (M'.MutMsg s)) -> m ()
set_JsonValue'Field'value (JsonValue'Field_newtype_ struct) value = U'.setPtr (C'.toPtr value) 1 struct
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "value" (DC'.Set (JsonValue'Field (M'.MutMsg s) -> (JsonValue (M'.MutMsg s)) -> m ())) where
    fromLabel = DC'.Set set_JsonValue'Field'value


