{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# OPTIONS_GHC -Wno-unused-imports #-}
module Capnp.Capnp.Rpc where

-- Code generated by capnpc-haskell. DO NOT EDIT.
-- Generated from schema file: capnp/rpc.capnp

import Data.Int
import Data.Word

import Data.Capnp.Untyped.Pure (List)
import Data.Capnp.BuiltinTypes.Pure (Data, Text)
import Control.Monad.Catch (MonadThrow)
import Data.Capnp.TraversalLimit (MonadLimit)

import qualified Data.Capnp.Untyped.Pure
import qualified Data.Capnp.Untyped
import qualified Codec.Capnp

import qualified Capnp.ById.Xb312981b2552a250
import qualified Capnp.ById.Xbdf87d7bb8304e81.Pure
import qualified Capnp.ById.Xbdf87d7bb8304e81

data Call
    = Call
        { questionId :: Word32
        , target :: MessageTarget
        , interfaceId :: Word64
        , methodId :: Word16
        , params :: Payload
        , sendResultsTo :: Call'sendResultsTo
        , allowThirdPartyTailCall :: Bool
        }
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Capnp.ById.Xb312981b2552a250.Call m) Call where
    decerialize raw = Call
            <$> (Capnp.ById.Xb312981b2552a250.get_Call'questionId raw >>= Codec.Capnp.decerialize)
            <*> (Capnp.ById.Xb312981b2552a250.get_Call'target raw >>= Codec.Capnp.decerialize)
            <*> (Capnp.ById.Xb312981b2552a250.get_Call'interfaceId raw >>= Codec.Capnp.decerialize)
            <*> (Capnp.ById.Xb312981b2552a250.get_Call'methodId raw >>= Codec.Capnp.decerialize)
            <*> (Capnp.ById.Xb312981b2552a250.get_Call'params raw >>= Codec.Capnp.decerialize)
            <*> (Capnp.ById.Xb312981b2552a250.get_Call'sendResultsTo raw >>= Codec.Capnp.decerialize)
            <*> (Capnp.ById.Xb312981b2552a250.get_Call'allowThirdPartyTailCall raw >>= Codec.Capnp.decerialize)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Call where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Capnp.ById.Xb312981b2552a250.Call m)

data CapDescriptor
    = CapDescriptor'none
    | CapDescriptor'senderHosted (Word32)
    | CapDescriptor'senderPromise (Word32)
    | CapDescriptor'receiverHosted (Word32)
    | CapDescriptor'receiverAnswer (PromisedAnswer)
    | CapDescriptor'thirdPartyHosted (ThirdPartyCapDescriptor)
    | CapDescriptor'unknown' (Word16)
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Capnp.ById.Xb312981b2552a250.CapDescriptor m) CapDescriptor where
    decerialize raw = case raw of

        Capnp.ById.Xb312981b2552a250.CapDescriptor'none -> pure CapDescriptor'none
        Capnp.ById.Xb312981b2552a250.CapDescriptor'senderHosted val -> CapDescriptor'senderHosted <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.CapDescriptor'senderPromise val -> CapDescriptor'senderPromise <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.CapDescriptor'receiverHosted val -> CapDescriptor'receiverHosted <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.CapDescriptor'receiverAnswer val -> CapDescriptor'receiverAnswer <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.CapDescriptor'thirdPartyHosted val -> CapDescriptor'thirdPartyHosted <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.CapDescriptor'unknown' val -> CapDescriptor'unknown' <$> Codec.Capnp.decerialize val

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m CapDescriptor where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Capnp.ById.Xb312981b2552a250.CapDescriptor m)

data Message
    = Message'unimplemented (Message)
    | Message'abort (Exception)
    | Message'call (Call)
    | Message'return (Return)
    | Message'finish (Finish)
    | Message'resolve (Resolve)
    | Message'release (Release)
    | Message'obsoleteSave (Maybe (Data.Capnp.Untyped.Pure.PtrType))
    | Message'bootstrap (Bootstrap)
    | Message'obsoleteDelete (Maybe (Data.Capnp.Untyped.Pure.PtrType))
    | Message'provide (Provide)
    | Message'accept (Accept)
    | Message'join (Join)
    | Message'disembargo (Disembargo)
    | Message'unknown' (Word16)
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Capnp.ById.Xb312981b2552a250.Message m) Message where
    decerialize raw = case raw of

        Capnp.ById.Xb312981b2552a250.Message'unimplemented val -> Message'unimplemented <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.Message'abort val -> Message'abort <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.Message'call val -> Message'call <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.Message'return val -> Message'return <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.Message'finish val -> Message'finish <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.Message'resolve val -> Message'resolve <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.Message'release val -> Message'release <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.Message'obsoleteSave val -> Message'obsoleteSave <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.Message'bootstrap val -> Message'bootstrap <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.Message'obsoleteDelete val -> Message'obsoleteDelete <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.Message'provide val -> Message'provide <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.Message'accept val -> Message'accept <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.Message'join val -> Message'join <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.Message'disembargo val -> Message'disembargo <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.Message'unknown' val -> Message'unknown' <$> Codec.Capnp.decerialize val

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Message where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Capnp.ById.Xb312981b2552a250.Message m)

data MessageTarget
    = MessageTarget'importedCap (Word32)
    | MessageTarget'promisedAnswer (PromisedAnswer)
    | MessageTarget'unknown' (Word16)
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Capnp.ById.Xb312981b2552a250.MessageTarget m) MessageTarget where
    decerialize raw = case raw of

        Capnp.ById.Xb312981b2552a250.MessageTarget'importedCap val -> MessageTarget'importedCap <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.MessageTarget'promisedAnswer val -> MessageTarget'promisedAnswer <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.MessageTarget'unknown' val -> MessageTarget'unknown' <$> Codec.Capnp.decerialize val

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m MessageTarget where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Capnp.ById.Xb312981b2552a250.MessageTarget m)

data Payload
    = Payload
        { content :: Maybe (Data.Capnp.Untyped.Pure.PtrType)
        , capTable :: List (CapDescriptor)
        }
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Capnp.ById.Xb312981b2552a250.Payload m) Payload where
    decerialize raw = Payload
            <$> (Capnp.ById.Xb312981b2552a250.get_Payload'content raw >>= Codec.Capnp.decerialize)
            <*> (Capnp.ById.Xb312981b2552a250.get_Payload'capTable raw >>= Codec.Capnp.decerialize)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Payload where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Capnp.ById.Xb312981b2552a250.Payload m)

data Provide
    = Provide
        { questionId :: Word32
        , target :: MessageTarget
        , recipient :: Maybe (Data.Capnp.Untyped.Pure.PtrType)
        }
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Capnp.ById.Xb312981b2552a250.Provide m) Provide where
    decerialize raw = Provide
            <$> (Capnp.ById.Xb312981b2552a250.get_Provide'questionId raw >>= Codec.Capnp.decerialize)
            <*> (Capnp.ById.Xb312981b2552a250.get_Provide'target raw >>= Codec.Capnp.decerialize)
            <*> (Capnp.ById.Xb312981b2552a250.get_Provide'recipient raw >>= Codec.Capnp.decerialize)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Provide where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Capnp.ById.Xb312981b2552a250.Provide m)

data Return
    = Return'
        { answerId :: Word32
        , releaseParamCaps :: Bool
        , union' :: Return'
        }
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Capnp.ById.Xb312981b2552a250.Return m) Return where
    decerialize raw = Return'
            <$> (Capnp.ById.Xb312981b2552a250.get_Return''answerId raw >>= Codec.Capnp.decerialize)
            <*> (Capnp.ById.Xb312981b2552a250.get_Return''releaseParamCaps raw >>= Codec.Capnp.decerialize)
            <*> (Capnp.ById.Xb312981b2552a250.get_Return''union' raw >>= Codec.Capnp.decerialize)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Return where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Capnp.ById.Xb312981b2552a250.Return m)

data Return'
    = Return'results (Payload)
    | Return'exception (Exception)
    | Return'canceled
    | Return'resultsSentElsewhere
    | Return'takeFromOtherQuestion (Word32)
    | Return'acceptFromThirdParty (Maybe (Data.Capnp.Untyped.Pure.PtrType))
    | Return'unknown' (Word16)
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Capnp.ById.Xb312981b2552a250.Return' m) Return' where
    decerialize raw = case raw of

        Capnp.ById.Xb312981b2552a250.Return'results val -> Return'results <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.Return'exception val -> Return'exception <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.Return'canceled -> pure Return'canceled
        Capnp.ById.Xb312981b2552a250.Return'resultsSentElsewhere -> pure Return'resultsSentElsewhere
        Capnp.ById.Xb312981b2552a250.Return'takeFromOtherQuestion val -> Return'takeFromOtherQuestion <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.Return'acceptFromThirdParty val -> Return'acceptFromThirdParty <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.Return'unknown' val -> Return'unknown' <$> Codec.Capnp.decerialize val

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Return' where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Capnp.ById.Xb312981b2552a250.Return' m)

data Release
    = Release
        { id :: Word32
        , referenceCount :: Word32
        }
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Capnp.ById.Xb312981b2552a250.Release m) Release where
    decerialize raw = Release
            <$> (Capnp.ById.Xb312981b2552a250.get_Release'id raw >>= Codec.Capnp.decerialize)
            <*> (Capnp.ById.Xb312981b2552a250.get_Release'referenceCount raw >>= Codec.Capnp.decerialize)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Release where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Capnp.ById.Xb312981b2552a250.Release m)

data Exception'Type
    = Exception'Type'failed
    | Exception'Type'overloaded
    | Exception'Type'disconnected
    | Exception'Type'unimplemented
    | Exception'Type'unknown' (Word16)
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Capnp.ById.Xb312981b2552a250.Exception'Type m) Exception'Type where
    decerialize raw = case raw of

        Capnp.ById.Xb312981b2552a250.Exception'Type'failed -> pure Exception'Type'failed
        Capnp.ById.Xb312981b2552a250.Exception'Type'overloaded -> pure Exception'Type'overloaded
        Capnp.ById.Xb312981b2552a250.Exception'Type'disconnected -> pure Exception'Type'disconnected
        Capnp.ById.Xb312981b2552a250.Exception'Type'unimplemented -> pure Exception'Type'unimplemented
        Capnp.ById.Xb312981b2552a250.Exception'Type'unknown' val -> Exception'Type'unknown' <$> Codec.Capnp.decerialize val

data Resolve
    = Resolve'
        { promiseId :: Word32
        , union' :: Resolve'
        }
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Capnp.ById.Xb312981b2552a250.Resolve m) Resolve where
    decerialize raw = Resolve'
            <$> (Capnp.ById.Xb312981b2552a250.get_Resolve''promiseId raw >>= Codec.Capnp.decerialize)
            <*> (Capnp.ById.Xb312981b2552a250.get_Resolve''union' raw >>= Codec.Capnp.decerialize)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Resolve where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Capnp.ById.Xb312981b2552a250.Resolve m)

data Resolve'
    = Resolve'cap (CapDescriptor)
    | Resolve'exception (Exception)
    | Resolve'unknown' (Word16)
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Capnp.ById.Xb312981b2552a250.Resolve' m) Resolve' where
    decerialize raw = case raw of

        Capnp.ById.Xb312981b2552a250.Resolve'cap val -> Resolve'cap <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.Resolve'exception val -> Resolve'exception <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.Resolve'unknown' val -> Resolve'unknown' <$> Codec.Capnp.decerialize val

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Resolve' where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Capnp.ById.Xb312981b2552a250.Resolve' m)

data ThirdPartyCapDescriptor
    = ThirdPartyCapDescriptor
        { id :: Maybe (Data.Capnp.Untyped.Pure.PtrType)
        , vineId :: Word32
        }
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Capnp.ById.Xb312981b2552a250.ThirdPartyCapDescriptor m) ThirdPartyCapDescriptor where
    decerialize raw = ThirdPartyCapDescriptor
            <$> (Capnp.ById.Xb312981b2552a250.get_ThirdPartyCapDescriptor'id raw >>= Codec.Capnp.decerialize)
            <*> (Capnp.ById.Xb312981b2552a250.get_ThirdPartyCapDescriptor'vineId raw >>= Codec.Capnp.decerialize)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m ThirdPartyCapDescriptor where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Capnp.ById.Xb312981b2552a250.ThirdPartyCapDescriptor m)

data Finish
    = Finish
        { questionId :: Word32
        , releaseResultCaps :: Bool
        }
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Capnp.ById.Xb312981b2552a250.Finish m) Finish where
    decerialize raw = Finish
            <$> (Capnp.ById.Xb312981b2552a250.get_Finish'questionId raw >>= Codec.Capnp.decerialize)
            <*> (Capnp.ById.Xb312981b2552a250.get_Finish'releaseResultCaps raw >>= Codec.Capnp.decerialize)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Finish where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Capnp.ById.Xb312981b2552a250.Finish m)

data Accept
    = Accept
        { questionId :: Word32
        , provision :: Maybe (Data.Capnp.Untyped.Pure.PtrType)
        , embargo :: Bool
        }
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Capnp.ById.Xb312981b2552a250.Accept m) Accept where
    decerialize raw = Accept
            <$> (Capnp.ById.Xb312981b2552a250.get_Accept'questionId raw >>= Codec.Capnp.decerialize)
            <*> (Capnp.ById.Xb312981b2552a250.get_Accept'provision raw >>= Codec.Capnp.decerialize)
            <*> (Capnp.ById.Xb312981b2552a250.get_Accept'embargo raw >>= Codec.Capnp.decerialize)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Accept where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Capnp.ById.Xb312981b2552a250.Accept m)

data Disembargo'context
    = Disembargo'context'senderLoopback (Word32)
    | Disembargo'context'receiverLoopback (Word32)
    | Disembargo'context'accept
    | Disembargo'context'provide (Word32)
    | Disembargo'context'unknown' (Word16)
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Capnp.ById.Xb312981b2552a250.Disembargo'context m) Disembargo'context where
    decerialize raw = case raw of

        Capnp.ById.Xb312981b2552a250.Disembargo'context'senderLoopback val -> Disembargo'context'senderLoopback <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.Disembargo'context'receiverLoopback val -> Disembargo'context'receiverLoopback <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.Disembargo'context'accept -> pure Disembargo'context'accept
        Capnp.ById.Xb312981b2552a250.Disembargo'context'provide val -> Disembargo'context'provide <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.Disembargo'context'unknown' val -> Disembargo'context'unknown' <$> Codec.Capnp.decerialize val

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Disembargo'context where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Capnp.ById.Xb312981b2552a250.Disembargo'context m)

data Exception
    = Exception
        { reason :: Text
        , obsoleteIsCallersFault :: Bool
        , obsoleteDurability :: Word16
        , type_ :: Exception'Type
        }
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Capnp.ById.Xb312981b2552a250.Exception m) Exception where
    decerialize raw = Exception
            <$> (Capnp.ById.Xb312981b2552a250.get_Exception'reason raw >>= Codec.Capnp.decerialize)
            <*> (Capnp.ById.Xb312981b2552a250.get_Exception'obsoleteIsCallersFault raw >>= Codec.Capnp.decerialize)
            <*> (Capnp.ById.Xb312981b2552a250.get_Exception'obsoleteDurability raw >>= Codec.Capnp.decerialize)
            <*> (Capnp.ById.Xb312981b2552a250.get_Exception'type_ raw >>= Codec.Capnp.decerialize)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Exception where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Capnp.ById.Xb312981b2552a250.Exception m)

data PromisedAnswer
    = PromisedAnswer
        { questionId :: Word32
        , transform :: List (PromisedAnswer'Op)
        }
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Capnp.ById.Xb312981b2552a250.PromisedAnswer m) PromisedAnswer where
    decerialize raw = PromisedAnswer
            <$> (Capnp.ById.Xb312981b2552a250.get_PromisedAnswer'questionId raw >>= Codec.Capnp.decerialize)
            <*> (Capnp.ById.Xb312981b2552a250.get_PromisedAnswer'transform raw >>= Codec.Capnp.decerialize)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m PromisedAnswer where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Capnp.ById.Xb312981b2552a250.PromisedAnswer m)

data Call'sendResultsTo
    = Call'sendResultsTo'caller
    | Call'sendResultsTo'yourself
    | Call'sendResultsTo'thirdParty (Maybe (Data.Capnp.Untyped.Pure.PtrType))
    | Call'sendResultsTo'unknown' (Word16)
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Capnp.ById.Xb312981b2552a250.Call'sendResultsTo m) Call'sendResultsTo where
    decerialize raw = case raw of

        Capnp.ById.Xb312981b2552a250.Call'sendResultsTo'caller -> pure Call'sendResultsTo'caller
        Capnp.ById.Xb312981b2552a250.Call'sendResultsTo'yourself -> pure Call'sendResultsTo'yourself
        Capnp.ById.Xb312981b2552a250.Call'sendResultsTo'thirdParty val -> Call'sendResultsTo'thirdParty <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.Call'sendResultsTo'unknown' val -> Call'sendResultsTo'unknown' <$> Codec.Capnp.decerialize val

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Call'sendResultsTo where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Capnp.ById.Xb312981b2552a250.Call'sendResultsTo m)

data Bootstrap
    = Bootstrap
        { questionId :: Word32
        , deprecatedObjectId :: Maybe (Data.Capnp.Untyped.Pure.PtrType)
        }
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Capnp.ById.Xb312981b2552a250.Bootstrap m) Bootstrap where
    decerialize raw = Bootstrap
            <$> (Capnp.ById.Xb312981b2552a250.get_Bootstrap'questionId raw >>= Codec.Capnp.decerialize)
            <*> (Capnp.ById.Xb312981b2552a250.get_Bootstrap'deprecatedObjectId raw >>= Codec.Capnp.decerialize)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Bootstrap where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Capnp.ById.Xb312981b2552a250.Bootstrap m)

data PromisedAnswer'Op
    = PromisedAnswer'Op'noop
    | PromisedAnswer'Op'getPointerField (Word16)
    | PromisedAnswer'Op'unknown' (Word16)
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Capnp.ById.Xb312981b2552a250.PromisedAnswer'Op m) PromisedAnswer'Op where
    decerialize raw = case raw of

        Capnp.ById.Xb312981b2552a250.PromisedAnswer'Op'noop -> pure PromisedAnswer'Op'noop
        Capnp.ById.Xb312981b2552a250.PromisedAnswer'Op'getPointerField val -> PromisedAnswer'Op'getPointerField <$> Codec.Capnp.decerialize val
        Capnp.ById.Xb312981b2552a250.PromisedAnswer'Op'unknown' val -> PromisedAnswer'Op'unknown' <$> Codec.Capnp.decerialize val

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m PromisedAnswer'Op where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Capnp.ById.Xb312981b2552a250.PromisedAnswer'Op m)

data Disembargo
    = Disembargo
        { target :: MessageTarget
        , context :: Disembargo'context
        }
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Capnp.ById.Xb312981b2552a250.Disembargo m) Disembargo where
    decerialize raw = Disembargo
            <$> (Capnp.ById.Xb312981b2552a250.get_Disembargo'target raw >>= Codec.Capnp.decerialize)
            <*> (Capnp.ById.Xb312981b2552a250.get_Disembargo'context raw >>= Codec.Capnp.decerialize)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Disembargo where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Capnp.ById.Xb312981b2552a250.Disembargo m)

data Join
    = Join
        { questionId :: Word32
        , target :: MessageTarget
        , keyPart :: Maybe (Data.Capnp.Untyped.Pure.PtrType)
        }
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Capnp.ById.Xb312981b2552a250.Join m) Join where
    decerialize raw = Join
            <$> (Capnp.ById.Xb312981b2552a250.get_Join'questionId raw >>= Codec.Capnp.decerialize)
            <*> (Capnp.ById.Xb312981b2552a250.get_Join'target raw >>= Codec.Capnp.decerialize)
            <*> (Capnp.ById.Xb312981b2552a250.get_Join'keyPart raw >>= Codec.Capnp.decerialize)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Join where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Capnp.ById.Xb312981b2552a250.Join m)

