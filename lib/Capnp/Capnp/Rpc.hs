{-# OPTIONS_GHC -Wno-unused-imports #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE DataKinds #-}
module Capnp.Capnp.Rpc where

-- Code generated by capnpc-haskell. DO NOT EDIT.
-- Generated from schema file: capnp/rpc.capnp

import Data.Int
import Data.Word

import GHC.OverloadedLabels

import qualified Data.Capnp as DC'
import Data.Capnp.Bits (Word1)

import qualified Data.Bits
import qualified Data.Maybe
import qualified Codec.Capnp as C'
import qualified Data.Capnp.Basics as B'
import qualified Data.Capnp.TraversalLimit as TL'
import qualified Data.Capnp.Untyped as U'
import qualified Data.Capnp.Message as M'

import qualified Capnp.ById.Xbdf87d7bb8304e81

newtype Call msg = Call (U'.Struct msg)

instance C'.IsStruct msg (Call msg) where
    fromStruct = pure . Call
instance C'.IsPtr msg (Call msg) where
    fromPtr msg ptr = Call <$> C'.fromPtr msg ptr
    toPtr (Call struct) = C'.toPtr struct
instance B'.ListElem msg (Call msg) where
    newtype List msg (Call msg) = List_Call (U'.ListOf msg (U'.Struct msg))
    length (List_Call l) = U'.length l
    index i (List_Call l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Call msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Call (M'.MutMsg s)) where
    setIndex (Call elt) i (List_Call l) = U'.setIndex elt i l
    allocList msg len = List_Call <$> U'.allocCompositeList msg 3 3 len

-- | Allocate a new 'Call' inside the message.
new_Call :: M'.WriteCtx m s => M'.MutMsg s -> m (Call (M'.MutMsg s))
new_Call msg = Call <$> U'.allocStruct msg 3 3
instance C'.IsPtr msg (B'.List msg (Call msg)) where
    fromPtr msg ptr = List_Call <$> C'.fromPtr msg ptr
    toPtr (List_Call l) = C'.toPtr l
get_Call'questionId :: U'.ReadCtx m msg => Call msg -> m Word32
get_Call'questionId (Call struct) = C'.getWordField struct 0 0 0
instance U'.ReadCtx m msg => IsLabel "questionId" (DC'.Get m (Call msg) (Word32)) where
    fromLabel = DC'.Get get_Call'questionId

has_Call'questionId :: U'.ReadCtx m msg => Call msg -> m Bool
has_Call'questionId(Call struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "questionId" (DC'.Has m (Call msg)) where
    fromLabel = DC'.Has has_Call'questionId

set_Call'questionId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Call (M'.MutMsg s) -> Word32 -> m ()
set_Call'questionId (Call struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "questionId" (DC'.Set m (Call (M'.MutMsg s)) (Word32)) where
    fromLabel = DC'.Set set_Call'questionId


get_Call'target :: U'.ReadCtx m msg => Call msg -> m (MessageTarget msg)
get_Call'target (Call struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "target" (DC'.Get m (Call msg) ((MessageTarget msg))) where
    fromLabel = DC'.Get get_Call'target

has_Call'target :: U'.ReadCtx m msg => Call msg -> m Bool
has_Call'target(Call struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "target" (DC'.Has m (Call msg)) where
    fromLabel = DC'.Has has_Call'target

set_Call'target :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Call (M'.MutMsg s) -> (MessageTarget (M'.MutMsg s)) -> m ()
set_Call'target (Call struct) value = U'.setPtr (C'.toPtr value) 0 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "target" (DC'.Set m (Call (M'.MutMsg s)) ((MessageTarget (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Call'target


get_Call'interfaceId :: U'.ReadCtx m msg => Call msg -> m Word64
get_Call'interfaceId (Call struct) = C'.getWordField struct 1 0 0
instance U'.ReadCtx m msg => IsLabel "interfaceId" (DC'.Get m (Call msg) (Word64)) where
    fromLabel = DC'.Get get_Call'interfaceId

has_Call'interfaceId :: U'.ReadCtx m msg => Call msg -> m Bool
has_Call'interfaceId(Call struct) = pure $ 1 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "interfaceId" (DC'.Has m (Call msg)) where
    fromLabel = DC'.Has has_Call'interfaceId

set_Call'interfaceId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Call (M'.MutMsg s) -> Word64 -> m ()
set_Call'interfaceId (Call struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 1 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "interfaceId" (DC'.Set m (Call (M'.MutMsg s)) (Word64)) where
    fromLabel = DC'.Set set_Call'interfaceId


get_Call'methodId :: U'.ReadCtx m msg => Call msg -> m Word16
get_Call'methodId (Call struct) = C'.getWordField struct 0 32 0
instance U'.ReadCtx m msg => IsLabel "methodId" (DC'.Get m (Call msg) (Word16)) where
    fromLabel = DC'.Get get_Call'methodId

has_Call'methodId :: U'.ReadCtx m msg => Call msg -> m Bool
has_Call'methodId(Call struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "methodId" (DC'.Has m (Call msg)) where
    fromLabel = DC'.Has has_Call'methodId

set_Call'methodId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Call (M'.MutMsg s) -> Word16 -> m ()
set_Call'methodId (Call struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word16) 0 32 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "methodId" (DC'.Set m (Call (M'.MutMsg s)) (Word16)) where
    fromLabel = DC'.Set set_Call'methodId


get_Call'params :: U'.ReadCtx m msg => Call msg -> m (Payload msg)
get_Call'params (Call struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "params" (DC'.Get m (Call msg) ((Payload msg))) where
    fromLabel = DC'.Get get_Call'params

has_Call'params :: U'.ReadCtx m msg => Call msg -> m Bool
has_Call'params(Call struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
instance U'.ReadCtx m msg => IsLabel "params" (DC'.Has m (Call msg)) where
    fromLabel = DC'.Has has_Call'params

set_Call'params :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Call (M'.MutMsg s) -> (Payload (M'.MutMsg s)) -> m ()
set_Call'params (Call struct) value = U'.setPtr (C'.toPtr value) 1 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "params" (DC'.Set m (Call (M'.MutMsg s)) ((Payload (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Call'params


get_Call'sendResultsTo :: U'.ReadCtx m msg => Call msg -> m (Call'sendResultsTo msg)
get_Call'sendResultsTo (Call struct) = C'.fromStruct struct
instance U'.ReadCtx m msg => IsLabel "sendResultsTo" (DC'.Get m (Call msg) ((Call'sendResultsTo msg))) where
    fromLabel = DC'.Get get_Call'sendResultsTo

has_Call'sendResultsTo :: U'.ReadCtx m msg => Call msg -> m Bool
has_Call'sendResultsTo(Call struct) = pure True
instance U'.ReadCtx m msg => IsLabel "sendResultsTo" (DC'.Has m (Call msg)) where
    fromLabel = DC'.Has has_Call'sendResultsTo

set_Call'sendResultsTo :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Call (M'.MutMsg s) -> (Call'sendResultsTo (M'.MutMsg s)) -> m ()
set_Call'sendResultsTo _ = error "TODO: generate more setters."
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "sendResultsTo" (DC'.Set m (Call (M'.MutMsg s)) ((Call'sendResultsTo (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Call'sendResultsTo


get_Call'allowThirdPartyTailCall :: U'.ReadCtx m msg => Call msg -> m Bool
get_Call'allowThirdPartyTailCall (Call struct) = C'.getWordField struct 2 0 0
instance U'.ReadCtx m msg => IsLabel "allowThirdPartyTailCall" (DC'.Get m (Call msg) (Bool)) where
    fromLabel = DC'.Get get_Call'allowThirdPartyTailCall

has_Call'allowThirdPartyTailCall :: U'.ReadCtx m msg => Call msg -> m Bool
has_Call'allowThirdPartyTailCall(Call struct) = pure $ 2 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "allowThirdPartyTailCall" (DC'.Has m (Call msg)) where
    fromLabel = DC'.Has has_Call'allowThirdPartyTailCall

set_Call'allowThirdPartyTailCall :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Call (M'.MutMsg s) -> Bool -> m ()
set_Call'allowThirdPartyTailCall (Call struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word1) 2 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "allowThirdPartyTailCall" (DC'.Set m (Call (M'.MutMsg s)) (Bool)) where
    fromLabel = DC'.Set set_Call'allowThirdPartyTailCall


data CapDescriptor msg
    = CapDescriptor'none
    | CapDescriptor'senderHosted Word32
    | CapDescriptor'senderPromise Word32
    | CapDescriptor'receiverHosted Word32
    | CapDescriptor'receiverAnswer (PromisedAnswer msg)
    | CapDescriptor'thirdPartyHosted (ThirdPartyCapDescriptor msg)
    | CapDescriptor'unknown' Word16







instance C'.IsStruct msg (CapDescriptor msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 0 0 0
        case tag of
            5 -> CapDescriptor'thirdPartyHosted <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            4 -> CapDescriptor'receiverAnswer <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            3 -> CapDescriptor'receiverHosted <$>  C'.getWordField struct 0 32 0
            2 -> CapDescriptor'senderPromise <$>  C'.getWordField struct 0 32 0
            1 -> CapDescriptor'senderHosted <$>  C'.getWordField struct 0 32 0
            0 -> pure CapDescriptor'none
            _ -> pure $ CapDescriptor'unknown' tag
instance B'.ListElem msg (CapDescriptor msg) where
    newtype List msg (CapDescriptor msg) = List_CapDescriptor (U'.ListOf msg (U'.Struct msg))
    length (List_CapDescriptor l) = U'.length l
    index i (List_CapDescriptor l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (CapDescriptor msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (CapDescriptor msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (CapDescriptor msg); go = C'.fromStruct} in go)

    toPtr = error "TODO: toPtr for non-newtype structs."

instance C'.IsPtr msg (B'.List msg (CapDescriptor msg)) where
    fromPtr msg ptr = List_CapDescriptor <$> C'.fromPtr msg ptr
    toPtr (List_CapDescriptor l) = C'.toPtr l

data Message msg
    = Message'unimplemented (Message msg)
    | Message'abort (Exception msg)
    | Message'call (Call msg)
    | Message'return (Return msg)
    | Message'finish (Finish msg)
    | Message'resolve (Resolve msg)
    | Message'release (Release msg)
    | Message'obsoleteSave (Maybe (U'.Ptr msg))
    | Message'bootstrap (Bootstrap msg)
    | Message'obsoleteDelete (Maybe (U'.Ptr msg))
    | Message'provide (Provide msg)
    | Message'accept (Accept msg)
    | Message'join (Join msg)
    | Message'disembargo (Disembargo msg)
    | Message'unknown' Word16















instance C'.IsStruct msg (Message msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 0 0 0
        case tag of
            13 -> Message'disembargo <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            12 -> Message'join <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            11 -> Message'accept <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            10 -> Message'provide <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            9 -> Message'obsoleteDelete <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            8 -> Message'bootstrap <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            7 -> Message'obsoleteSave <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            6 -> Message'release <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            5 -> Message'resolve <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            4 -> Message'finish <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            3 -> Message'return <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            2 -> Message'call <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            1 -> Message'abort <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            0 -> Message'unimplemented <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            _ -> pure $ Message'unknown' tag
instance B'.ListElem msg (Message msg) where
    newtype List msg (Message msg) = List_Message (U'.ListOf msg (U'.Struct msg))
    length (List_Message l) = U'.length l
    index i (List_Message l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Message msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (Message msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Message msg); go = C'.fromStruct} in go)

    toPtr = error "TODO: toPtr for non-newtype structs."

instance C'.IsPtr msg (B'.List msg (Message msg)) where
    fromPtr msg ptr = List_Message <$> C'.fromPtr msg ptr
    toPtr (List_Message l) = C'.toPtr l

data MessageTarget msg
    = MessageTarget'importedCap Word32
    | MessageTarget'promisedAnswer (PromisedAnswer msg)
    | MessageTarget'unknown' Word16



instance C'.IsStruct msg (MessageTarget msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 0 32 0
        case tag of
            1 -> MessageTarget'promisedAnswer <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            0 -> MessageTarget'importedCap <$>  C'.getWordField struct 0 0 0
            _ -> pure $ MessageTarget'unknown' tag
instance B'.ListElem msg (MessageTarget msg) where
    newtype List msg (MessageTarget msg) = List_MessageTarget (U'.ListOf msg (U'.Struct msg))
    length (List_MessageTarget l) = U'.length l
    index i (List_MessageTarget l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (MessageTarget msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (MessageTarget msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (MessageTarget msg); go = C'.fromStruct} in go)

    toPtr = error "TODO: toPtr for non-newtype structs."

instance C'.IsPtr msg (B'.List msg (MessageTarget msg)) where
    fromPtr msg ptr = List_MessageTarget <$> C'.fromPtr msg ptr
    toPtr (List_MessageTarget l) = C'.toPtr l

newtype Payload msg = Payload (U'.Struct msg)

instance C'.IsStruct msg (Payload msg) where
    fromStruct = pure . Payload
instance C'.IsPtr msg (Payload msg) where
    fromPtr msg ptr = Payload <$> C'.fromPtr msg ptr
    toPtr (Payload struct) = C'.toPtr struct
instance B'.ListElem msg (Payload msg) where
    newtype List msg (Payload msg) = List_Payload (U'.ListOf msg (U'.Struct msg))
    length (List_Payload l) = U'.length l
    index i (List_Payload l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Payload msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Payload (M'.MutMsg s)) where
    setIndex (Payload elt) i (List_Payload l) = U'.setIndex elt i l
    allocList msg len = List_Payload <$> U'.allocCompositeList msg 0 2 len

-- | Allocate a new 'Payload' inside the message.
new_Payload :: M'.WriteCtx m s => M'.MutMsg s -> m (Payload (M'.MutMsg s))
new_Payload msg = Payload <$> U'.allocStruct msg 0 2
instance C'.IsPtr msg (B'.List msg (Payload msg)) where
    fromPtr msg ptr = List_Payload <$> C'.fromPtr msg ptr
    toPtr (List_Payload l) = C'.toPtr l
get_Payload'content :: U'.ReadCtx m msg => Payload msg -> m (Maybe (U'.Ptr msg))
get_Payload'content (Payload struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "content" (DC'.Get m (Payload msg) ((Maybe (U'.Ptr msg)))) where
    fromLabel = DC'.Get get_Payload'content

has_Payload'content :: U'.ReadCtx m msg => Payload msg -> m Bool
has_Payload'content(Payload struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "content" (DC'.Has m (Payload msg)) where
    fromLabel = DC'.Has has_Payload'content

set_Payload'content :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Payload (M'.MutMsg s) -> (Maybe (U'.Ptr (M'.MutMsg s))) -> m ()
set_Payload'content (Payload struct) value = U'.setPtr (C'.toPtr value) 0 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "content" (DC'.Set m (Payload (M'.MutMsg s)) ((Maybe (U'.Ptr (M'.MutMsg s))))) where
    fromLabel = DC'.Set set_Payload'content


get_Payload'capTable :: U'.ReadCtx m msg => Payload msg -> m (B'.List msg (CapDescriptor msg))
get_Payload'capTable (Payload struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "capTable" (DC'.Get m (Payload msg) ((B'.List msg (CapDescriptor msg)))) where
    fromLabel = DC'.Get get_Payload'capTable

has_Payload'capTable :: U'.ReadCtx m msg => Payload msg -> m Bool
has_Payload'capTable(Payload struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
instance U'.ReadCtx m msg => IsLabel "capTable" (DC'.Has m (Payload msg)) where
    fromLabel = DC'.Has has_Payload'capTable

set_Payload'capTable :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Payload (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (CapDescriptor (M'.MutMsg s))) -> m ()
set_Payload'capTable (Payload struct) value = U'.setPtr (C'.toPtr value) 1 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "capTable" (DC'.Set m (Payload (M'.MutMsg s)) ((B'.List (M'.MutMsg s) (CapDescriptor (M'.MutMsg s))))) where
    fromLabel = DC'.Set set_Payload'capTable


newtype Provide msg = Provide (U'.Struct msg)

instance C'.IsStruct msg (Provide msg) where
    fromStruct = pure . Provide
instance C'.IsPtr msg (Provide msg) where
    fromPtr msg ptr = Provide <$> C'.fromPtr msg ptr
    toPtr (Provide struct) = C'.toPtr struct
instance B'.ListElem msg (Provide msg) where
    newtype List msg (Provide msg) = List_Provide (U'.ListOf msg (U'.Struct msg))
    length (List_Provide l) = U'.length l
    index i (List_Provide l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Provide msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Provide (M'.MutMsg s)) where
    setIndex (Provide elt) i (List_Provide l) = U'.setIndex elt i l
    allocList msg len = List_Provide <$> U'.allocCompositeList msg 1 2 len

-- | Allocate a new 'Provide' inside the message.
new_Provide :: M'.WriteCtx m s => M'.MutMsg s -> m (Provide (M'.MutMsg s))
new_Provide msg = Provide <$> U'.allocStruct msg 1 2
instance C'.IsPtr msg (B'.List msg (Provide msg)) where
    fromPtr msg ptr = List_Provide <$> C'.fromPtr msg ptr
    toPtr (List_Provide l) = C'.toPtr l
get_Provide'questionId :: U'.ReadCtx m msg => Provide msg -> m Word32
get_Provide'questionId (Provide struct) = C'.getWordField struct 0 0 0
instance U'.ReadCtx m msg => IsLabel "questionId" (DC'.Get m (Provide msg) (Word32)) where
    fromLabel = DC'.Get get_Provide'questionId

has_Provide'questionId :: U'.ReadCtx m msg => Provide msg -> m Bool
has_Provide'questionId(Provide struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "questionId" (DC'.Has m (Provide msg)) where
    fromLabel = DC'.Has has_Provide'questionId

set_Provide'questionId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Provide (M'.MutMsg s) -> Word32 -> m ()
set_Provide'questionId (Provide struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "questionId" (DC'.Set m (Provide (M'.MutMsg s)) (Word32)) where
    fromLabel = DC'.Set set_Provide'questionId


get_Provide'target :: U'.ReadCtx m msg => Provide msg -> m (MessageTarget msg)
get_Provide'target (Provide struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "target" (DC'.Get m (Provide msg) ((MessageTarget msg))) where
    fromLabel = DC'.Get get_Provide'target

has_Provide'target :: U'.ReadCtx m msg => Provide msg -> m Bool
has_Provide'target(Provide struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "target" (DC'.Has m (Provide msg)) where
    fromLabel = DC'.Has has_Provide'target

set_Provide'target :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Provide (M'.MutMsg s) -> (MessageTarget (M'.MutMsg s)) -> m ()
set_Provide'target (Provide struct) value = U'.setPtr (C'.toPtr value) 0 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "target" (DC'.Set m (Provide (M'.MutMsg s)) ((MessageTarget (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Provide'target


get_Provide'recipient :: U'.ReadCtx m msg => Provide msg -> m (Maybe (U'.Ptr msg))
get_Provide'recipient (Provide struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "recipient" (DC'.Get m (Provide msg) ((Maybe (U'.Ptr msg)))) where
    fromLabel = DC'.Get get_Provide'recipient

has_Provide'recipient :: U'.ReadCtx m msg => Provide msg -> m Bool
has_Provide'recipient(Provide struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
instance U'.ReadCtx m msg => IsLabel "recipient" (DC'.Has m (Provide msg)) where
    fromLabel = DC'.Has has_Provide'recipient

set_Provide'recipient :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Provide (M'.MutMsg s) -> (Maybe (U'.Ptr (M'.MutMsg s))) -> m ()
set_Provide'recipient (Provide struct) value = U'.setPtr (C'.toPtr value) 1 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "recipient" (DC'.Set m (Provide (M'.MutMsg s)) ((Maybe (U'.Ptr (M'.MutMsg s))))) where
    fromLabel = DC'.Set set_Provide'recipient


newtype Return msg = Return (U'.Struct msg)

instance C'.IsStruct msg (Return msg) where
    fromStruct = pure . Return
instance C'.IsPtr msg (Return msg) where
    fromPtr msg ptr = Return <$> C'.fromPtr msg ptr
    toPtr (Return struct) = C'.toPtr struct
instance B'.ListElem msg (Return msg) where
    newtype List msg (Return msg) = List_Return (U'.ListOf msg (U'.Struct msg))
    length (List_Return l) = U'.length l
    index i (List_Return l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Return msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Return (M'.MutMsg s)) where
    setIndex (Return elt) i (List_Return l) = U'.setIndex elt i l
    allocList msg len = List_Return <$> U'.allocCompositeList msg 2 1 len

-- | Allocate a new 'Return' inside the message.
new_Return :: M'.WriteCtx m s => M'.MutMsg s -> m (Return (M'.MutMsg s))
new_Return msg = Return <$> U'.allocStruct msg 2 1
instance C'.IsPtr msg (B'.List msg (Return msg)) where
    fromPtr msg ptr = List_Return <$> C'.fromPtr msg ptr
    toPtr (List_Return l) = C'.toPtr l
get_Return'answerId :: U'.ReadCtx m msg => Return msg -> m Word32
get_Return'answerId (Return struct) = C'.getWordField struct 0 0 0
instance U'.ReadCtx m msg => IsLabel "answerId" (DC'.Get m (Return msg) (Word32)) where
    fromLabel = DC'.Get get_Return'answerId

has_Return'answerId :: U'.ReadCtx m msg => Return msg -> m Bool
has_Return'answerId(Return struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "answerId" (DC'.Has m (Return msg)) where
    fromLabel = DC'.Has has_Return'answerId

set_Return'answerId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Return (M'.MutMsg s) -> Word32 -> m ()
set_Return'answerId (Return struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "answerId" (DC'.Set m (Return (M'.MutMsg s)) (Word32)) where
    fromLabel = DC'.Set set_Return'answerId


get_Return'releaseParamCaps :: U'.ReadCtx m msg => Return msg -> m Bool
get_Return'releaseParamCaps (Return struct) = C'.getWordField struct 0 32 1
instance U'.ReadCtx m msg => IsLabel "releaseParamCaps" (DC'.Get m (Return msg) (Bool)) where
    fromLabel = DC'.Get get_Return'releaseParamCaps

has_Return'releaseParamCaps :: U'.ReadCtx m msg => Return msg -> m Bool
has_Return'releaseParamCaps(Return struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "releaseParamCaps" (DC'.Has m (Return msg)) where
    fromLabel = DC'.Has has_Return'releaseParamCaps

set_Return'releaseParamCaps :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Return (M'.MutMsg s) -> Bool -> m ()
set_Return'releaseParamCaps (Return struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word1) 0 32 1
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "releaseParamCaps" (DC'.Set m (Return (M'.MutMsg s)) (Bool)) where
    fromLabel = DC'.Set set_Return'releaseParamCaps


get_Return'union' :: U'.ReadCtx m msg => Return msg -> m (Return' msg)
get_Return'union' (Return struct) = C'.fromStruct struct
instance U'.ReadCtx m msg => IsLabel "union'" (DC'.Get m (Return msg) ((Return' msg))) where
    fromLabel = DC'.Get get_Return'union'

has_Return'union' :: U'.ReadCtx m msg => Return msg -> m Bool
has_Return'union'(Return struct) = pure True
instance U'.ReadCtx m msg => IsLabel "union'" (DC'.Has m (Return msg)) where
    fromLabel = DC'.Has has_Return'union'

set_Return'union' :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Return (M'.MutMsg s) -> (Return' (M'.MutMsg s)) -> m ()
set_Return'union' _ = error "TODO: generate more setters."
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "union'" (DC'.Set m (Return (M'.MutMsg s)) ((Return' (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Return'union'


data Return' msg
    = Return'results (Payload msg)
    | Return'exception (Exception msg)
    | Return'canceled
    | Return'resultsSentElsewhere
    | Return'takeFromOtherQuestion Word32
    | Return'acceptFromThirdParty (Maybe (U'.Ptr msg))
    | Return'unknown' Word16







instance C'.IsStruct msg (Return' msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 0 48 0
        case tag of
            5 -> Return'acceptFromThirdParty <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            4 -> Return'takeFromOtherQuestion <$>  C'.getWordField struct 1 0 0
            3 -> pure Return'resultsSentElsewhere
            2 -> pure Return'canceled
            1 -> Return'exception <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            0 -> Return'results <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            _ -> pure $ Return'unknown' tag
instance B'.ListElem msg (Return' msg) where
    newtype List msg (Return' msg) = List_Return' (U'.ListOf msg (U'.Struct msg))
    length (List_Return' l) = U'.length l
    index i (List_Return' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Return' msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (Return' msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Return' msg); go = C'.fromStruct} in go)

    toPtr = error "TODO: toPtr for non-newtype structs."

instance C'.IsPtr msg (B'.List msg (Return' msg)) where
    fromPtr msg ptr = List_Return' <$> C'.fromPtr msg ptr
    toPtr (List_Return' l) = C'.toPtr l

newtype Release msg = Release (U'.Struct msg)

instance C'.IsStruct msg (Release msg) where
    fromStruct = pure . Release
instance C'.IsPtr msg (Release msg) where
    fromPtr msg ptr = Release <$> C'.fromPtr msg ptr
    toPtr (Release struct) = C'.toPtr struct
instance B'.ListElem msg (Release msg) where
    newtype List msg (Release msg) = List_Release (U'.ListOf msg (U'.Struct msg))
    length (List_Release l) = U'.length l
    index i (List_Release l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Release msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Release (M'.MutMsg s)) where
    setIndex (Release elt) i (List_Release l) = U'.setIndex elt i l
    allocList msg len = List_Release <$> U'.allocCompositeList msg 1 0 len

-- | Allocate a new 'Release' inside the message.
new_Release :: M'.WriteCtx m s => M'.MutMsg s -> m (Release (M'.MutMsg s))
new_Release msg = Release <$> U'.allocStruct msg 1 0
instance C'.IsPtr msg (B'.List msg (Release msg)) where
    fromPtr msg ptr = List_Release <$> C'.fromPtr msg ptr
    toPtr (List_Release l) = C'.toPtr l
get_Release'id :: U'.ReadCtx m msg => Release msg -> m Word32
get_Release'id (Release struct) = C'.getWordField struct 0 0 0
instance U'.ReadCtx m msg => IsLabel "id" (DC'.Get m (Release msg) (Word32)) where
    fromLabel = DC'.Get get_Release'id

has_Release'id :: U'.ReadCtx m msg => Release msg -> m Bool
has_Release'id(Release struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "id" (DC'.Has m (Release msg)) where
    fromLabel = DC'.Has has_Release'id

set_Release'id :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Release (M'.MutMsg s) -> Word32 -> m ()
set_Release'id (Release struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "id" (DC'.Set m (Release (M'.MutMsg s)) (Word32)) where
    fromLabel = DC'.Set set_Release'id


get_Release'referenceCount :: U'.ReadCtx m msg => Release msg -> m Word32
get_Release'referenceCount (Release struct) = C'.getWordField struct 0 32 0
instance U'.ReadCtx m msg => IsLabel "referenceCount" (DC'.Get m (Release msg) (Word32)) where
    fromLabel = DC'.Get get_Release'referenceCount

has_Release'referenceCount :: U'.ReadCtx m msg => Release msg -> m Bool
has_Release'referenceCount(Release struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "referenceCount" (DC'.Has m (Release msg)) where
    fromLabel = DC'.Has has_Release'referenceCount

set_Release'referenceCount :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Release (M'.MutMsg s) -> Word32 -> m ()
set_Release'referenceCount (Release struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 32 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "referenceCount" (DC'.Set m (Release (M'.MutMsg s)) (Word32)) where
    fromLabel = DC'.Set set_Release'referenceCount


data Exception'Type
    = Exception'Type'failed
    | Exception'Type'overloaded
    | Exception'Type'disconnected
    | Exception'Type'unimplemented
    | Exception'Type'unknown' Word16
instance Enum Exception'Type where
    toEnum = C'.fromWord . fromIntegral
    fromEnum = fromIntegral . C'.toWord


instance C'.IsWord Exception'Type where
    fromWord n = go (fromIntegral n :: Word16)
      where
        go 3 = Exception'Type'unimplemented
        go 2 = Exception'Type'disconnected
        go 1 = Exception'Type'overloaded
        go 0 = Exception'Type'failed
        go tag = Exception'Type'unknown' (fromIntegral tag)
    toWord Exception'Type'unimplemented = 3
    toWord Exception'Type'disconnected = 2
    toWord Exception'Type'overloaded = 1
    toWord Exception'Type'failed = 0
    toWord (Exception'Type'unknown' tag) = fromIntegral tag
instance B'.ListElem msg Exception'Type where
    newtype List msg Exception'Type = List_Exception'Type (U'.ListOf msg Word16)
    length (List_Exception'Type l) = U'.length l
    index i (List_Exception'Type l) = (C'.fromWord . fromIntegral) <$> U'.index i l
instance B'.MutListElem s Exception'Type where
    setIndex elt i (List_Exception'Type l) = error "TODO: generate code for setIndex"
    allocList msg size = List_Exception'Type <$> U'.allocList16 msg size
instance C'.IsPtr msg (B'.List msg Exception'Type) where
    fromPtr msg ptr = List_Exception'Type <$> C'.fromPtr msg ptr
    toPtr (List_Exception'Type l) = C'.toPtr l

newtype Resolve msg = Resolve (U'.Struct msg)

instance C'.IsStruct msg (Resolve msg) where
    fromStruct = pure . Resolve
instance C'.IsPtr msg (Resolve msg) where
    fromPtr msg ptr = Resolve <$> C'.fromPtr msg ptr
    toPtr (Resolve struct) = C'.toPtr struct
instance B'.ListElem msg (Resolve msg) where
    newtype List msg (Resolve msg) = List_Resolve (U'.ListOf msg (U'.Struct msg))
    length (List_Resolve l) = U'.length l
    index i (List_Resolve l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Resolve msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Resolve (M'.MutMsg s)) where
    setIndex (Resolve elt) i (List_Resolve l) = U'.setIndex elt i l
    allocList msg len = List_Resolve <$> U'.allocCompositeList msg 1 1 len

-- | Allocate a new 'Resolve' inside the message.
new_Resolve :: M'.WriteCtx m s => M'.MutMsg s -> m (Resolve (M'.MutMsg s))
new_Resolve msg = Resolve <$> U'.allocStruct msg 1 1
instance C'.IsPtr msg (B'.List msg (Resolve msg)) where
    fromPtr msg ptr = List_Resolve <$> C'.fromPtr msg ptr
    toPtr (List_Resolve l) = C'.toPtr l
get_Resolve'promiseId :: U'.ReadCtx m msg => Resolve msg -> m Word32
get_Resolve'promiseId (Resolve struct) = C'.getWordField struct 0 0 0
instance U'.ReadCtx m msg => IsLabel "promiseId" (DC'.Get m (Resolve msg) (Word32)) where
    fromLabel = DC'.Get get_Resolve'promiseId

has_Resolve'promiseId :: U'.ReadCtx m msg => Resolve msg -> m Bool
has_Resolve'promiseId(Resolve struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "promiseId" (DC'.Has m (Resolve msg)) where
    fromLabel = DC'.Has has_Resolve'promiseId

set_Resolve'promiseId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Resolve (M'.MutMsg s) -> Word32 -> m ()
set_Resolve'promiseId (Resolve struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "promiseId" (DC'.Set m (Resolve (M'.MutMsg s)) (Word32)) where
    fromLabel = DC'.Set set_Resolve'promiseId


get_Resolve'union' :: U'.ReadCtx m msg => Resolve msg -> m (Resolve' msg)
get_Resolve'union' (Resolve struct) = C'.fromStruct struct
instance U'.ReadCtx m msg => IsLabel "union'" (DC'.Get m (Resolve msg) ((Resolve' msg))) where
    fromLabel = DC'.Get get_Resolve'union'

has_Resolve'union' :: U'.ReadCtx m msg => Resolve msg -> m Bool
has_Resolve'union'(Resolve struct) = pure True
instance U'.ReadCtx m msg => IsLabel "union'" (DC'.Has m (Resolve msg)) where
    fromLabel = DC'.Has has_Resolve'union'

set_Resolve'union' :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Resolve (M'.MutMsg s) -> (Resolve' (M'.MutMsg s)) -> m ()
set_Resolve'union' _ = error "TODO: generate more setters."
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "union'" (DC'.Set m (Resolve (M'.MutMsg s)) ((Resolve' (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Resolve'union'


data Resolve' msg
    = Resolve'cap (CapDescriptor msg)
    | Resolve'exception (Exception msg)
    | Resolve'unknown' Word16



instance C'.IsStruct msg (Resolve' msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 0 32 0
        case tag of
            1 -> Resolve'exception <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            0 -> Resolve'cap <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            _ -> pure $ Resolve'unknown' tag
instance B'.ListElem msg (Resolve' msg) where
    newtype List msg (Resolve' msg) = List_Resolve' (U'.ListOf msg (U'.Struct msg))
    length (List_Resolve' l) = U'.length l
    index i (List_Resolve' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Resolve' msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (Resolve' msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Resolve' msg); go = C'.fromStruct} in go)

    toPtr = error "TODO: toPtr for non-newtype structs."

instance C'.IsPtr msg (B'.List msg (Resolve' msg)) where
    fromPtr msg ptr = List_Resolve' <$> C'.fromPtr msg ptr
    toPtr (List_Resolve' l) = C'.toPtr l

newtype ThirdPartyCapDescriptor msg = ThirdPartyCapDescriptor (U'.Struct msg)

instance C'.IsStruct msg (ThirdPartyCapDescriptor msg) where
    fromStruct = pure . ThirdPartyCapDescriptor
instance C'.IsPtr msg (ThirdPartyCapDescriptor msg) where
    fromPtr msg ptr = ThirdPartyCapDescriptor <$> C'.fromPtr msg ptr
    toPtr (ThirdPartyCapDescriptor struct) = C'.toPtr struct
instance B'.ListElem msg (ThirdPartyCapDescriptor msg) where
    newtype List msg (ThirdPartyCapDescriptor msg) = List_ThirdPartyCapDescriptor (U'.ListOf msg (U'.Struct msg))
    length (List_ThirdPartyCapDescriptor l) = U'.length l
    index i (List_ThirdPartyCapDescriptor l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (ThirdPartyCapDescriptor msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (ThirdPartyCapDescriptor (M'.MutMsg s)) where
    setIndex (ThirdPartyCapDescriptor elt) i (List_ThirdPartyCapDescriptor l) = U'.setIndex elt i l
    allocList msg len = List_ThirdPartyCapDescriptor <$> U'.allocCompositeList msg 1 1 len

-- | Allocate a new 'ThirdPartyCapDescriptor' inside the message.
new_ThirdPartyCapDescriptor :: M'.WriteCtx m s => M'.MutMsg s -> m (ThirdPartyCapDescriptor (M'.MutMsg s))
new_ThirdPartyCapDescriptor msg = ThirdPartyCapDescriptor <$> U'.allocStruct msg 1 1
instance C'.IsPtr msg (B'.List msg (ThirdPartyCapDescriptor msg)) where
    fromPtr msg ptr = List_ThirdPartyCapDescriptor <$> C'.fromPtr msg ptr
    toPtr (List_ThirdPartyCapDescriptor l) = C'.toPtr l
get_ThirdPartyCapDescriptor'id :: U'.ReadCtx m msg => ThirdPartyCapDescriptor msg -> m (Maybe (U'.Ptr msg))
get_ThirdPartyCapDescriptor'id (ThirdPartyCapDescriptor struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "id" (DC'.Get m (ThirdPartyCapDescriptor msg) ((Maybe (U'.Ptr msg)))) where
    fromLabel = DC'.Get get_ThirdPartyCapDescriptor'id

has_ThirdPartyCapDescriptor'id :: U'.ReadCtx m msg => ThirdPartyCapDescriptor msg -> m Bool
has_ThirdPartyCapDescriptor'id(ThirdPartyCapDescriptor struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "id" (DC'.Has m (ThirdPartyCapDescriptor msg)) where
    fromLabel = DC'.Has has_ThirdPartyCapDescriptor'id

set_ThirdPartyCapDescriptor'id :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => ThirdPartyCapDescriptor (M'.MutMsg s) -> (Maybe (U'.Ptr (M'.MutMsg s))) -> m ()
set_ThirdPartyCapDescriptor'id (ThirdPartyCapDescriptor struct) value = U'.setPtr (C'.toPtr value) 0 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "id" (DC'.Set m (ThirdPartyCapDescriptor (M'.MutMsg s)) ((Maybe (U'.Ptr (M'.MutMsg s))))) where
    fromLabel = DC'.Set set_ThirdPartyCapDescriptor'id


get_ThirdPartyCapDescriptor'vineId :: U'.ReadCtx m msg => ThirdPartyCapDescriptor msg -> m Word32
get_ThirdPartyCapDescriptor'vineId (ThirdPartyCapDescriptor struct) = C'.getWordField struct 0 0 0
instance U'.ReadCtx m msg => IsLabel "vineId" (DC'.Get m (ThirdPartyCapDescriptor msg) (Word32)) where
    fromLabel = DC'.Get get_ThirdPartyCapDescriptor'vineId

has_ThirdPartyCapDescriptor'vineId :: U'.ReadCtx m msg => ThirdPartyCapDescriptor msg -> m Bool
has_ThirdPartyCapDescriptor'vineId(ThirdPartyCapDescriptor struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "vineId" (DC'.Has m (ThirdPartyCapDescriptor msg)) where
    fromLabel = DC'.Has has_ThirdPartyCapDescriptor'vineId

set_ThirdPartyCapDescriptor'vineId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => ThirdPartyCapDescriptor (M'.MutMsg s) -> Word32 -> m ()
set_ThirdPartyCapDescriptor'vineId (ThirdPartyCapDescriptor struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "vineId" (DC'.Set m (ThirdPartyCapDescriptor (M'.MutMsg s)) (Word32)) where
    fromLabel = DC'.Set set_ThirdPartyCapDescriptor'vineId


newtype Finish msg = Finish (U'.Struct msg)

instance C'.IsStruct msg (Finish msg) where
    fromStruct = pure . Finish
instance C'.IsPtr msg (Finish msg) where
    fromPtr msg ptr = Finish <$> C'.fromPtr msg ptr
    toPtr (Finish struct) = C'.toPtr struct
instance B'.ListElem msg (Finish msg) where
    newtype List msg (Finish msg) = List_Finish (U'.ListOf msg (U'.Struct msg))
    length (List_Finish l) = U'.length l
    index i (List_Finish l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Finish msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Finish (M'.MutMsg s)) where
    setIndex (Finish elt) i (List_Finish l) = U'.setIndex elt i l
    allocList msg len = List_Finish <$> U'.allocCompositeList msg 1 0 len

-- | Allocate a new 'Finish' inside the message.
new_Finish :: M'.WriteCtx m s => M'.MutMsg s -> m (Finish (M'.MutMsg s))
new_Finish msg = Finish <$> U'.allocStruct msg 1 0
instance C'.IsPtr msg (B'.List msg (Finish msg)) where
    fromPtr msg ptr = List_Finish <$> C'.fromPtr msg ptr
    toPtr (List_Finish l) = C'.toPtr l
get_Finish'questionId :: U'.ReadCtx m msg => Finish msg -> m Word32
get_Finish'questionId (Finish struct) = C'.getWordField struct 0 0 0
instance U'.ReadCtx m msg => IsLabel "questionId" (DC'.Get m (Finish msg) (Word32)) where
    fromLabel = DC'.Get get_Finish'questionId

has_Finish'questionId :: U'.ReadCtx m msg => Finish msg -> m Bool
has_Finish'questionId(Finish struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "questionId" (DC'.Has m (Finish msg)) where
    fromLabel = DC'.Has has_Finish'questionId

set_Finish'questionId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Finish (M'.MutMsg s) -> Word32 -> m ()
set_Finish'questionId (Finish struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "questionId" (DC'.Set m (Finish (M'.MutMsg s)) (Word32)) where
    fromLabel = DC'.Set set_Finish'questionId


get_Finish'releaseResultCaps :: U'.ReadCtx m msg => Finish msg -> m Bool
get_Finish'releaseResultCaps (Finish struct) = C'.getWordField struct 0 32 1
instance U'.ReadCtx m msg => IsLabel "releaseResultCaps" (DC'.Get m (Finish msg) (Bool)) where
    fromLabel = DC'.Get get_Finish'releaseResultCaps

has_Finish'releaseResultCaps :: U'.ReadCtx m msg => Finish msg -> m Bool
has_Finish'releaseResultCaps(Finish struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "releaseResultCaps" (DC'.Has m (Finish msg)) where
    fromLabel = DC'.Has has_Finish'releaseResultCaps

set_Finish'releaseResultCaps :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Finish (M'.MutMsg s) -> Bool -> m ()
set_Finish'releaseResultCaps (Finish struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word1) 0 32 1
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "releaseResultCaps" (DC'.Set m (Finish (M'.MutMsg s)) (Bool)) where
    fromLabel = DC'.Set set_Finish'releaseResultCaps


newtype Accept msg = Accept (U'.Struct msg)

instance C'.IsStruct msg (Accept msg) where
    fromStruct = pure . Accept
instance C'.IsPtr msg (Accept msg) where
    fromPtr msg ptr = Accept <$> C'.fromPtr msg ptr
    toPtr (Accept struct) = C'.toPtr struct
instance B'.ListElem msg (Accept msg) where
    newtype List msg (Accept msg) = List_Accept (U'.ListOf msg (U'.Struct msg))
    length (List_Accept l) = U'.length l
    index i (List_Accept l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Accept msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Accept (M'.MutMsg s)) where
    setIndex (Accept elt) i (List_Accept l) = U'.setIndex elt i l
    allocList msg len = List_Accept <$> U'.allocCompositeList msg 1 1 len

-- | Allocate a new 'Accept' inside the message.
new_Accept :: M'.WriteCtx m s => M'.MutMsg s -> m (Accept (M'.MutMsg s))
new_Accept msg = Accept <$> U'.allocStruct msg 1 1
instance C'.IsPtr msg (B'.List msg (Accept msg)) where
    fromPtr msg ptr = List_Accept <$> C'.fromPtr msg ptr
    toPtr (List_Accept l) = C'.toPtr l
get_Accept'questionId :: U'.ReadCtx m msg => Accept msg -> m Word32
get_Accept'questionId (Accept struct) = C'.getWordField struct 0 0 0
instance U'.ReadCtx m msg => IsLabel "questionId" (DC'.Get m (Accept msg) (Word32)) where
    fromLabel = DC'.Get get_Accept'questionId

has_Accept'questionId :: U'.ReadCtx m msg => Accept msg -> m Bool
has_Accept'questionId(Accept struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "questionId" (DC'.Has m (Accept msg)) where
    fromLabel = DC'.Has has_Accept'questionId

set_Accept'questionId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Accept (M'.MutMsg s) -> Word32 -> m ()
set_Accept'questionId (Accept struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "questionId" (DC'.Set m (Accept (M'.MutMsg s)) (Word32)) where
    fromLabel = DC'.Set set_Accept'questionId


get_Accept'provision :: U'.ReadCtx m msg => Accept msg -> m (Maybe (U'.Ptr msg))
get_Accept'provision (Accept struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "provision" (DC'.Get m (Accept msg) ((Maybe (U'.Ptr msg)))) where
    fromLabel = DC'.Get get_Accept'provision

has_Accept'provision :: U'.ReadCtx m msg => Accept msg -> m Bool
has_Accept'provision(Accept struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "provision" (DC'.Has m (Accept msg)) where
    fromLabel = DC'.Has has_Accept'provision

set_Accept'provision :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Accept (M'.MutMsg s) -> (Maybe (U'.Ptr (M'.MutMsg s))) -> m ()
set_Accept'provision (Accept struct) value = U'.setPtr (C'.toPtr value) 0 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "provision" (DC'.Set m (Accept (M'.MutMsg s)) ((Maybe (U'.Ptr (M'.MutMsg s))))) where
    fromLabel = DC'.Set set_Accept'provision


get_Accept'embargo :: U'.ReadCtx m msg => Accept msg -> m Bool
get_Accept'embargo (Accept struct) = C'.getWordField struct 0 32 0
instance U'.ReadCtx m msg => IsLabel "embargo" (DC'.Get m (Accept msg) (Bool)) where
    fromLabel = DC'.Get get_Accept'embargo

has_Accept'embargo :: U'.ReadCtx m msg => Accept msg -> m Bool
has_Accept'embargo(Accept struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "embargo" (DC'.Has m (Accept msg)) where
    fromLabel = DC'.Has has_Accept'embargo

set_Accept'embargo :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Accept (M'.MutMsg s) -> Bool -> m ()
set_Accept'embargo (Accept struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word1) 0 32 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "embargo" (DC'.Set m (Accept (M'.MutMsg s)) (Bool)) where
    fromLabel = DC'.Set set_Accept'embargo


data Disembargo'context msg
    = Disembargo'context'senderLoopback Word32
    | Disembargo'context'receiverLoopback Word32
    | Disembargo'context'accept
    | Disembargo'context'provide Word32
    | Disembargo'context'unknown' Word16





instance C'.IsStruct msg (Disembargo'context msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 0 32 0
        case tag of
            3 -> Disembargo'context'provide <$>  C'.getWordField struct 0 0 0
            2 -> pure Disembargo'context'accept
            1 -> Disembargo'context'receiverLoopback <$>  C'.getWordField struct 0 0 0
            0 -> Disembargo'context'senderLoopback <$>  C'.getWordField struct 0 0 0
            _ -> pure $ Disembargo'context'unknown' tag
instance B'.ListElem msg (Disembargo'context msg) where
    newtype List msg (Disembargo'context msg) = List_Disembargo'context (U'.ListOf msg (U'.Struct msg))
    length (List_Disembargo'context l) = U'.length l
    index i (List_Disembargo'context l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Disembargo'context msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (Disembargo'context msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Disembargo'context msg); go = C'.fromStruct} in go)

    toPtr = error "TODO: toPtr for non-newtype structs."

instance C'.IsPtr msg (B'.List msg (Disembargo'context msg)) where
    fromPtr msg ptr = List_Disembargo'context <$> C'.fromPtr msg ptr
    toPtr (List_Disembargo'context l) = C'.toPtr l

newtype Exception msg = Exception (U'.Struct msg)

instance C'.IsStruct msg (Exception msg) where
    fromStruct = pure . Exception
instance C'.IsPtr msg (Exception msg) where
    fromPtr msg ptr = Exception <$> C'.fromPtr msg ptr
    toPtr (Exception struct) = C'.toPtr struct
instance B'.ListElem msg (Exception msg) where
    newtype List msg (Exception msg) = List_Exception (U'.ListOf msg (U'.Struct msg))
    length (List_Exception l) = U'.length l
    index i (List_Exception l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Exception msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Exception (M'.MutMsg s)) where
    setIndex (Exception elt) i (List_Exception l) = U'.setIndex elt i l
    allocList msg len = List_Exception <$> U'.allocCompositeList msg 1 1 len

-- | Allocate a new 'Exception' inside the message.
new_Exception :: M'.WriteCtx m s => M'.MutMsg s -> m (Exception (M'.MutMsg s))
new_Exception msg = Exception <$> U'.allocStruct msg 1 1
instance C'.IsPtr msg (B'.List msg (Exception msg)) where
    fromPtr msg ptr = List_Exception <$> C'.fromPtr msg ptr
    toPtr (List_Exception l) = C'.toPtr l
get_Exception'reason :: U'.ReadCtx m msg => Exception msg -> m (B'.Text msg)
get_Exception'reason (Exception struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "reason" (DC'.Get m (Exception msg) ((B'.Text msg))) where
    fromLabel = DC'.Get get_Exception'reason

has_Exception'reason :: U'.ReadCtx m msg => Exception msg -> m Bool
has_Exception'reason(Exception struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "reason" (DC'.Has m (Exception msg)) where
    fromLabel = DC'.Has has_Exception'reason

set_Exception'reason :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Exception (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_Exception'reason (Exception struct) value = U'.setPtr (C'.toPtr value) 0 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "reason" (DC'.Set m (Exception (M'.MutMsg s)) ((B'.Text (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Exception'reason


get_Exception'obsoleteIsCallersFault :: U'.ReadCtx m msg => Exception msg -> m Bool
get_Exception'obsoleteIsCallersFault (Exception struct) = C'.getWordField struct 0 0 0
instance U'.ReadCtx m msg => IsLabel "obsoleteIsCallersFault" (DC'.Get m (Exception msg) (Bool)) where
    fromLabel = DC'.Get get_Exception'obsoleteIsCallersFault

has_Exception'obsoleteIsCallersFault :: U'.ReadCtx m msg => Exception msg -> m Bool
has_Exception'obsoleteIsCallersFault(Exception struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "obsoleteIsCallersFault" (DC'.Has m (Exception msg)) where
    fromLabel = DC'.Has has_Exception'obsoleteIsCallersFault

set_Exception'obsoleteIsCallersFault :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Exception (M'.MutMsg s) -> Bool -> m ()
set_Exception'obsoleteIsCallersFault (Exception struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word1) 0 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "obsoleteIsCallersFault" (DC'.Set m (Exception (M'.MutMsg s)) (Bool)) where
    fromLabel = DC'.Set set_Exception'obsoleteIsCallersFault


get_Exception'obsoleteDurability :: U'.ReadCtx m msg => Exception msg -> m Word16
get_Exception'obsoleteDurability (Exception struct) = C'.getWordField struct 0 16 0
instance U'.ReadCtx m msg => IsLabel "obsoleteDurability" (DC'.Get m (Exception msg) (Word16)) where
    fromLabel = DC'.Get get_Exception'obsoleteDurability

has_Exception'obsoleteDurability :: U'.ReadCtx m msg => Exception msg -> m Bool
has_Exception'obsoleteDurability(Exception struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "obsoleteDurability" (DC'.Has m (Exception msg)) where
    fromLabel = DC'.Has has_Exception'obsoleteDurability

set_Exception'obsoleteDurability :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Exception (M'.MutMsg s) -> Word16 -> m ()
set_Exception'obsoleteDurability (Exception struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word16) 0 16 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "obsoleteDurability" (DC'.Set m (Exception (M'.MutMsg s)) (Word16)) where
    fromLabel = DC'.Set set_Exception'obsoleteDurability


get_Exception'type_ :: U'.ReadCtx m msg => Exception msg -> m Exception'Type
get_Exception'type_ (Exception struct) = C'.getWordField struct 0 32 0
instance U'.ReadCtx m msg => IsLabel "type_" (DC'.Get m (Exception msg) (Exception'Type)) where
    fromLabel = DC'.Get get_Exception'type_

has_Exception'type_ :: U'.ReadCtx m msg => Exception msg -> m Bool
has_Exception'type_(Exception struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "type_" (DC'.Has m (Exception msg)) where
    fromLabel = DC'.Has has_Exception'type_

set_Exception'type_ :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Exception (M'.MutMsg s) -> Exception'Type -> m ()
set_Exception'type_ (Exception struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word16) 0 32 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "type_" (DC'.Set m (Exception (M'.MutMsg s)) (Exception'Type)) where
    fromLabel = DC'.Set set_Exception'type_


newtype PromisedAnswer msg = PromisedAnswer (U'.Struct msg)

instance C'.IsStruct msg (PromisedAnswer msg) where
    fromStruct = pure . PromisedAnswer
instance C'.IsPtr msg (PromisedAnswer msg) where
    fromPtr msg ptr = PromisedAnswer <$> C'.fromPtr msg ptr
    toPtr (PromisedAnswer struct) = C'.toPtr struct
instance B'.ListElem msg (PromisedAnswer msg) where
    newtype List msg (PromisedAnswer msg) = List_PromisedAnswer (U'.ListOf msg (U'.Struct msg))
    length (List_PromisedAnswer l) = U'.length l
    index i (List_PromisedAnswer l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (PromisedAnswer msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (PromisedAnswer (M'.MutMsg s)) where
    setIndex (PromisedAnswer elt) i (List_PromisedAnswer l) = U'.setIndex elt i l
    allocList msg len = List_PromisedAnswer <$> U'.allocCompositeList msg 1 1 len

-- | Allocate a new 'PromisedAnswer' inside the message.
new_PromisedAnswer :: M'.WriteCtx m s => M'.MutMsg s -> m (PromisedAnswer (M'.MutMsg s))
new_PromisedAnswer msg = PromisedAnswer <$> U'.allocStruct msg 1 1
instance C'.IsPtr msg (B'.List msg (PromisedAnswer msg)) where
    fromPtr msg ptr = List_PromisedAnswer <$> C'.fromPtr msg ptr
    toPtr (List_PromisedAnswer l) = C'.toPtr l
get_PromisedAnswer'questionId :: U'.ReadCtx m msg => PromisedAnswer msg -> m Word32
get_PromisedAnswer'questionId (PromisedAnswer struct) = C'.getWordField struct 0 0 0
instance U'.ReadCtx m msg => IsLabel "questionId" (DC'.Get m (PromisedAnswer msg) (Word32)) where
    fromLabel = DC'.Get get_PromisedAnswer'questionId

has_PromisedAnswer'questionId :: U'.ReadCtx m msg => PromisedAnswer msg -> m Bool
has_PromisedAnswer'questionId(PromisedAnswer struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "questionId" (DC'.Has m (PromisedAnswer msg)) where
    fromLabel = DC'.Has has_PromisedAnswer'questionId

set_PromisedAnswer'questionId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => PromisedAnswer (M'.MutMsg s) -> Word32 -> m ()
set_PromisedAnswer'questionId (PromisedAnswer struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "questionId" (DC'.Set m (PromisedAnswer (M'.MutMsg s)) (Word32)) where
    fromLabel = DC'.Set set_PromisedAnswer'questionId


get_PromisedAnswer'transform :: U'.ReadCtx m msg => PromisedAnswer msg -> m (B'.List msg (PromisedAnswer'Op msg))
get_PromisedAnswer'transform (PromisedAnswer struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "transform" (DC'.Get m (PromisedAnswer msg) ((B'.List msg (PromisedAnswer'Op msg)))) where
    fromLabel = DC'.Get get_PromisedAnswer'transform

has_PromisedAnswer'transform :: U'.ReadCtx m msg => PromisedAnswer msg -> m Bool
has_PromisedAnswer'transform(PromisedAnswer struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "transform" (DC'.Has m (PromisedAnswer msg)) where
    fromLabel = DC'.Has has_PromisedAnswer'transform

set_PromisedAnswer'transform :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => PromisedAnswer (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (PromisedAnswer'Op (M'.MutMsg s))) -> m ()
set_PromisedAnswer'transform (PromisedAnswer struct) value = U'.setPtr (C'.toPtr value) 0 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "transform" (DC'.Set m (PromisedAnswer (M'.MutMsg s)) ((B'.List (M'.MutMsg s) (PromisedAnswer'Op (M'.MutMsg s))))) where
    fromLabel = DC'.Set set_PromisedAnswer'transform


data Call'sendResultsTo msg
    = Call'sendResultsTo'caller
    | Call'sendResultsTo'yourself
    | Call'sendResultsTo'thirdParty (Maybe (U'.Ptr msg))
    | Call'sendResultsTo'unknown' Word16




instance C'.IsStruct msg (Call'sendResultsTo msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 0 48 0
        case tag of
            2 -> Call'sendResultsTo'thirdParty <$>  (U'.getPtr 2 struct >>= C'.fromPtr (U'.message struct))
            1 -> pure Call'sendResultsTo'yourself
            0 -> pure Call'sendResultsTo'caller
            _ -> pure $ Call'sendResultsTo'unknown' tag
instance B'.ListElem msg (Call'sendResultsTo msg) where
    newtype List msg (Call'sendResultsTo msg) = List_Call'sendResultsTo (U'.ListOf msg (U'.Struct msg))
    length (List_Call'sendResultsTo l) = U'.length l
    index i (List_Call'sendResultsTo l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Call'sendResultsTo msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (Call'sendResultsTo msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Call'sendResultsTo msg); go = C'.fromStruct} in go)

    toPtr = error "TODO: toPtr for non-newtype structs."

instance C'.IsPtr msg (B'.List msg (Call'sendResultsTo msg)) where
    fromPtr msg ptr = List_Call'sendResultsTo <$> C'.fromPtr msg ptr
    toPtr (List_Call'sendResultsTo l) = C'.toPtr l

newtype Bootstrap msg = Bootstrap (U'.Struct msg)

instance C'.IsStruct msg (Bootstrap msg) where
    fromStruct = pure . Bootstrap
instance C'.IsPtr msg (Bootstrap msg) where
    fromPtr msg ptr = Bootstrap <$> C'.fromPtr msg ptr
    toPtr (Bootstrap struct) = C'.toPtr struct
instance B'.ListElem msg (Bootstrap msg) where
    newtype List msg (Bootstrap msg) = List_Bootstrap (U'.ListOf msg (U'.Struct msg))
    length (List_Bootstrap l) = U'.length l
    index i (List_Bootstrap l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Bootstrap msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Bootstrap (M'.MutMsg s)) where
    setIndex (Bootstrap elt) i (List_Bootstrap l) = U'.setIndex elt i l
    allocList msg len = List_Bootstrap <$> U'.allocCompositeList msg 1 1 len

-- | Allocate a new 'Bootstrap' inside the message.
new_Bootstrap :: M'.WriteCtx m s => M'.MutMsg s -> m (Bootstrap (M'.MutMsg s))
new_Bootstrap msg = Bootstrap <$> U'.allocStruct msg 1 1
instance C'.IsPtr msg (B'.List msg (Bootstrap msg)) where
    fromPtr msg ptr = List_Bootstrap <$> C'.fromPtr msg ptr
    toPtr (List_Bootstrap l) = C'.toPtr l
get_Bootstrap'questionId :: U'.ReadCtx m msg => Bootstrap msg -> m Word32
get_Bootstrap'questionId (Bootstrap struct) = C'.getWordField struct 0 0 0
instance U'.ReadCtx m msg => IsLabel "questionId" (DC'.Get m (Bootstrap msg) (Word32)) where
    fromLabel = DC'.Get get_Bootstrap'questionId

has_Bootstrap'questionId :: U'.ReadCtx m msg => Bootstrap msg -> m Bool
has_Bootstrap'questionId(Bootstrap struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "questionId" (DC'.Has m (Bootstrap msg)) where
    fromLabel = DC'.Has has_Bootstrap'questionId

set_Bootstrap'questionId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Bootstrap (M'.MutMsg s) -> Word32 -> m ()
set_Bootstrap'questionId (Bootstrap struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "questionId" (DC'.Set m (Bootstrap (M'.MutMsg s)) (Word32)) where
    fromLabel = DC'.Set set_Bootstrap'questionId


get_Bootstrap'deprecatedObjectId :: U'.ReadCtx m msg => Bootstrap msg -> m (Maybe (U'.Ptr msg))
get_Bootstrap'deprecatedObjectId (Bootstrap struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "deprecatedObjectId" (DC'.Get m (Bootstrap msg) ((Maybe (U'.Ptr msg)))) where
    fromLabel = DC'.Get get_Bootstrap'deprecatedObjectId

has_Bootstrap'deprecatedObjectId :: U'.ReadCtx m msg => Bootstrap msg -> m Bool
has_Bootstrap'deprecatedObjectId(Bootstrap struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "deprecatedObjectId" (DC'.Has m (Bootstrap msg)) where
    fromLabel = DC'.Has has_Bootstrap'deprecatedObjectId

set_Bootstrap'deprecatedObjectId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Bootstrap (M'.MutMsg s) -> (Maybe (U'.Ptr (M'.MutMsg s))) -> m ()
set_Bootstrap'deprecatedObjectId (Bootstrap struct) value = U'.setPtr (C'.toPtr value) 0 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "deprecatedObjectId" (DC'.Set m (Bootstrap (M'.MutMsg s)) ((Maybe (U'.Ptr (M'.MutMsg s))))) where
    fromLabel = DC'.Set set_Bootstrap'deprecatedObjectId


data PromisedAnswer'Op msg
    = PromisedAnswer'Op'noop
    | PromisedAnswer'Op'getPointerField Word16
    | PromisedAnswer'Op'unknown' Word16



instance C'.IsStruct msg (PromisedAnswer'Op msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 0 0 0
        case tag of
            1 -> PromisedAnswer'Op'getPointerField <$>  C'.getWordField struct 0 16 0
            0 -> pure PromisedAnswer'Op'noop
            _ -> pure $ PromisedAnswer'Op'unknown' tag
instance B'.ListElem msg (PromisedAnswer'Op msg) where
    newtype List msg (PromisedAnswer'Op msg) = List_PromisedAnswer'Op (U'.ListOf msg (U'.Struct msg))
    length (List_PromisedAnswer'Op l) = U'.length l
    index i (List_PromisedAnswer'Op l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (PromisedAnswer'Op msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (PromisedAnswer'Op msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (PromisedAnswer'Op msg); go = C'.fromStruct} in go)

    toPtr = error "TODO: toPtr for non-newtype structs."

instance C'.IsPtr msg (B'.List msg (PromisedAnswer'Op msg)) where
    fromPtr msg ptr = List_PromisedAnswer'Op <$> C'.fromPtr msg ptr
    toPtr (List_PromisedAnswer'Op l) = C'.toPtr l

newtype Disembargo msg = Disembargo (U'.Struct msg)

instance C'.IsStruct msg (Disembargo msg) where
    fromStruct = pure . Disembargo
instance C'.IsPtr msg (Disembargo msg) where
    fromPtr msg ptr = Disembargo <$> C'.fromPtr msg ptr
    toPtr (Disembargo struct) = C'.toPtr struct
instance B'.ListElem msg (Disembargo msg) where
    newtype List msg (Disembargo msg) = List_Disembargo (U'.ListOf msg (U'.Struct msg))
    length (List_Disembargo l) = U'.length l
    index i (List_Disembargo l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Disembargo msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Disembargo (M'.MutMsg s)) where
    setIndex (Disembargo elt) i (List_Disembargo l) = U'.setIndex elt i l
    allocList msg len = List_Disembargo <$> U'.allocCompositeList msg 1 1 len

-- | Allocate a new 'Disembargo' inside the message.
new_Disembargo :: M'.WriteCtx m s => M'.MutMsg s -> m (Disembargo (M'.MutMsg s))
new_Disembargo msg = Disembargo <$> U'.allocStruct msg 1 1
instance C'.IsPtr msg (B'.List msg (Disembargo msg)) where
    fromPtr msg ptr = List_Disembargo <$> C'.fromPtr msg ptr
    toPtr (List_Disembargo l) = C'.toPtr l
get_Disembargo'target :: U'.ReadCtx m msg => Disembargo msg -> m (MessageTarget msg)
get_Disembargo'target (Disembargo struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "target" (DC'.Get m (Disembargo msg) ((MessageTarget msg))) where
    fromLabel = DC'.Get get_Disembargo'target

has_Disembargo'target :: U'.ReadCtx m msg => Disembargo msg -> m Bool
has_Disembargo'target(Disembargo struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "target" (DC'.Has m (Disembargo msg)) where
    fromLabel = DC'.Has has_Disembargo'target

set_Disembargo'target :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Disembargo (M'.MutMsg s) -> (MessageTarget (M'.MutMsg s)) -> m ()
set_Disembargo'target (Disembargo struct) value = U'.setPtr (C'.toPtr value) 0 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "target" (DC'.Set m (Disembargo (M'.MutMsg s)) ((MessageTarget (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Disembargo'target


get_Disembargo'context :: U'.ReadCtx m msg => Disembargo msg -> m (Disembargo'context msg)
get_Disembargo'context (Disembargo struct) = C'.fromStruct struct
instance U'.ReadCtx m msg => IsLabel "context" (DC'.Get m (Disembargo msg) ((Disembargo'context msg))) where
    fromLabel = DC'.Get get_Disembargo'context

has_Disembargo'context :: U'.ReadCtx m msg => Disembargo msg -> m Bool
has_Disembargo'context(Disembargo struct) = pure True
instance U'.ReadCtx m msg => IsLabel "context" (DC'.Has m (Disembargo msg)) where
    fromLabel = DC'.Has has_Disembargo'context

set_Disembargo'context :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Disembargo (M'.MutMsg s) -> (Disembargo'context (M'.MutMsg s)) -> m ()
set_Disembargo'context _ = error "TODO: generate more setters."
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "context" (DC'.Set m (Disembargo (M'.MutMsg s)) ((Disembargo'context (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Disembargo'context


newtype Join msg = Join (U'.Struct msg)

instance C'.IsStruct msg (Join msg) where
    fromStruct = pure . Join
instance C'.IsPtr msg (Join msg) where
    fromPtr msg ptr = Join <$> C'.fromPtr msg ptr
    toPtr (Join struct) = C'.toPtr struct
instance B'.ListElem msg (Join msg) where
    newtype List msg (Join msg) = List_Join (U'.ListOf msg (U'.Struct msg))
    length (List_Join l) = U'.length l
    index i (List_Join l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Join msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Join (M'.MutMsg s)) where
    setIndex (Join elt) i (List_Join l) = U'.setIndex elt i l
    allocList msg len = List_Join <$> U'.allocCompositeList msg 1 2 len

-- | Allocate a new 'Join' inside the message.
new_Join :: M'.WriteCtx m s => M'.MutMsg s -> m (Join (M'.MutMsg s))
new_Join msg = Join <$> U'.allocStruct msg 1 2
instance C'.IsPtr msg (B'.List msg (Join msg)) where
    fromPtr msg ptr = List_Join <$> C'.fromPtr msg ptr
    toPtr (List_Join l) = C'.toPtr l
get_Join'questionId :: U'.ReadCtx m msg => Join msg -> m Word32
get_Join'questionId (Join struct) = C'.getWordField struct 0 0 0
instance U'.ReadCtx m msg => IsLabel "questionId" (DC'.Get m (Join msg) (Word32)) where
    fromLabel = DC'.Get get_Join'questionId

has_Join'questionId :: U'.ReadCtx m msg => Join msg -> m Bool
has_Join'questionId(Join struct) = pure $ 0 < U'.length (U'.dataSection struct)
instance U'.ReadCtx m msg => IsLabel "questionId" (DC'.Has m (Join msg)) where
    fromLabel = DC'.Has has_Join'questionId

set_Join'questionId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Join (M'.MutMsg s) -> Word32 -> m ()
set_Join'questionId (Join struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0
instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "questionId" (DC'.Set m (Join (M'.MutMsg s)) (Word32)) where
    fromLabel = DC'.Set set_Join'questionId


get_Join'target :: U'.ReadCtx m msg => Join msg -> m (MessageTarget msg)
get_Join'target (Join struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "target" (DC'.Get m (Join msg) ((MessageTarget msg))) where
    fromLabel = DC'.Get get_Join'target

has_Join'target :: U'.ReadCtx m msg => Join msg -> m Bool
has_Join'target(Join struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
instance U'.ReadCtx m msg => IsLabel "target" (DC'.Has m (Join msg)) where
    fromLabel = DC'.Has has_Join'target

set_Join'target :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Join (M'.MutMsg s) -> (MessageTarget (M'.MutMsg s)) -> m ()
set_Join'target (Join struct) value = U'.setPtr (C'.toPtr value) 0 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "target" (DC'.Set m (Join (M'.MutMsg s)) ((MessageTarget (M'.MutMsg s)))) where
    fromLabel = DC'.Set set_Join'target


get_Join'keyPart :: U'.ReadCtx m msg => Join msg -> m (Maybe (U'.Ptr msg))
get_Join'keyPart (Join struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)

instance U'.ReadCtx m msg => IsLabel "keyPart" (DC'.Get m (Join msg) ((Maybe (U'.Ptr msg)))) where
    fromLabel = DC'.Get get_Join'keyPart

has_Join'keyPart :: U'.ReadCtx m msg => Join msg -> m Bool
has_Join'keyPart(Join struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
instance U'.ReadCtx m msg => IsLabel "keyPart" (DC'.Has m (Join msg)) where
    fromLabel = DC'.Has has_Join'keyPart

set_Join'keyPart :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Join (M'.MutMsg s) -> (Maybe (U'.Ptr (M'.MutMsg s))) -> m ()
set_Join'keyPart (Join struct) value = U'.setPtr (C'.toPtr value) 1 struct

instance (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => IsLabel "keyPart" (DC'.Set m (Join (M'.MutMsg s)) ((Maybe (U'.Ptr (M'.MutMsg s))))) where
    fromLabel = DC'.Set set_Join'keyPart

