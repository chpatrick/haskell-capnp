{-# OPTIONS_GHC -Wno-unused-imports #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeFamilies #-}
module Capnp.Capnp.Rpc where

-- Code generated by capnpc-haskell. DO NOT EDIT.
-- Generated from schema file: capnp/rpc.capnp

import Data.Int
import Data.Word

import Data.Capnp.Bits (Word1)

import qualified Data.Bits
import qualified Data.Maybe
import qualified Codec.Capnp as C'
import qualified Data.Capnp.Basics as B'
import qualified Data.Capnp.TraversalLimit as TL'
import qualified Data.Capnp.Untyped as U'
import qualified Data.Capnp.Message as M'

import qualified Capnp.ById.Xbdf87d7bb8304e81

newtype Call msg = Call (U'.Struct msg)

instance C'.IsStruct msg (Call msg) where
    fromStruct = pure . Call
instance C'.IsPtr msg (Call msg) where
    fromPtr msg ptr = Call <$> C'.fromPtr msg ptr
    toPtr (Call struct) = C'.toPtr struct
instance B'.ListElem msg (Call msg) where
    newtype List msg (Call msg) = List_Call (U'.ListOf msg (U'.Struct msg))
    length (List_Call l) = U'.length l
    index i (List_Call l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Call msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Call (M'.MutMsg s)) where
    setIndex (Call elt) i (List_Call l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Call msg)) where
    fromPtr msg ptr = List_Call <$> C'.fromPtr msg ptr
    toPtr (List_Call l) = C'.toPtr l
get_Call'questionId :: U'.ReadCtx m msg => Call msg -> m Word32
get_Call'questionId (Call struct) = C'.getWordField struct 0 0 0

has_Call'questionId :: U'.ReadCtx m msg => Call msg -> m Bool
has_Call'questionId(Call struct) = pure $ 0 < U'.length (U'.dataSection struct)
set_Call'questionId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Call (M'.MutMsg s) -> Word32 -> m ()
set_Call'questionId (Call struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0

get_Call'target :: U'.ReadCtx m msg => Call msg -> m (MessageTarget msg)
get_Call'target (Call struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)


has_Call'target :: U'.ReadCtx m msg => Call msg -> m Bool
has_Call'target(Call struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_Call'target :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Call (M'.MutMsg s) -> (MessageTarget (M'.MutMsg s)) -> m ()
set_Call'target (Call struct) value = U'.setPtr (C'.toPtr value) 0 struct


get_Call'interfaceId :: U'.ReadCtx m msg => Call msg -> m Word64
get_Call'interfaceId (Call struct) = C'.getWordField struct 1 0 0

has_Call'interfaceId :: U'.ReadCtx m msg => Call msg -> m Bool
has_Call'interfaceId(Call struct) = pure $ 1 < U'.length (U'.dataSection struct)
set_Call'interfaceId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Call (M'.MutMsg s) -> Word64 -> m ()
set_Call'interfaceId (Call struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word64) 1 0 0

get_Call'methodId :: U'.ReadCtx m msg => Call msg -> m Word16
get_Call'methodId (Call struct) = C'.getWordField struct 0 32 0

has_Call'methodId :: U'.ReadCtx m msg => Call msg -> m Bool
has_Call'methodId(Call struct) = pure $ 0 < U'.length (U'.dataSection struct)
set_Call'methodId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Call (M'.MutMsg s) -> Word16 -> m ()
set_Call'methodId (Call struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word16) 0 32 0

get_Call'params :: U'.ReadCtx m msg => Call msg -> m (Payload msg)
get_Call'params (Call struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)


has_Call'params :: U'.ReadCtx m msg => Call msg -> m Bool
has_Call'params(Call struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
set_Call'params :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Call (M'.MutMsg s) -> (Payload (M'.MutMsg s)) -> m ()
set_Call'params (Call struct) value = U'.setPtr (C'.toPtr value) 1 struct


get_Call'sendResultsTo :: U'.ReadCtx m msg => Call msg -> m (Call'sendResultsTo msg)
get_Call'sendResultsTo (Call struct) = C'.fromStruct struct

has_Call'sendResultsTo :: U'.ReadCtx m msg => Call msg -> m Bool
has_Call'sendResultsTo(Call struct) = pure True
set_Call'sendResultsTo :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Call (M'.MutMsg s) -> (Call'sendResultsTo (M'.MutMsg s)) -> m ()
set_Call'sendResultsTo _ = error "TODO: generate more setters."

get_Call'allowThirdPartyTailCall :: U'.ReadCtx m msg => Call msg -> m Bool
get_Call'allowThirdPartyTailCall (Call struct) = C'.getWordField struct 2 0 0

has_Call'allowThirdPartyTailCall :: U'.ReadCtx m msg => Call msg -> m Bool
has_Call'allowThirdPartyTailCall(Call struct) = pure $ 2 < U'.length (U'.dataSection struct)
set_Call'allowThirdPartyTailCall :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Call (M'.MutMsg s) -> Bool -> m ()
set_Call'allowThirdPartyTailCall (Call struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word1) 2 0 0

data CapDescriptor msg
    = CapDescriptor'none
    | CapDescriptor'senderHosted Word32
    | CapDescriptor'senderPromise Word32
    | CapDescriptor'receiverHosted Word32
    | CapDescriptor'receiverAnswer (PromisedAnswer msg)
    | CapDescriptor'thirdPartyHosted (ThirdPartyCapDescriptor msg)
    | CapDescriptor'unknown' Word16







instance C'.IsStruct msg (CapDescriptor msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 0 0 0
        case tag of
            5 -> CapDescriptor'thirdPartyHosted <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            4 -> CapDescriptor'receiverAnswer <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            3 -> CapDescriptor'receiverHosted <$>  C'.getWordField struct 0 32 0
            2 -> CapDescriptor'senderPromise <$>  C'.getWordField struct 0 32 0
            1 -> CapDescriptor'senderHosted <$>  C'.getWordField struct 0 32 0
            0 -> pure CapDescriptor'none
            _ -> pure $ CapDescriptor'unknown' tag
instance B'.ListElem msg (CapDescriptor msg) where
    newtype List msg (CapDescriptor msg) = List_CapDescriptor (U'.ListOf msg (U'.Struct msg))
    length (List_CapDescriptor l) = U'.length l
    index i (List_CapDescriptor l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (CapDescriptor msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (CapDescriptor msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (CapDescriptor msg); go = C'.fromStruct} in go)

    toPtr = error "TODO: toPtr for non-newtype structs."

instance C'.IsPtr msg (B'.List msg (CapDescriptor msg)) where
    fromPtr msg ptr = List_CapDescriptor <$> C'.fromPtr msg ptr
    toPtr (List_CapDescriptor l) = C'.toPtr l

data Message msg
    = Message'unimplemented (Message msg)
    | Message'abort (Exception msg)
    | Message'call (Call msg)
    | Message'return (Return msg)
    | Message'finish (Finish msg)
    | Message'resolve (Resolve msg)
    | Message'release (Release msg)
    | Message'obsoleteSave (Maybe (U'.Ptr msg))
    | Message'bootstrap (Bootstrap msg)
    | Message'obsoleteDelete (Maybe (U'.Ptr msg))
    | Message'provide (Provide msg)
    | Message'accept (Accept msg)
    | Message'join (Join msg)
    | Message'disembargo (Disembargo msg)
    | Message'unknown' Word16















instance C'.IsStruct msg (Message msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 0 0 0
        case tag of
            13 -> Message'disembargo <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            12 -> Message'join <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            11 -> Message'accept <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            10 -> Message'provide <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            9 -> Message'obsoleteDelete <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            8 -> Message'bootstrap <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            7 -> Message'obsoleteSave <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            6 -> Message'release <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            5 -> Message'resolve <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            4 -> Message'finish <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            3 -> Message'return <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            2 -> Message'call <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            1 -> Message'abort <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            0 -> Message'unimplemented <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            _ -> pure $ Message'unknown' tag
instance B'.ListElem msg (Message msg) where
    newtype List msg (Message msg) = List_Message (U'.ListOf msg (U'.Struct msg))
    length (List_Message l) = U'.length l
    index i (List_Message l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Message msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (Message msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Message msg); go = C'.fromStruct} in go)

    toPtr = error "TODO: toPtr for non-newtype structs."

instance C'.IsPtr msg (B'.List msg (Message msg)) where
    fromPtr msg ptr = List_Message <$> C'.fromPtr msg ptr
    toPtr (List_Message l) = C'.toPtr l

data MessageTarget msg
    = MessageTarget'importedCap Word32
    | MessageTarget'promisedAnswer (PromisedAnswer msg)
    | MessageTarget'unknown' Word16



instance C'.IsStruct msg (MessageTarget msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 0 32 0
        case tag of
            1 -> MessageTarget'promisedAnswer <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            0 -> MessageTarget'importedCap <$>  C'.getWordField struct 0 0 0
            _ -> pure $ MessageTarget'unknown' tag
instance B'.ListElem msg (MessageTarget msg) where
    newtype List msg (MessageTarget msg) = List_MessageTarget (U'.ListOf msg (U'.Struct msg))
    length (List_MessageTarget l) = U'.length l
    index i (List_MessageTarget l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (MessageTarget msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (MessageTarget msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (MessageTarget msg); go = C'.fromStruct} in go)

    toPtr = error "TODO: toPtr for non-newtype structs."

instance C'.IsPtr msg (B'.List msg (MessageTarget msg)) where
    fromPtr msg ptr = List_MessageTarget <$> C'.fromPtr msg ptr
    toPtr (List_MessageTarget l) = C'.toPtr l

newtype Payload msg = Payload (U'.Struct msg)

instance C'.IsStruct msg (Payload msg) where
    fromStruct = pure . Payload
instance C'.IsPtr msg (Payload msg) where
    fromPtr msg ptr = Payload <$> C'.fromPtr msg ptr
    toPtr (Payload struct) = C'.toPtr struct
instance B'.ListElem msg (Payload msg) where
    newtype List msg (Payload msg) = List_Payload (U'.ListOf msg (U'.Struct msg))
    length (List_Payload l) = U'.length l
    index i (List_Payload l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Payload msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Payload (M'.MutMsg s)) where
    setIndex (Payload elt) i (List_Payload l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Payload msg)) where
    fromPtr msg ptr = List_Payload <$> C'.fromPtr msg ptr
    toPtr (List_Payload l) = C'.toPtr l
get_Payload'content :: U'.ReadCtx m msg => Payload msg -> m (Maybe (U'.Ptr msg))
get_Payload'content (Payload struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)


has_Payload'content :: U'.ReadCtx m msg => Payload msg -> m Bool
has_Payload'content(Payload struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_Payload'content :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Payload (M'.MutMsg s) -> (Maybe (U'.Ptr (M'.MutMsg s))) -> m ()
set_Payload'content (Payload struct) value = U'.setPtr (C'.toPtr value) 0 struct


get_Payload'capTable :: U'.ReadCtx m msg => Payload msg -> m (B'.List msg (CapDescriptor msg))
get_Payload'capTable (Payload struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)


has_Payload'capTable :: U'.ReadCtx m msg => Payload msg -> m Bool
has_Payload'capTable(Payload struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
set_Payload'capTable :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Payload (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (CapDescriptor (M'.MutMsg s))) -> m ()
set_Payload'capTable (Payload struct) value = U'.setPtr (C'.toPtr value) 1 struct


newtype Provide msg = Provide (U'.Struct msg)

instance C'.IsStruct msg (Provide msg) where
    fromStruct = pure . Provide
instance C'.IsPtr msg (Provide msg) where
    fromPtr msg ptr = Provide <$> C'.fromPtr msg ptr
    toPtr (Provide struct) = C'.toPtr struct
instance B'.ListElem msg (Provide msg) where
    newtype List msg (Provide msg) = List_Provide (U'.ListOf msg (U'.Struct msg))
    length (List_Provide l) = U'.length l
    index i (List_Provide l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Provide msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Provide (M'.MutMsg s)) where
    setIndex (Provide elt) i (List_Provide l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Provide msg)) where
    fromPtr msg ptr = List_Provide <$> C'.fromPtr msg ptr
    toPtr (List_Provide l) = C'.toPtr l
get_Provide'questionId :: U'.ReadCtx m msg => Provide msg -> m Word32
get_Provide'questionId (Provide struct) = C'.getWordField struct 0 0 0

has_Provide'questionId :: U'.ReadCtx m msg => Provide msg -> m Bool
has_Provide'questionId(Provide struct) = pure $ 0 < U'.length (U'.dataSection struct)
set_Provide'questionId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Provide (M'.MutMsg s) -> Word32 -> m ()
set_Provide'questionId (Provide struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0

get_Provide'target :: U'.ReadCtx m msg => Provide msg -> m (MessageTarget msg)
get_Provide'target (Provide struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)


has_Provide'target :: U'.ReadCtx m msg => Provide msg -> m Bool
has_Provide'target(Provide struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_Provide'target :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Provide (M'.MutMsg s) -> (MessageTarget (M'.MutMsg s)) -> m ()
set_Provide'target (Provide struct) value = U'.setPtr (C'.toPtr value) 0 struct


get_Provide'recipient :: U'.ReadCtx m msg => Provide msg -> m (Maybe (U'.Ptr msg))
get_Provide'recipient (Provide struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)


has_Provide'recipient :: U'.ReadCtx m msg => Provide msg -> m Bool
has_Provide'recipient(Provide struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
set_Provide'recipient :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Provide (M'.MutMsg s) -> (Maybe (U'.Ptr (M'.MutMsg s))) -> m ()
set_Provide'recipient (Provide struct) value = U'.setPtr (C'.toPtr value) 1 struct


newtype Return msg = Return (U'.Struct msg)

instance C'.IsStruct msg (Return msg) where
    fromStruct = pure . Return
instance C'.IsPtr msg (Return msg) where
    fromPtr msg ptr = Return <$> C'.fromPtr msg ptr
    toPtr (Return struct) = C'.toPtr struct
instance B'.ListElem msg (Return msg) where
    newtype List msg (Return msg) = List_Return (U'.ListOf msg (U'.Struct msg))
    length (List_Return l) = U'.length l
    index i (List_Return l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Return msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Return (M'.MutMsg s)) where
    setIndex (Return elt) i (List_Return l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Return msg)) where
    fromPtr msg ptr = List_Return <$> C'.fromPtr msg ptr
    toPtr (List_Return l) = C'.toPtr l
get_Return''answerId :: U'.ReadCtx m msg => Return msg -> m Word32
get_Return''answerId (Return struct) = C'.getWordField struct 0 0 0

has_Return''answerId :: U'.ReadCtx m msg => Return msg -> m Bool
has_Return''answerId(Return struct) = pure $ 0 < U'.length (U'.dataSection struct)
set_Return''answerId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Return (M'.MutMsg s) -> Word32 -> m ()
set_Return''answerId (Return struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0

get_Return''releaseParamCaps :: U'.ReadCtx m msg => Return msg -> m Bool
get_Return''releaseParamCaps (Return struct) = C'.getWordField struct 0 32 1

has_Return''releaseParamCaps :: U'.ReadCtx m msg => Return msg -> m Bool
has_Return''releaseParamCaps(Return struct) = pure $ 0 < U'.length (U'.dataSection struct)
set_Return''releaseParamCaps :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Return (M'.MutMsg s) -> Bool -> m ()
set_Return''releaseParamCaps (Return struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word1) 0 32 1

get_Return''union' :: U'.ReadCtx m msg => Return msg -> m (Return' msg)
get_Return''union' (Return struct) = C'.fromStruct struct

has_Return''union' :: U'.ReadCtx m msg => Return msg -> m Bool
has_Return''union'(Return struct) = pure True
set_Return''union' :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Return (M'.MutMsg s) -> (Return' (M'.MutMsg s)) -> m ()
set_Return''union' _ = error "TODO: generate more setters."

data Return' msg
    = Return'results (Payload msg)
    | Return'exception (Exception msg)
    | Return'canceled
    | Return'resultsSentElsewhere
    | Return'takeFromOtherQuestion Word32
    | Return'acceptFromThirdParty (Maybe (U'.Ptr msg))
    | Return'unknown' Word16







instance C'.IsStruct msg (Return' msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 0 48 0
        case tag of
            5 -> Return'acceptFromThirdParty <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            4 -> Return'takeFromOtherQuestion <$>  C'.getWordField struct 1 0 0
            3 -> pure Return'resultsSentElsewhere
            2 -> pure Return'canceled
            1 -> Return'exception <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            0 -> Return'results <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            _ -> pure $ Return'unknown' tag
instance B'.ListElem msg (Return' msg) where
    newtype List msg (Return' msg) = List_Return' (U'.ListOf msg (U'.Struct msg))
    length (List_Return' l) = U'.length l
    index i (List_Return' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Return' msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (Return' msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Return' msg); go = C'.fromStruct} in go)

    toPtr = error "TODO: toPtr for non-newtype structs."

instance C'.IsPtr msg (B'.List msg (Return' msg)) where
    fromPtr msg ptr = List_Return' <$> C'.fromPtr msg ptr
    toPtr (List_Return' l) = C'.toPtr l

newtype Release msg = Release (U'.Struct msg)

instance C'.IsStruct msg (Release msg) where
    fromStruct = pure . Release
instance C'.IsPtr msg (Release msg) where
    fromPtr msg ptr = Release <$> C'.fromPtr msg ptr
    toPtr (Release struct) = C'.toPtr struct
instance B'.ListElem msg (Release msg) where
    newtype List msg (Release msg) = List_Release (U'.ListOf msg (U'.Struct msg))
    length (List_Release l) = U'.length l
    index i (List_Release l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Release msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Release (M'.MutMsg s)) where
    setIndex (Release elt) i (List_Release l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Release msg)) where
    fromPtr msg ptr = List_Release <$> C'.fromPtr msg ptr
    toPtr (List_Release l) = C'.toPtr l
get_Release'id :: U'.ReadCtx m msg => Release msg -> m Word32
get_Release'id (Release struct) = C'.getWordField struct 0 0 0

has_Release'id :: U'.ReadCtx m msg => Release msg -> m Bool
has_Release'id(Release struct) = pure $ 0 < U'.length (U'.dataSection struct)
set_Release'id :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Release (M'.MutMsg s) -> Word32 -> m ()
set_Release'id (Release struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0

get_Release'referenceCount :: U'.ReadCtx m msg => Release msg -> m Word32
get_Release'referenceCount (Release struct) = C'.getWordField struct 0 32 0

has_Release'referenceCount :: U'.ReadCtx m msg => Release msg -> m Bool
has_Release'referenceCount(Release struct) = pure $ 0 < U'.length (U'.dataSection struct)
set_Release'referenceCount :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Release (M'.MutMsg s) -> Word32 -> m ()
set_Release'referenceCount (Release struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 32 0

data Exception'Type
    = Exception'Type'failed
    | Exception'Type'overloaded
    | Exception'Type'disconnected
    | Exception'Type'unimplemented
    | Exception'Type'unknown' Word16
instance Enum Exception'Type where
    toEnum = C'.fromWord . fromIntegral
    fromEnum = fromIntegral . C'.toWord


instance C'.IsWord Exception'Type where
    fromWord n = go (fromIntegral n :: Word16)
      where
        go 3 = Exception'Type'unimplemented
        go 2 = Exception'Type'disconnected
        go 1 = Exception'Type'overloaded
        go 0 = Exception'Type'failed
        go tag = Exception'Type'unknown' (fromIntegral tag)
    toWord Exception'Type'unimplemented = 3
    toWord Exception'Type'disconnected = 2
    toWord Exception'Type'overloaded = 1
    toWord Exception'Type'failed = 0
    toWord (Exception'Type'unknown' tag) = fromIntegral tag
instance B'.ListElem msg Exception'Type where
    newtype List msg Exception'Type = List_Exception'Type (U'.ListOf msg Word16)
    length (List_Exception'Type l) = U'.length l
    index i (List_Exception'Type l) = (C'.fromWord . fromIntegral) <$> U'.index i l
instance B'.MutListElem s Exception'Type where
    setIndex elt i (List_Exception'Type l) = error "TODO: generate code for setIndex"
instance C'.IsPtr msg (B'.List msg Exception'Type) where
    fromPtr msg ptr = List_Exception'Type <$> C'.fromPtr msg ptr
    toPtr (List_Exception'Type l) = C'.toPtr l

newtype Resolve msg = Resolve (U'.Struct msg)

instance C'.IsStruct msg (Resolve msg) where
    fromStruct = pure . Resolve
instance C'.IsPtr msg (Resolve msg) where
    fromPtr msg ptr = Resolve <$> C'.fromPtr msg ptr
    toPtr (Resolve struct) = C'.toPtr struct
instance B'.ListElem msg (Resolve msg) where
    newtype List msg (Resolve msg) = List_Resolve (U'.ListOf msg (U'.Struct msg))
    length (List_Resolve l) = U'.length l
    index i (List_Resolve l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Resolve msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Resolve (M'.MutMsg s)) where
    setIndex (Resolve elt) i (List_Resolve l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Resolve msg)) where
    fromPtr msg ptr = List_Resolve <$> C'.fromPtr msg ptr
    toPtr (List_Resolve l) = C'.toPtr l
get_Resolve''promiseId :: U'.ReadCtx m msg => Resolve msg -> m Word32
get_Resolve''promiseId (Resolve struct) = C'.getWordField struct 0 0 0

has_Resolve''promiseId :: U'.ReadCtx m msg => Resolve msg -> m Bool
has_Resolve''promiseId(Resolve struct) = pure $ 0 < U'.length (U'.dataSection struct)
set_Resolve''promiseId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Resolve (M'.MutMsg s) -> Word32 -> m ()
set_Resolve''promiseId (Resolve struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0

get_Resolve''union' :: U'.ReadCtx m msg => Resolve msg -> m (Resolve' msg)
get_Resolve''union' (Resolve struct) = C'.fromStruct struct

has_Resolve''union' :: U'.ReadCtx m msg => Resolve msg -> m Bool
has_Resolve''union'(Resolve struct) = pure True
set_Resolve''union' :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Resolve (M'.MutMsg s) -> (Resolve' (M'.MutMsg s)) -> m ()
set_Resolve''union' _ = error "TODO: generate more setters."

data Resolve' msg
    = Resolve'cap (CapDescriptor msg)
    | Resolve'exception (Exception msg)
    | Resolve'unknown' Word16



instance C'.IsStruct msg (Resolve' msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 0 32 0
        case tag of
            1 -> Resolve'exception <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            0 -> Resolve'cap <$>  (U'.getPtr 0 struct >>= C'.fromPtr (U'.message struct))
            _ -> pure $ Resolve'unknown' tag
instance B'.ListElem msg (Resolve' msg) where
    newtype List msg (Resolve' msg) = List_Resolve' (U'.ListOf msg (U'.Struct msg))
    length (List_Resolve' l) = U'.length l
    index i (List_Resolve' l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Resolve' msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (Resolve' msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Resolve' msg); go = C'.fromStruct} in go)

    toPtr = error "TODO: toPtr for non-newtype structs."

instance C'.IsPtr msg (B'.List msg (Resolve' msg)) where
    fromPtr msg ptr = List_Resolve' <$> C'.fromPtr msg ptr
    toPtr (List_Resolve' l) = C'.toPtr l

newtype ThirdPartyCapDescriptor msg = ThirdPartyCapDescriptor (U'.Struct msg)

instance C'.IsStruct msg (ThirdPartyCapDescriptor msg) where
    fromStruct = pure . ThirdPartyCapDescriptor
instance C'.IsPtr msg (ThirdPartyCapDescriptor msg) where
    fromPtr msg ptr = ThirdPartyCapDescriptor <$> C'.fromPtr msg ptr
    toPtr (ThirdPartyCapDescriptor struct) = C'.toPtr struct
instance B'.ListElem msg (ThirdPartyCapDescriptor msg) where
    newtype List msg (ThirdPartyCapDescriptor msg) = List_ThirdPartyCapDescriptor (U'.ListOf msg (U'.Struct msg))
    length (List_ThirdPartyCapDescriptor l) = U'.length l
    index i (List_ThirdPartyCapDescriptor l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (ThirdPartyCapDescriptor msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (ThirdPartyCapDescriptor (M'.MutMsg s)) where
    setIndex (ThirdPartyCapDescriptor elt) i (List_ThirdPartyCapDescriptor l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (ThirdPartyCapDescriptor msg)) where
    fromPtr msg ptr = List_ThirdPartyCapDescriptor <$> C'.fromPtr msg ptr
    toPtr (List_ThirdPartyCapDescriptor l) = C'.toPtr l
get_ThirdPartyCapDescriptor'id :: U'.ReadCtx m msg => ThirdPartyCapDescriptor msg -> m (Maybe (U'.Ptr msg))
get_ThirdPartyCapDescriptor'id (ThirdPartyCapDescriptor struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)


has_ThirdPartyCapDescriptor'id :: U'.ReadCtx m msg => ThirdPartyCapDescriptor msg -> m Bool
has_ThirdPartyCapDescriptor'id(ThirdPartyCapDescriptor struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_ThirdPartyCapDescriptor'id :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => ThirdPartyCapDescriptor (M'.MutMsg s) -> (Maybe (U'.Ptr (M'.MutMsg s))) -> m ()
set_ThirdPartyCapDescriptor'id (ThirdPartyCapDescriptor struct) value = U'.setPtr (C'.toPtr value) 0 struct


get_ThirdPartyCapDescriptor'vineId :: U'.ReadCtx m msg => ThirdPartyCapDescriptor msg -> m Word32
get_ThirdPartyCapDescriptor'vineId (ThirdPartyCapDescriptor struct) = C'.getWordField struct 0 0 0

has_ThirdPartyCapDescriptor'vineId :: U'.ReadCtx m msg => ThirdPartyCapDescriptor msg -> m Bool
has_ThirdPartyCapDescriptor'vineId(ThirdPartyCapDescriptor struct) = pure $ 0 < U'.length (U'.dataSection struct)
set_ThirdPartyCapDescriptor'vineId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => ThirdPartyCapDescriptor (M'.MutMsg s) -> Word32 -> m ()
set_ThirdPartyCapDescriptor'vineId (ThirdPartyCapDescriptor struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0

newtype Finish msg = Finish (U'.Struct msg)

instance C'.IsStruct msg (Finish msg) where
    fromStruct = pure . Finish
instance C'.IsPtr msg (Finish msg) where
    fromPtr msg ptr = Finish <$> C'.fromPtr msg ptr
    toPtr (Finish struct) = C'.toPtr struct
instance B'.ListElem msg (Finish msg) where
    newtype List msg (Finish msg) = List_Finish (U'.ListOf msg (U'.Struct msg))
    length (List_Finish l) = U'.length l
    index i (List_Finish l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Finish msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Finish (M'.MutMsg s)) where
    setIndex (Finish elt) i (List_Finish l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Finish msg)) where
    fromPtr msg ptr = List_Finish <$> C'.fromPtr msg ptr
    toPtr (List_Finish l) = C'.toPtr l
get_Finish'questionId :: U'.ReadCtx m msg => Finish msg -> m Word32
get_Finish'questionId (Finish struct) = C'.getWordField struct 0 0 0

has_Finish'questionId :: U'.ReadCtx m msg => Finish msg -> m Bool
has_Finish'questionId(Finish struct) = pure $ 0 < U'.length (U'.dataSection struct)
set_Finish'questionId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Finish (M'.MutMsg s) -> Word32 -> m ()
set_Finish'questionId (Finish struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0

get_Finish'releaseResultCaps :: U'.ReadCtx m msg => Finish msg -> m Bool
get_Finish'releaseResultCaps (Finish struct) = C'.getWordField struct 0 32 1

has_Finish'releaseResultCaps :: U'.ReadCtx m msg => Finish msg -> m Bool
has_Finish'releaseResultCaps(Finish struct) = pure $ 0 < U'.length (U'.dataSection struct)
set_Finish'releaseResultCaps :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Finish (M'.MutMsg s) -> Bool -> m ()
set_Finish'releaseResultCaps (Finish struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word1) 0 32 1

newtype Accept msg = Accept (U'.Struct msg)

instance C'.IsStruct msg (Accept msg) where
    fromStruct = pure . Accept
instance C'.IsPtr msg (Accept msg) where
    fromPtr msg ptr = Accept <$> C'.fromPtr msg ptr
    toPtr (Accept struct) = C'.toPtr struct
instance B'.ListElem msg (Accept msg) where
    newtype List msg (Accept msg) = List_Accept (U'.ListOf msg (U'.Struct msg))
    length (List_Accept l) = U'.length l
    index i (List_Accept l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Accept msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Accept (M'.MutMsg s)) where
    setIndex (Accept elt) i (List_Accept l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Accept msg)) where
    fromPtr msg ptr = List_Accept <$> C'.fromPtr msg ptr
    toPtr (List_Accept l) = C'.toPtr l
get_Accept'questionId :: U'.ReadCtx m msg => Accept msg -> m Word32
get_Accept'questionId (Accept struct) = C'.getWordField struct 0 0 0

has_Accept'questionId :: U'.ReadCtx m msg => Accept msg -> m Bool
has_Accept'questionId(Accept struct) = pure $ 0 < U'.length (U'.dataSection struct)
set_Accept'questionId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Accept (M'.MutMsg s) -> Word32 -> m ()
set_Accept'questionId (Accept struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0

get_Accept'provision :: U'.ReadCtx m msg => Accept msg -> m (Maybe (U'.Ptr msg))
get_Accept'provision (Accept struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)


has_Accept'provision :: U'.ReadCtx m msg => Accept msg -> m Bool
has_Accept'provision(Accept struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_Accept'provision :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Accept (M'.MutMsg s) -> (Maybe (U'.Ptr (M'.MutMsg s))) -> m ()
set_Accept'provision (Accept struct) value = U'.setPtr (C'.toPtr value) 0 struct


get_Accept'embargo :: U'.ReadCtx m msg => Accept msg -> m Bool
get_Accept'embargo (Accept struct) = C'.getWordField struct 0 32 0

has_Accept'embargo :: U'.ReadCtx m msg => Accept msg -> m Bool
has_Accept'embargo(Accept struct) = pure $ 0 < U'.length (U'.dataSection struct)
set_Accept'embargo :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Accept (M'.MutMsg s) -> Bool -> m ()
set_Accept'embargo (Accept struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word1) 0 32 0

data Disembargo'context msg
    = Disembargo'context'senderLoopback Word32
    | Disembargo'context'receiverLoopback Word32
    | Disembargo'context'accept
    | Disembargo'context'provide Word32
    | Disembargo'context'unknown' Word16





instance C'.IsStruct msg (Disembargo'context msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 0 32 0
        case tag of
            3 -> Disembargo'context'provide <$>  C'.getWordField struct 0 0 0
            2 -> pure Disembargo'context'accept
            1 -> Disembargo'context'receiverLoopback <$>  C'.getWordField struct 0 0 0
            0 -> Disembargo'context'senderLoopback <$>  C'.getWordField struct 0 0 0
            _ -> pure $ Disembargo'context'unknown' tag
instance B'.ListElem msg (Disembargo'context msg) where
    newtype List msg (Disembargo'context msg) = List_Disembargo'context (U'.ListOf msg (U'.Struct msg))
    length (List_Disembargo'context l) = U'.length l
    index i (List_Disembargo'context l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Disembargo'context msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (Disembargo'context msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Disembargo'context msg); go = C'.fromStruct} in go)

    toPtr = error "TODO: toPtr for non-newtype structs."

instance C'.IsPtr msg (B'.List msg (Disembargo'context msg)) where
    fromPtr msg ptr = List_Disembargo'context <$> C'.fromPtr msg ptr
    toPtr (List_Disembargo'context l) = C'.toPtr l

newtype Exception msg = Exception (U'.Struct msg)

instance C'.IsStruct msg (Exception msg) where
    fromStruct = pure . Exception
instance C'.IsPtr msg (Exception msg) where
    fromPtr msg ptr = Exception <$> C'.fromPtr msg ptr
    toPtr (Exception struct) = C'.toPtr struct
instance B'.ListElem msg (Exception msg) where
    newtype List msg (Exception msg) = List_Exception (U'.ListOf msg (U'.Struct msg))
    length (List_Exception l) = U'.length l
    index i (List_Exception l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Exception msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Exception (M'.MutMsg s)) where
    setIndex (Exception elt) i (List_Exception l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Exception msg)) where
    fromPtr msg ptr = List_Exception <$> C'.fromPtr msg ptr
    toPtr (List_Exception l) = C'.toPtr l
get_Exception'reason :: U'.ReadCtx m msg => Exception msg -> m (B'.Text msg)
get_Exception'reason (Exception struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)


has_Exception'reason :: U'.ReadCtx m msg => Exception msg -> m Bool
has_Exception'reason(Exception struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_Exception'reason :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Exception (M'.MutMsg s) -> (B'.Text (M'.MutMsg s)) -> m ()
set_Exception'reason (Exception struct) value = U'.setPtr (C'.toPtr value) 0 struct


get_Exception'obsoleteIsCallersFault :: U'.ReadCtx m msg => Exception msg -> m Bool
get_Exception'obsoleteIsCallersFault (Exception struct) = C'.getWordField struct 0 0 0

has_Exception'obsoleteIsCallersFault :: U'.ReadCtx m msg => Exception msg -> m Bool
has_Exception'obsoleteIsCallersFault(Exception struct) = pure $ 0 < U'.length (U'.dataSection struct)
set_Exception'obsoleteIsCallersFault :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Exception (M'.MutMsg s) -> Bool -> m ()
set_Exception'obsoleteIsCallersFault (Exception struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word1) 0 0 0

get_Exception'obsoleteDurability :: U'.ReadCtx m msg => Exception msg -> m Word16
get_Exception'obsoleteDurability (Exception struct) = C'.getWordField struct 0 16 0

has_Exception'obsoleteDurability :: U'.ReadCtx m msg => Exception msg -> m Bool
has_Exception'obsoleteDurability(Exception struct) = pure $ 0 < U'.length (U'.dataSection struct)
set_Exception'obsoleteDurability :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Exception (M'.MutMsg s) -> Word16 -> m ()
set_Exception'obsoleteDurability (Exception struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word16) 0 16 0

get_Exception'type_ :: U'.ReadCtx m msg => Exception msg -> m Exception'Type
get_Exception'type_ (Exception struct) = C'.getWordField struct 0 32 0

has_Exception'type_ :: U'.ReadCtx m msg => Exception msg -> m Bool
has_Exception'type_(Exception struct) = pure $ 0 < U'.length (U'.dataSection struct)
set_Exception'type_ :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Exception (M'.MutMsg s) -> Exception'Type -> m ()
set_Exception'type_ (Exception struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word16) 0 32 0

newtype PromisedAnswer msg = PromisedAnswer (U'.Struct msg)

instance C'.IsStruct msg (PromisedAnswer msg) where
    fromStruct = pure . PromisedAnswer
instance C'.IsPtr msg (PromisedAnswer msg) where
    fromPtr msg ptr = PromisedAnswer <$> C'.fromPtr msg ptr
    toPtr (PromisedAnswer struct) = C'.toPtr struct
instance B'.ListElem msg (PromisedAnswer msg) where
    newtype List msg (PromisedAnswer msg) = List_PromisedAnswer (U'.ListOf msg (U'.Struct msg))
    length (List_PromisedAnswer l) = U'.length l
    index i (List_PromisedAnswer l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (PromisedAnswer msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (PromisedAnswer (M'.MutMsg s)) where
    setIndex (PromisedAnswer elt) i (List_PromisedAnswer l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (PromisedAnswer msg)) where
    fromPtr msg ptr = List_PromisedAnswer <$> C'.fromPtr msg ptr
    toPtr (List_PromisedAnswer l) = C'.toPtr l
get_PromisedAnswer'questionId :: U'.ReadCtx m msg => PromisedAnswer msg -> m Word32
get_PromisedAnswer'questionId (PromisedAnswer struct) = C'.getWordField struct 0 0 0

has_PromisedAnswer'questionId :: U'.ReadCtx m msg => PromisedAnswer msg -> m Bool
has_PromisedAnswer'questionId(PromisedAnswer struct) = pure $ 0 < U'.length (U'.dataSection struct)
set_PromisedAnswer'questionId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => PromisedAnswer (M'.MutMsg s) -> Word32 -> m ()
set_PromisedAnswer'questionId (PromisedAnswer struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0

get_PromisedAnswer'transform :: U'.ReadCtx m msg => PromisedAnswer msg -> m (B'.List msg (PromisedAnswer'Op msg))
get_PromisedAnswer'transform (PromisedAnswer struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)


has_PromisedAnswer'transform :: U'.ReadCtx m msg => PromisedAnswer msg -> m Bool
has_PromisedAnswer'transform(PromisedAnswer struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_PromisedAnswer'transform :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => PromisedAnswer (M'.MutMsg s) -> (B'.List (M'.MutMsg s) (PromisedAnswer'Op (M'.MutMsg s))) -> m ()
set_PromisedAnswer'transform (PromisedAnswer struct) value = U'.setPtr (C'.toPtr value) 0 struct


data Call'sendResultsTo msg
    = Call'sendResultsTo'caller
    | Call'sendResultsTo'yourself
    | Call'sendResultsTo'thirdParty (Maybe (U'.Ptr msg))
    | Call'sendResultsTo'unknown' Word16




instance C'.IsStruct msg (Call'sendResultsTo msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 0 48 0
        case tag of
            2 -> Call'sendResultsTo'thirdParty <$>  (U'.getPtr 2 struct >>= C'.fromPtr (U'.message struct))
            1 -> pure Call'sendResultsTo'yourself
            0 -> pure Call'sendResultsTo'caller
            _ -> pure $ Call'sendResultsTo'unknown' tag
instance B'.ListElem msg (Call'sendResultsTo msg) where
    newtype List msg (Call'sendResultsTo msg) = List_Call'sendResultsTo (U'.ListOf msg (U'.Struct msg))
    length (List_Call'sendResultsTo l) = U'.length l
    index i (List_Call'sendResultsTo l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Call'sendResultsTo msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (Call'sendResultsTo msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Call'sendResultsTo msg); go = C'.fromStruct} in go)

    toPtr = error "TODO: toPtr for non-newtype structs."

instance C'.IsPtr msg (B'.List msg (Call'sendResultsTo msg)) where
    fromPtr msg ptr = List_Call'sendResultsTo <$> C'.fromPtr msg ptr
    toPtr (List_Call'sendResultsTo l) = C'.toPtr l

newtype Bootstrap msg = Bootstrap (U'.Struct msg)

instance C'.IsStruct msg (Bootstrap msg) where
    fromStruct = pure . Bootstrap
instance C'.IsPtr msg (Bootstrap msg) where
    fromPtr msg ptr = Bootstrap <$> C'.fromPtr msg ptr
    toPtr (Bootstrap struct) = C'.toPtr struct
instance B'.ListElem msg (Bootstrap msg) where
    newtype List msg (Bootstrap msg) = List_Bootstrap (U'.ListOf msg (U'.Struct msg))
    length (List_Bootstrap l) = U'.length l
    index i (List_Bootstrap l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Bootstrap msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Bootstrap (M'.MutMsg s)) where
    setIndex (Bootstrap elt) i (List_Bootstrap l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Bootstrap msg)) where
    fromPtr msg ptr = List_Bootstrap <$> C'.fromPtr msg ptr
    toPtr (List_Bootstrap l) = C'.toPtr l
get_Bootstrap'questionId :: U'.ReadCtx m msg => Bootstrap msg -> m Word32
get_Bootstrap'questionId (Bootstrap struct) = C'.getWordField struct 0 0 0

has_Bootstrap'questionId :: U'.ReadCtx m msg => Bootstrap msg -> m Bool
has_Bootstrap'questionId(Bootstrap struct) = pure $ 0 < U'.length (U'.dataSection struct)
set_Bootstrap'questionId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Bootstrap (M'.MutMsg s) -> Word32 -> m ()
set_Bootstrap'questionId (Bootstrap struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0

get_Bootstrap'deprecatedObjectId :: U'.ReadCtx m msg => Bootstrap msg -> m (Maybe (U'.Ptr msg))
get_Bootstrap'deprecatedObjectId (Bootstrap struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)


has_Bootstrap'deprecatedObjectId :: U'.ReadCtx m msg => Bootstrap msg -> m Bool
has_Bootstrap'deprecatedObjectId(Bootstrap struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_Bootstrap'deprecatedObjectId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Bootstrap (M'.MutMsg s) -> (Maybe (U'.Ptr (M'.MutMsg s))) -> m ()
set_Bootstrap'deprecatedObjectId (Bootstrap struct) value = U'.setPtr (C'.toPtr value) 0 struct


data PromisedAnswer'Op msg
    = PromisedAnswer'Op'noop
    | PromisedAnswer'Op'getPointerField Word16
    | PromisedAnswer'Op'unknown' Word16



instance C'.IsStruct msg (PromisedAnswer'Op msg) where
    fromStruct struct = do
        tag <-  C'.getWordField struct 0 0 0
        case tag of
            1 -> PromisedAnswer'Op'getPointerField <$>  C'.getWordField struct 0 16 0
            0 -> pure PromisedAnswer'Op'noop
            _ -> pure $ PromisedAnswer'Op'unknown' tag
instance B'.ListElem msg (PromisedAnswer'Op msg) where
    newtype List msg (PromisedAnswer'Op msg) = List_PromisedAnswer'Op (U'.ListOf msg (U'.Struct msg))
    length (List_PromisedAnswer'Op l) = U'.length l
    index i (List_PromisedAnswer'Op l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (PromisedAnswer'Op msg); go = C'.fromStruct} in go)

instance C'.IsPtr msg (PromisedAnswer'Op msg) where
    fromPtr msg ptr = C'.fromPtr msg ptr >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (PromisedAnswer'Op msg); go = C'.fromStruct} in go)

    toPtr = error "TODO: toPtr for non-newtype structs."

instance C'.IsPtr msg (B'.List msg (PromisedAnswer'Op msg)) where
    fromPtr msg ptr = List_PromisedAnswer'Op <$> C'.fromPtr msg ptr
    toPtr (List_PromisedAnswer'Op l) = C'.toPtr l

newtype Disembargo msg = Disembargo (U'.Struct msg)

instance C'.IsStruct msg (Disembargo msg) where
    fromStruct = pure . Disembargo
instance C'.IsPtr msg (Disembargo msg) where
    fromPtr msg ptr = Disembargo <$> C'.fromPtr msg ptr
    toPtr (Disembargo struct) = C'.toPtr struct
instance B'.ListElem msg (Disembargo msg) where
    newtype List msg (Disembargo msg) = List_Disembargo (U'.ListOf msg (U'.Struct msg))
    length (List_Disembargo l) = U'.length l
    index i (List_Disembargo l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Disembargo msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Disembargo (M'.MutMsg s)) where
    setIndex (Disembargo elt) i (List_Disembargo l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Disembargo msg)) where
    fromPtr msg ptr = List_Disembargo <$> C'.fromPtr msg ptr
    toPtr (List_Disembargo l) = C'.toPtr l
get_Disembargo'target :: U'.ReadCtx m msg => Disembargo msg -> m (MessageTarget msg)
get_Disembargo'target (Disembargo struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)


has_Disembargo'target :: U'.ReadCtx m msg => Disembargo msg -> m Bool
has_Disembargo'target(Disembargo struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_Disembargo'target :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Disembargo (M'.MutMsg s) -> (MessageTarget (M'.MutMsg s)) -> m ()
set_Disembargo'target (Disembargo struct) value = U'.setPtr (C'.toPtr value) 0 struct


get_Disembargo'context :: U'.ReadCtx m msg => Disembargo msg -> m (Disembargo'context msg)
get_Disembargo'context (Disembargo struct) = C'.fromStruct struct

has_Disembargo'context :: U'.ReadCtx m msg => Disembargo msg -> m Bool
has_Disembargo'context(Disembargo struct) = pure True
set_Disembargo'context :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Disembargo (M'.MutMsg s) -> (Disembargo'context (M'.MutMsg s)) -> m ()
set_Disembargo'context _ = error "TODO: generate more setters."

newtype Join msg = Join (U'.Struct msg)

instance C'.IsStruct msg (Join msg) where
    fromStruct = pure . Join
instance C'.IsPtr msg (Join msg) where
    fromPtr msg ptr = Join <$> C'.fromPtr msg ptr
    toPtr (Join struct) = C'.toPtr struct
instance B'.ListElem msg (Join msg) where
    newtype List msg (Join msg) = List_Join (U'.ListOf msg (U'.Struct msg))
    length (List_Join l) = U'.length l
    index i (List_Join l) = U'.index i l >>= (let {go :: U'.ReadCtx m msg => U'.Struct msg -> m (Join msg); go = C'.fromStruct} in go)
instance B'.MutListElem s (Join (M'.MutMsg s)) where
    setIndex (Join elt) i (List_Join l) = U'.setIndex elt i l

instance C'.IsPtr msg (B'.List msg (Join msg)) where
    fromPtr msg ptr = List_Join <$> C'.fromPtr msg ptr
    toPtr (List_Join l) = C'.toPtr l
get_Join'questionId :: U'.ReadCtx m msg => Join msg -> m Word32
get_Join'questionId (Join struct) = C'.getWordField struct 0 0 0

has_Join'questionId :: U'.ReadCtx m msg => Join msg -> m Bool
has_Join'questionId(Join struct) = pure $ 0 < U'.length (U'.dataSection struct)
set_Join'questionId :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Join (M'.MutMsg s) -> Word32 -> m ()
set_Join'questionId (Join struct) value =  C'.setWordField struct (fromIntegral (C'.toWord value) :: Word32) 0 0 0

get_Join'target :: U'.ReadCtx m msg => Join msg -> m (MessageTarget msg)
get_Join'target (Join struct) =
    U'.getPtr 0 struct
    >>= C'.fromPtr (U'.message struct)


has_Join'target :: U'.ReadCtx m msg => Join msg -> m Bool
has_Join'target(Join struct) = Data.Maybe.isJust <$> U'.getPtr 0 struct
set_Join'target :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Join (M'.MutMsg s) -> (MessageTarget (M'.MutMsg s)) -> m ()
set_Join'target (Join struct) value = U'.setPtr (C'.toPtr value) 0 struct


get_Join'keyPart :: U'.ReadCtx m msg => Join msg -> m (Maybe (U'.Ptr msg))
get_Join'keyPart (Join struct) =
    U'.getPtr 1 struct
    >>= C'.fromPtr (U'.message struct)


has_Join'keyPart :: U'.ReadCtx m msg => Join msg -> m Bool
has_Join'keyPart(Join struct) = Data.Maybe.isJust <$> U'.getPtr 1 struct
set_Join'keyPart :: (U'.ReadCtx m (M'.MutMsg s), M'.WriteCtx m s) => Join (M'.MutMsg s) -> (Maybe (U'.Ptr (M'.MutMsg s))) -> m ()
set_Join'keyPart (Join struct) value = U'.setPtr (C'.toPtr value) 1 struct

