{-# OPTIONS_GHC -Wno-unused-imports #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE KindSignatures #-}
module Capnp.ById.Xb312981b2552a250 where

-- Code generated by capnpc-haskell. DO NOT EDIT.
-- Generated from schema file: capnp/rpc.capnp

import Data.Int
import Data.Word
import qualified Data.Bits
import qualified Data.Maybe
import qualified Codec.Capnp
import qualified Data.Capnp.BuiltinTypes
import qualified Data.Capnp.TraversalLimit
import qualified Data.Capnp.Untyped

import qualified Capnp.ById.Xbdf87d7bb8304e81

newtype Call (m :: * -> *) = Call (Data.Capnp.Untyped.Struct m)

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsStruct m (Call m) where
    fromStruct = pure . Call
instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Call m) where
    fromPtr = Codec.Capnp.structPtr

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Data.Capnp.Untyped.ListOf m (Call m)) where
    fromPtr = Codec.Capnp.structListPtr
get_Call'questionId :: Data.Capnp.Untyped.ReadCtx m => Call m -> m Word32
get_Call'questionId (Call struct) = Codec.Capnp.getWordField struct 0 0 0

has_Call'questionId :: Data.Capnp.Untyped.ReadCtx m => Call m -> m Bool
has_Call'questionId(Call struct) = pure $ 0 < Data.Capnp.Untyped.length (Data.Capnp.Untyped.dataSection struct)
get_Call'target :: Data.Capnp.Untyped.ReadCtx m => Call m -> m (MessageTarget m)
get_Call'target (Call struct) =
    Data.Capnp.Untyped.getPtr 0 struct
    >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct)


has_Call'target :: Data.Capnp.Untyped.ReadCtx m => Call m -> m Bool
has_Call'target(Call struct) = Data.Maybe.isJust <$> Data.Capnp.Untyped.getPtr 0 struct
get_Call'interfaceId :: Data.Capnp.Untyped.ReadCtx m => Call m -> m Word64
get_Call'interfaceId (Call struct) = Codec.Capnp.getWordField struct 1 0 0

has_Call'interfaceId :: Data.Capnp.Untyped.ReadCtx m => Call m -> m Bool
has_Call'interfaceId(Call struct) = pure $ 1 < Data.Capnp.Untyped.length (Data.Capnp.Untyped.dataSection struct)
get_Call'methodId :: Data.Capnp.Untyped.ReadCtx m => Call m -> m Word16
get_Call'methodId (Call struct) = Codec.Capnp.getWordField struct 0 32 0

has_Call'methodId :: Data.Capnp.Untyped.ReadCtx m => Call m -> m Bool
has_Call'methodId(Call struct) = pure $ 0 < Data.Capnp.Untyped.length (Data.Capnp.Untyped.dataSection struct)
get_Call'params :: Data.Capnp.Untyped.ReadCtx m => Call m -> m (Payload m)
get_Call'params (Call struct) =
    Data.Capnp.Untyped.getPtr 1 struct
    >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct)


has_Call'params :: Data.Capnp.Untyped.ReadCtx m => Call m -> m Bool
has_Call'params(Call struct) = Data.Maybe.isJust <$> Data.Capnp.Untyped.getPtr 1 struct
get_Call'sendResultsTo :: Data.Capnp.Untyped.ReadCtx m => Call m -> m (Call'sendResultsTo m)
get_Call'sendResultsTo (Call struct) = Codec.Capnp.fromStruct struct

has_Call'sendResultsTo :: Data.Capnp.Untyped.ReadCtx m => Call m -> m Bool
has_Call'sendResultsTo(Call struct) = pure True
get_Call'allowThirdPartyTailCall :: Data.Capnp.Untyped.ReadCtx m => Call m -> m Bool
get_Call'allowThirdPartyTailCall (Call struct) = Codec.Capnp.getWordField struct 2 0 0

has_Call'allowThirdPartyTailCall :: Data.Capnp.Untyped.ReadCtx m => Call m -> m Bool
has_Call'allowThirdPartyTailCall(Call struct) = pure $ 2 < Data.Capnp.Untyped.length (Data.Capnp.Untyped.dataSection struct)
data CapDescriptor (m :: * -> *)
    = CapDescriptor'none
    | CapDescriptor'senderHosted Word32
    | CapDescriptor'senderPromise Word32
    | CapDescriptor'receiverHosted Word32
    | CapDescriptor'receiverAnswer (PromisedAnswer m)
    | CapDescriptor'thirdPartyHosted (ThirdPartyCapDescriptor m)
    | CapDescriptor'unknown' Word16







instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsStruct m (CapDescriptor m) where
    fromStruct struct = do
        tag <-  Codec.Capnp.getWordField struct 0 0 0
        case tag of
            5 -> CapDescriptor'thirdPartyHosted <$>  (Data.Capnp.Untyped.getPtr 0 struct >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct))
            4 -> CapDescriptor'receiverAnswer <$>  (Data.Capnp.Untyped.getPtr 0 struct >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct))
            3 -> CapDescriptor'receiverHosted <$>  Codec.Capnp.getWordField struct 0 32 0
            2 -> CapDescriptor'senderPromise <$>  Codec.Capnp.getWordField struct 0 32 0
            1 -> CapDescriptor'senderHosted <$>  Codec.Capnp.getWordField struct 0 32 0
            0 -> pure CapDescriptor'none
            _ -> pure $ CapDescriptor'unknown' tag

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (CapDescriptor m) where
    fromPtr = Codec.Capnp.structPtr
instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Data.Capnp.Untyped.ListOf m (CapDescriptor m)) where
    fromPtr = Codec.Capnp.structListPtr

data Message (m :: * -> *)
    = Message'unimplemented (Message m)
    | Message'abort (Exception m)
    | Message'call (Call m)
    | Message'return (Return m)
    | Message'finish (Finish m)
    | Message'resolve (Resolve m)
    | Message'release (Release m)
    | Message'obsoleteSave (Maybe (Data.Capnp.Untyped.Ptr m))
    | Message'bootstrap (Bootstrap m)
    | Message'obsoleteDelete (Maybe (Data.Capnp.Untyped.Ptr m))
    | Message'provide (Provide m)
    | Message'accept (Accept m)
    | Message'join (Join m)
    | Message'disembargo (Disembargo m)
    | Message'unknown' Word16















instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsStruct m (Message m) where
    fromStruct struct = do
        tag <-  Codec.Capnp.getWordField struct 0 0 0
        case tag of
            13 -> Message'disembargo <$>  (Data.Capnp.Untyped.getPtr 0 struct >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct))
            12 -> Message'join <$>  (Data.Capnp.Untyped.getPtr 0 struct >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct))
            11 -> Message'accept <$>  (Data.Capnp.Untyped.getPtr 0 struct >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct))
            10 -> Message'provide <$>  (Data.Capnp.Untyped.getPtr 0 struct >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct))
            9 -> Message'obsoleteDelete <$>  (Data.Capnp.Untyped.getPtr 0 struct >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct))
            8 -> Message'bootstrap <$>  (Data.Capnp.Untyped.getPtr 0 struct >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct))
            7 -> Message'obsoleteSave <$>  (Data.Capnp.Untyped.getPtr 0 struct >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct))
            6 -> Message'release <$>  (Data.Capnp.Untyped.getPtr 0 struct >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct))
            5 -> Message'resolve <$>  (Data.Capnp.Untyped.getPtr 0 struct >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct))
            4 -> Message'finish <$>  (Data.Capnp.Untyped.getPtr 0 struct >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct))
            3 -> Message'return <$>  (Data.Capnp.Untyped.getPtr 0 struct >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct))
            2 -> Message'call <$>  (Data.Capnp.Untyped.getPtr 0 struct >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct))
            1 -> Message'abort <$>  (Data.Capnp.Untyped.getPtr 0 struct >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct))
            0 -> Message'unimplemented <$>  (Data.Capnp.Untyped.getPtr 0 struct >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct))
            _ -> pure $ Message'unknown' tag

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Message m) where
    fromPtr = Codec.Capnp.structPtr
instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Data.Capnp.Untyped.ListOf m (Message m)) where
    fromPtr = Codec.Capnp.structListPtr

data MessageTarget (m :: * -> *)
    = MessageTarget'importedCap Word32
    | MessageTarget'promisedAnswer (PromisedAnswer m)
    | MessageTarget'unknown' Word16



instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsStruct m (MessageTarget m) where
    fromStruct struct = do
        tag <-  Codec.Capnp.getWordField struct 0 32 0
        case tag of
            1 -> MessageTarget'promisedAnswer <$>  (Data.Capnp.Untyped.getPtr 0 struct >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct))
            0 -> MessageTarget'importedCap <$>  Codec.Capnp.getWordField struct 0 0 0
            _ -> pure $ MessageTarget'unknown' tag

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (MessageTarget m) where
    fromPtr = Codec.Capnp.structPtr
instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Data.Capnp.Untyped.ListOf m (MessageTarget m)) where
    fromPtr = Codec.Capnp.structListPtr

newtype Payload (m :: * -> *) = Payload (Data.Capnp.Untyped.Struct m)

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsStruct m (Payload m) where
    fromStruct = pure . Payload
instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Payload m) where
    fromPtr = Codec.Capnp.structPtr

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Data.Capnp.Untyped.ListOf m (Payload m)) where
    fromPtr = Codec.Capnp.structListPtr
get_Payload'content :: Data.Capnp.Untyped.ReadCtx m => Payload m -> m (Maybe (Data.Capnp.Untyped.Ptr m))
get_Payload'content (Payload struct) =
    Data.Capnp.Untyped.getPtr 0 struct
    >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct)


has_Payload'content :: Data.Capnp.Untyped.ReadCtx m => Payload m -> m Bool
has_Payload'content(Payload struct) = Data.Maybe.isJust <$> Data.Capnp.Untyped.getPtr 0 struct
get_Payload'capTable :: Data.Capnp.Untyped.ReadCtx m => Payload m -> m (Data.Capnp.Untyped.ListOf m (CapDescriptor m))
get_Payload'capTable (Payload struct) =
    Data.Capnp.Untyped.getPtr 1 struct
    >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct)


has_Payload'capTable :: Data.Capnp.Untyped.ReadCtx m => Payload m -> m Bool
has_Payload'capTable(Payload struct) = Data.Maybe.isJust <$> Data.Capnp.Untyped.getPtr 1 struct
newtype Provide (m :: * -> *) = Provide (Data.Capnp.Untyped.Struct m)

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsStruct m (Provide m) where
    fromStruct = pure . Provide
instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Provide m) where
    fromPtr = Codec.Capnp.structPtr

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Data.Capnp.Untyped.ListOf m (Provide m)) where
    fromPtr = Codec.Capnp.structListPtr
get_Provide'questionId :: Data.Capnp.Untyped.ReadCtx m => Provide m -> m Word32
get_Provide'questionId (Provide struct) = Codec.Capnp.getWordField struct 0 0 0

has_Provide'questionId :: Data.Capnp.Untyped.ReadCtx m => Provide m -> m Bool
has_Provide'questionId(Provide struct) = pure $ 0 < Data.Capnp.Untyped.length (Data.Capnp.Untyped.dataSection struct)
get_Provide'target :: Data.Capnp.Untyped.ReadCtx m => Provide m -> m (MessageTarget m)
get_Provide'target (Provide struct) =
    Data.Capnp.Untyped.getPtr 0 struct
    >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct)


has_Provide'target :: Data.Capnp.Untyped.ReadCtx m => Provide m -> m Bool
has_Provide'target(Provide struct) = Data.Maybe.isJust <$> Data.Capnp.Untyped.getPtr 0 struct
get_Provide'recipient :: Data.Capnp.Untyped.ReadCtx m => Provide m -> m (Maybe (Data.Capnp.Untyped.Ptr m))
get_Provide'recipient (Provide struct) =
    Data.Capnp.Untyped.getPtr 1 struct
    >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct)


has_Provide'recipient :: Data.Capnp.Untyped.ReadCtx m => Provide m -> m Bool
has_Provide'recipient(Provide struct) = Data.Maybe.isJust <$> Data.Capnp.Untyped.getPtr 1 struct
newtype Return (m :: * -> *) = Return (Data.Capnp.Untyped.Struct m)

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsStruct m (Return m) where
    fromStruct = pure . Return
instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Return m) where
    fromPtr = Codec.Capnp.structPtr

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Data.Capnp.Untyped.ListOf m (Return m)) where
    fromPtr = Codec.Capnp.structListPtr
get_Return''answerId :: Data.Capnp.Untyped.ReadCtx m => Return m -> m Word32
get_Return''answerId (Return struct) = Codec.Capnp.getWordField struct 0 0 0

has_Return''answerId :: Data.Capnp.Untyped.ReadCtx m => Return m -> m Bool
has_Return''answerId(Return struct) = pure $ 0 < Data.Capnp.Untyped.length (Data.Capnp.Untyped.dataSection struct)
get_Return''releaseParamCaps :: Data.Capnp.Untyped.ReadCtx m => Return m -> m Bool
get_Return''releaseParamCaps (Return struct) = Codec.Capnp.getWordField struct 0 32 1

has_Return''releaseParamCaps :: Data.Capnp.Untyped.ReadCtx m => Return m -> m Bool
has_Return''releaseParamCaps(Return struct) = pure $ 0 < Data.Capnp.Untyped.length (Data.Capnp.Untyped.dataSection struct)
get_Return''union' :: Data.Capnp.Untyped.ReadCtx m => Return m -> m (Return' m)
get_Return''union' (Return struct) = Codec.Capnp.fromStruct struct

has_Return''union' :: Data.Capnp.Untyped.ReadCtx m => Return m -> m Bool
has_Return''union'(Return struct) = pure True
data Return' (m :: * -> *)
    = Return'results (Payload m)
    | Return'exception (Exception m)
    | Return'canceled
    | Return'resultsSentElsewhere
    | Return'takeFromOtherQuestion Word32
    | Return'acceptFromThirdParty (Maybe (Data.Capnp.Untyped.Ptr m))
    | Return'unknown' Word16







instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsStruct m (Return' m) where
    fromStruct struct = do
        tag <-  Codec.Capnp.getWordField struct 0 48 0
        case tag of
            5 -> Return'acceptFromThirdParty <$>  (Data.Capnp.Untyped.getPtr 0 struct >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct))
            4 -> Return'takeFromOtherQuestion <$>  Codec.Capnp.getWordField struct 1 0 0
            3 -> pure Return'resultsSentElsewhere
            2 -> pure Return'canceled
            1 -> Return'exception <$>  (Data.Capnp.Untyped.getPtr 0 struct >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct))
            0 -> Return'results <$>  (Data.Capnp.Untyped.getPtr 0 struct >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct))
            _ -> pure $ Return'unknown' tag

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Return' m) where
    fromPtr = Codec.Capnp.structPtr
instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Data.Capnp.Untyped.ListOf m (Return' m)) where
    fromPtr = Codec.Capnp.structListPtr

newtype Release (m :: * -> *) = Release (Data.Capnp.Untyped.Struct m)

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsStruct m (Release m) where
    fromStruct = pure . Release
instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Release m) where
    fromPtr = Codec.Capnp.structPtr

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Data.Capnp.Untyped.ListOf m (Release m)) where
    fromPtr = Codec.Capnp.structListPtr
get_Release'id :: Data.Capnp.Untyped.ReadCtx m => Release m -> m Word32
get_Release'id (Release struct) = Codec.Capnp.getWordField struct 0 0 0

has_Release'id :: Data.Capnp.Untyped.ReadCtx m => Release m -> m Bool
has_Release'id(Release struct) = pure $ 0 < Data.Capnp.Untyped.length (Data.Capnp.Untyped.dataSection struct)
get_Release'referenceCount :: Data.Capnp.Untyped.ReadCtx m => Release m -> m Word32
get_Release'referenceCount (Release struct) = Codec.Capnp.getWordField struct 0 32 0

has_Release'referenceCount :: Data.Capnp.Untyped.ReadCtx m => Release m -> m Bool
has_Release'referenceCount(Release struct) = pure $ 0 < Data.Capnp.Untyped.length (Data.Capnp.Untyped.dataSection struct)
data Exception'Type (m :: * -> *)
    = Exception'Type'failed
    | Exception'Type'overloaded
    | Exception'Type'disconnected
    | Exception'Type'unimplemented
    | Exception'Type'unknown' Word16
instance Enum (Exception'Type m) where
    toEnum = Codec.Capnp.fromWord . fromIntegral
    fromEnum = fromIntegral . Codec.Capnp.toWord


instance Codec.Capnp.IsWord (Exception'Type m) where
    fromWord n = go (fromIntegral n :: Word16)
      where
        go 3 = Exception'Type'unimplemented
        go 2 = Exception'Type'disconnected
        go 1 = Exception'Type'overloaded
        go 0 = Exception'Type'failed
        go tag = Exception'Type'unknown' (fromIntegral tag)
    toWord Exception'Type'unimplemented = 3
    toWord Exception'Type'disconnected = 2
    toWord Exception'Type'overloaded = 1
    toWord Exception'Type'failed = 0
    toWord (Exception'Type'unknown' tag) = fromIntegral tag
instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Data.Capnp.Untyped.ListOf m (Exception'Type m)) where
    fromPtr msg ptr = fmap
       (fmap (toEnum . (fromIntegral :: Word16 -> Int)))
       (Codec.Capnp.fromPtr msg ptr)

newtype Resolve (m :: * -> *) = Resolve (Data.Capnp.Untyped.Struct m)

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsStruct m (Resolve m) where
    fromStruct = pure . Resolve
instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Resolve m) where
    fromPtr = Codec.Capnp.structPtr

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Data.Capnp.Untyped.ListOf m (Resolve m)) where
    fromPtr = Codec.Capnp.structListPtr
get_Resolve''promiseId :: Data.Capnp.Untyped.ReadCtx m => Resolve m -> m Word32
get_Resolve''promiseId (Resolve struct) = Codec.Capnp.getWordField struct 0 0 0

has_Resolve''promiseId :: Data.Capnp.Untyped.ReadCtx m => Resolve m -> m Bool
has_Resolve''promiseId(Resolve struct) = pure $ 0 < Data.Capnp.Untyped.length (Data.Capnp.Untyped.dataSection struct)
get_Resolve''union' :: Data.Capnp.Untyped.ReadCtx m => Resolve m -> m (Resolve' m)
get_Resolve''union' (Resolve struct) = Codec.Capnp.fromStruct struct

has_Resolve''union' :: Data.Capnp.Untyped.ReadCtx m => Resolve m -> m Bool
has_Resolve''union'(Resolve struct) = pure True
data Resolve' (m :: * -> *)
    = Resolve'cap (CapDescriptor m)
    | Resolve'exception (Exception m)
    | Resolve'unknown' Word16



instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsStruct m (Resolve' m) where
    fromStruct struct = do
        tag <-  Codec.Capnp.getWordField struct 0 32 0
        case tag of
            1 -> Resolve'exception <$>  (Data.Capnp.Untyped.getPtr 0 struct >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct))
            0 -> Resolve'cap <$>  (Data.Capnp.Untyped.getPtr 0 struct >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct))
            _ -> pure $ Resolve'unknown' tag

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Resolve' m) where
    fromPtr = Codec.Capnp.structPtr
instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Data.Capnp.Untyped.ListOf m (Resolve' m)) where
    fromPtr = Codec.Capnp.structListPtr

newtype ThirdPartyCapDescriptor (m :: * -> *) = ThirdPartyCapDescriptor (Data.Capnp.Untyped.Struct m)

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsStruct m (ThirdPartyCapDescriptor m) where
    fromStruct = pure . ThirdPartyCapDescriptor
instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (ThirdPartyCapDescriptor m) where
    fromPtr = Codec.Capnp.structPtr

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Data.Capnp.Untyped.ListOf m (ThirdPartyCapDescriptor m)) where
    fromPtr = Codec.Capnp.structListPtr
get_ThirdPartyCapDescriptor'id :: Data.Capnp.Untyped.ReadCtx m => ThirdPartyCapDescriptor m -> m (Maybe (Data.Capnp.Untyped.Ptr m))
get_ThirdPartyCapDescriptor'id (ThirdPartyCapDescriptor struct) =
    Data.Capnp.Untyped.getPtr 0 struct
    >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct)


has_ThirdPartyCapDescriptor'id :: Data.Capnp.Untyped.ReadCtx m => ThirdPartyCapDescriptor m -> m Bool
has_ThirdPartyCapDescriptor'id(ThirdPartyCapDescriptor struct) = Data.Maybe.isJust <$> Data.Capnp.Untyped.getPtr 0 struct
get_ThirdPartyCapDescriptor'vineId :: Data.Capnp.Untyped.ReadCtx m => ThirdPartyCapDescriptor m -> m Word32
get_ThirdPartyCapDescriptor'vineId (ThirdPartyCapDescriptor struct) = Codec.Capnp.getWordField struct 0 0 0

has_ThirdPartyCapDescriptor'vineId :: Data.Capnp.Untyped.ReadCtx m => ThirdPartyCapDescriptor m -> m Bool
has_ThirdPartyCapDescriptor'vineId(ThirdPartyCapDescriptor struct) = pure $ 0 < Data.Capnp.Untyped.length (Data.Capnp.Untyped.dataSection struct)
newtype Finish (m :: * -> *) = Finish (Data.Capnp.Untyped.Struct m)

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsStruct m (Finish m) where
    fromStruct = pure . Finish
instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Finish m) where
    fromPtr = Codec.Capnp.structPtr

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Data.Capnp.Untyped.ListOf m (Finish m)) where
    fromPtr = Codec.Capnp.structListPtr
get_Finish'questionId :: Data.Capnp.Untyped.ReadCtx m => Finish m -> m Word32
get_Finish'questionId (Finish struct) = Codec.Capnp.getWordField struct 0 0 0

has_Finish'questionId :: Data.Capnp.Untyped.ReadCtx m => Finish m -> m Bool
has_Finish'questionId(Finish struct) = pure $ 0 < Data.Capnp.Untyped.length (Data.Capnp.Untyped.dataSection struct)
get_Finish'releaseResultCaps :: Data.Capnp.Untyped.ReadCtx m => Finish m -> m Bool
get_Finish'releaseResultCaps (Finish struct) = Codec.Capnp.getWordField struct 0 32 1

has_Finish'releaseResultCaps :: Data.Capnp.Untyped.ReadCtx m => Finish m -> m Bool
has_Finish'releaseResultCaps(Finish struct) = pure $ 0 < Data.Capnp.Untyped.length (Data.Capnp.Untyped.dataSection struct)
newtype Accept (m :: * -> *) = Accept (Data.Capnp.Untyped.Struct m)

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsStruct m (Accept m) where
    fromStruct = pure . Accept
instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Accept m) where
    fromPtr = Codec.Capnp.structPtr

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Data.Capnp.Untyped.ListOf m (Accept m)) where
    fromPtr = Codec.Capnp.structListPtr
get_Accept'questionId :: Data.Capnp.Untyped.ReadCtx m => Accept m -> m Word32
get_Accept'questionId (Accept struct) = Codec.Capnp.getWordField struct 0 0 0

has_Accept'questionId :: Data.Capnp.Untyped.ReadCtx m => Accept m -> m Bool
has_Accept'questionId(Accept struct) = pure $ 0 < Data.Capnp.Untyped.length (Data.Capnp.Untyped.dataSection struct)
get_Accept'provision :: Data.Capnp.Untyped.ReadCtx m => Accept m -> m (Maybe (Data.Capnp.Untyped.Ptr m))
get_Accept'provision (Accept struct) =
    Data.Capnp.Untyped.getPtr 0 struct
    >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct)


has_Accept'provision :: Data.Capnp.Untyped.ReadCtx m => Accept m -> m Bool
has_Accept'provision(Accept struct) = Data.Maybe.isJust <$> Data.Capnp.Untyped.getPtr 0 struct
get_Accept'embargo :: Data.Capnp.Untyped.ReadCtx m => Accept m -> m Bool
get_Accept'embargo (Accept struct) = Codec.Capnp.getWordField struct 0 32 0

has_Accept'embargo :: Data.Capnp.Untyped.ReadCtx m => Accept m -> m Bool
has_Accept'embargo(Accept struct) = pure $ 0 < Data.Capnp.Untyped.length (Data.Capnp.Untyped.dataSection struct)
data Disembargo'context (m :: * -> *)
    = Disembargo'context'senderLoopback Word32
    | Disembargo'context'receiverLoopback Word32
    | Disembargo'context'accept
    | Disembargo'context'provide Word32
    | Disembargo'context'unknown' Word16





instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsStruct m (Disembargo'context m) where
    fromStruct struct = do
        tag <-  Codec.Capnp.getWordField struct 0 32 0
        case tag of
            3 -> Disembargo'context'provide <$>  Codec.Capnp.getWordField struct 0 0 0
            2 -> pure Disembargo'context'accept
            1 -> Disembargo'context'receiverLoopback <$>  Codec.Capnp.getWordField struct 0 0 0
            0 -> Disembargo'context'senderLoopback <$>  Codec.Capnp.getWordField struct 0 0 0
            _ -> pure $ Disembargo'context'unknown' tag

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Disembargo'context m) where
    fromPtr = Codec.Capnp.structPtr
instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Data.Capnp.Untyped.ListOf m (Disembargo'context m)) where
    fromPtr = Codec.Capnp.structListPtr

newtype Exception (m :: * -> *) = Exception (Data.Capnp.Untyped.Struct m)

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsStruct m (Exception m) where
    fromStruct = pure . Exception
instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Exception m) where
    fromPtr = Codec.Capnp.structPtr

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Data.Capnp.Untyped.ListOf m (Exception m)) where
    fromPtr = Codec.Capnp.structListPtr
get_Exception'reason :: Data.Capnp.Untyped.ReadCtx m => Exception m -> m Data.Capnp.BuiltinTypes.Text
get_Exception'reason (Exception struct) =
    Data.Capnp.Untyped.getPtr 0 struct
    >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct)


has_Exception'reason :: Data.Capnp.Untyped.ReadCtx m => Exception m -> m Bool
has_Exception'reason(Exception struct) = Data.Maybe.isJust <$> Data.Capnp.Untyped.getPtr 0 struct
get_Exception'obsoleteIsCallersFault :: Data.Capnp.Untyped.ReadCtx m => Exception m -> m Bool
get_Exception'obsoleteIsCallersFault (Exception struct) = Codec.Capnp.getWordField struct 0 0 0

has_Exception'obsoleteIsCallersFault :: Data.Capnp.Untyped.ReadCtx m => Exception m -> m Bool
has_Exception'obsoleteIsCallersFault(Exception struct) = pure $ 0 < Data.Capnp.Untyped.length (Data.Capnp.Untyped.dataSection struct)
get_Exception'obsoleteDurability :: Data.Capnp.Untyped.ReadCtx m => Exception m -> m Word16
get_Exception'obsoleteDurability (Exception struct) = Codec.Capnp.getWordField struct 0 16 0

has_Exception'obsoleteDurability :: Data.Capnp.Untyped.ReadCtx m => Exception m -> m Bool
has_Exception'obsoleteDurability(Exception struct) = pure $ 0 < Data.Capnp.Untyped.length (Data.Capnp.Untyped.dataSection struct)
get_Exception'type_ :: Data.Capnp.Untyped.ReadCtx m => Exception m -> m (Exception'Type m)
get_Exception'type_ (Exception struct) = Codec.Capnp.getWordField struct 0 32 0

has_Exception'type_ :: Data.Capnp.Untyped.ReadCtx m => Exception m -> m Bool
has_Exception'type_(Exception struct) = pure $ 0 < Data.Capnp.Untyped.length (Data.Capnp.Untyped.dataSection struct)
newtype PromisedAnswer (m :: * -> *) = PromisedAnswer (Data.Capnp.Untyped.Struct m)

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsStruct m (PromisedAnswer m) where
    fromStruct = pure . PromisedAnswer
instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (PromisedAnswer m) where
    fromPtr = Codec.Capnp.structPtr

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Data.Capnp.Untyped.ListOf m (PromisedAnswer m)) where
    fromPtr = Codec.Capnp.structListPtr
get_PromisedAnswer'questionId :: Data.Capnp.Untyped.ReadCtx m => PromisedAnswer m -> m Word32
get_PromisedAnswer'questionId (PromisedAnswer struct) = Codec.Capnp.getWordField struct 0 0 0

has_PromisedAnswer'questionId :: Data.Capnp.Untyped.ReadCtx m => PromisedAnswer m -> m Bool
has_PromisedAnswer'questionId(PromisedAnswer struct) = pure $ 0 < Data.Capnp.Untyped.length (Data.Capnp.Untyped.dataSection struct)
get_PromisedAnswer'transform :: Data.Capnp.Untyped.ReadCtx m => PromisedAnswer m -> m (Data.Capnp.Untyped.ListOf m (PromisedAnswer'Op m))
get_PromisedAnswer'transform (PromisedAnswer struct) =
    Data.Capnp.Untyped.getPtr 0 struct
    >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct)


has_PromisedAnswer'transform :: Data.Capnp.Untyped.ReadCtx m => PromisedAnswer m -> m Bool
has_PromisedAnswer'transform(PromisedAnswer struct) = Data.Maybe.isJust <$> Data.Capnp.Untyped.getPtr 0 struct
data Call'sendResultsTo (m :: * -> *)
    = Call'sendResultsTo'caller
    | Call'sendResultsTo'yourself
    | Call'sendResultsTo'thirdParty (Maybe (Data.Capnp.Untyped.Ptr m))
    | Call'sendResultsTo'unknown' Word16




instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsStruct m (Call'sendResultsTo m) where
    fromStruct struct = do
        tag <-  Codec.Capnp.getWordField struct 0 48 0
        case tag of
            2 -> Call'sendResultsTo'thirdParty <$>  (Data.Capnp.Untyped.getPtr 2 struct >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct))
            1 -> pure Call'sendResultsTo'yourself
            0 -> pure Call'sendResultsTo'caller
            _ -> pure $ Call'sendResultsTo'unknown' tag

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Call'sendResultsTo m) where
    fromPtr = Codec.Capnp.structPtr
instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Data.Capnp.Untyped.ListOf m (Call'sendResultsTo m)) where
    fromPtr = Codec.Capnp.structListPtr

newtype Bootstrap (m :: * -> *) = Bootstrap (Data.Capnp.Untyped.Struct m)

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsStruct m (Bootstrap m) where
    fromStruct = pure . Bootstrap
instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Bootstrap m) where
    fromPtr = Codec.Capnp.structPtr

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Data.Capnp.Untyped.ListOf m (Bootstrap m)) where
    fromPtr = Codec.Capnp.structListPtr
get_Bootstrap'questionId :: Data.Capnp.Untyped.ReadCtx m => Bootstrap m -> m Word32
get_Bootstrap'questionId (Bootstrap struct) = Codec.Capnp.getWordField struct 0 0 0

has_Bootstrap'questionId :: Data.Capnp.Untyped.ReadCtx m => Bootstrap m -> m Bool
has_Bootstrap'questionId(Bootstrap struct) = pure $ 0 < Data.Capnp.Untyped.length (Data.Capnp.Untyped.dataSection struct)
get_Bootstrap'deprecatedObjectId :: Data.Capnp.Untyped.ReadCtx m => Bootstrap m -> m (Maybe (Data.Capnp.Untyped.Ptr m))
get_Bootstrap'deprecatedObjectId (Bootstrap struct) =
    Data.Capnp.Untyped.getPtr 0 struct
    >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct)


has_Bootstrap'deprecatedObjectId :: Data.Capnp.Untyped.ReadCtx m => Bootstrap m -> m Bool
has_Bootstrap'deprecatedObjectId(Bootstrap struct) = Data.Maybe.isJust <$> Data.Capnp.Untyped.getPtr 0 struct
data PromisedAnswer'Op (m :: * -> *)
    = PromisedAnswer'Op'noop
    | PromisedAnswer'Op'getPointerField Word16
    | PromisedAnswer'Op'unknown' Word16



instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsStruct m (PromisedAnswer'Op m) where
    fromStruct struct = do
        tag <-  Codec.Capnp.getWordField struct 0 0 0
        case tag of
            1 -> PromisedAnswer'Op'getPointerField <$>  Codec.Capnp.getWordField struct 0 16 0
            0 -> pure PromisedAnswer'Op'noop
            _ -> pure $ PromisedAnswer'Op'unknown' tag

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (PromisedAnswer'Op m) where
    fromPtr = Codec.Capnp.structPtr
instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Data.Capnp.Untyped.ListOf m (PromisedAnswer'Op m)) where
    fromPtr = Codec.Capnp.structListPtr

newtype Disembargo (m :: * -> *) = Disembargo (Data.Capnp.Untyped.Struct m)

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsStruct m (Disembargo m) where
    fromStruct = pure . Disembargo
instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Disembargo m) where
    fromPtr = Codec.Capnp.structPtr

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Data.Capnp.Untyped.ListOf m (Disembargo m)) where
    fromPtr = Codec.Capnp.structListPtr
get_Disembargo'target :: Data.Capnp.Untyped.ReadCtx m => Disembargo m -> m (MessageTarget m)
get_Disembargo'target (Disembargo struct) =
    Data.Capnp.Untyped.getPtr 0 struct
    >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct)


has_Disembargo'target :: Data.Capnp.Untyped.ReadCtx m => Disembargo m -> m Bool
has_Disembargo'target(Disembargo struct) = Data.Maybe.isJust <$> Data.Capnp.Untyped.getPtr 0 struct
get_Disembargo'context :: Data.Capnp.Untyped.ReadCtx m => Disembargo m -> m (Disembargo'context m)
get_Disembargo'context (Disembargo struct) = Codec.Capnp.fromStruct struct

has_Disembargo'context :: Data.Capnp.Untyped.ReadCtx m => Disembargo m -> m Bool
has_Disembargo'context(Disembargo struct) = pure True
newtype Join (m :: * -> *) = Join (Data.Capnp.Untyped.Struct m)

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsStruct m (Join m) where
    fromStruct = pure . Join
instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Join m) where
    fromPtr = Codec.Capnp.structPtr

instance Data.Capnp.Untyped.ReadCtx m => Codec.Capnp.IsPtr m (Data.Capnp.Untyped.ListOf m (Join m)) where
    fromPtr = Codec.Capnp.structListPtr
get_Join'questionId :: Data.Capnp.Untyped.ReadCtx m => Join m -> m Word32
get_Join'questionId (Join struct) = Codec.Capnp.getWordField struct 0 0 0

has_Join'questionId :: Data.Capnp.Untyped.ReadCtx m => Join m -> m Bool
has_Join'questionId(Join struct) = pure $ 0 < Data.Capnp.Untyped.length (Data.Capnp.Untyped.dataSection struct)
get_Join'target :: Data.Capnp.Untyped.ReadCtx m => Join m -> m (MessageTarget m)
get_Join'target (Join struct) =
    Data.Capnp.Untyped.getPtr 0 struct
    >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct)


has_Join'target :: Data.Capnp.Untyped.ReadCtx m => Join m -> m Bool
has_Join'target(Join struct) = Data.Maybe.isJust <$> Data.Capnp.Untyped.getPtr 0 struct
get_Join'keyPart :: Data.Capnp.Untyped.ReadCtx m => Join m -> m (Maybe (Data.Capnp.Untyped.Ptr m))
get_Join'keyPart (Join struct) =
    Data.Capnp.Untyped.getPtr 1 struct
    >>= Codec.Capnp.fromPtr (Data.Capnp.Untyped.message struct)


has_Join'keyPart :: Data.Capnp.Untyped.ReadCtx m => Join m -> m Bool
has_Join'keyPart(Join struct) = Data.Maybe.isJust <$> Data.Capnp.Untyped.getPtr 1 struct