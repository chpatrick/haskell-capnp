{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# OPTIONS_GHC -Wno-unused-imports #-}
module Data.Capnp.Schema.Capnp.Rpc where

-- Code generated by capnpc-haskell. DO NOT EDIT.
-- Generated from schema file: schema/capnp/rpc.capnp

import Data.Int
import Data.Word

import Data.Capnp.Untyped.Pure (List)
import Data.Capnp.BuiltinTypes.Pure (Data, Text)
import Control.Monad.Catch (MonadThrow)
import Data.Capnp.TraversalLimit (MonadLimit)

import qualified Data.Capnp.Untyped.Pure
import qualified Data.Capnp.Untyped
import qualified Codec.Capnp

import Data.ByteString as BS

import qualified Data.Capnp.ById.Xb312981b2552a250
import qualified Data.Capnp.ById.Xbdf87d7bb8304e81.Pure
import qualified Data.Capnp.ById.Xbdf87d7bb8304e81

data Call
    = Call
        { questionId :: Word32
        , target :: MessageTarget
        , interfaceId :: Word64
        , methodId :: Word16
        , params :: Payload
        , sendResultsTo :: Call'sendResultsTo
        , allowThirdPartyTailCall :: Bool
        }
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Data.Capnp.ById.Xb312981b2552a250.Call m BS.ByteString) Call where
    decerialize raw = Call
            <$> (Data.Capnp.ById.Xb312981b2552a250.get_Call'questionId raw >>= Codec.Capnp.decerialize)
            <*> (Data.Capnp.ById.Xb312981b2552a250.get_Call'target raw >>= Codec.Capnp.decerialize)
            <*> (Data.Capnp.ById.Xb312981b2552a250.get_Call'interfaceId raw >>= Codec.Capnp.decerialize)
            <*> (Data.Capnp.ById.Xb312981b2552a250.get_Call'methodId raw >>= Codec.Capnp.decerialize)
            <*> (Data.Capnp.ById.Xb312981b2552a250.get_Call'params raw >>= Codec.Capnp.decerialize)
            <*> (Data.Capnp.ById.Xb312981b2552a250.get_Call'sendResultsTo raw >>= Codec.Capnp.decerialize)
            <*> (Data.Capnp.ById.Xb312981b2552a250.get_Call'allowThirdPartyTailCall raw >>= Codec.Capnp.decerialize)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Call BS.ByteString where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Data.Capnp.ById.Xb312981b2552a250.Call m BS.ByteString)

data CapDescriptor
    = CapDescriptor'none
    | CapDescriptor'senderHosted (Word32)
    | CapDescriptor'senderPromise (Word32)
    | CapDescriptor'receiverHosted (Word32)
    | CapDescriptor'receiverAnswer (PromisedAnswer)
    | CapDescriptor'thirdPartyHosted (ThirdPartyCapDescriptor)
    | CapDescriptor'unknown' (Word16)
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Data.Capnp.ById.Xb312981b2552a250.CapDescriptor m BS.ByteString) CapDescriptor where
    decerialize raw = case raw of

        Data.Capnp.ById.Xb312981b2552a250.CapDescriptor'none -> pure CapDescriptor'none
        Data.Capnp.ById.Xb312981b2552a250.CapDescriptor'senderHosted val -> CapDescriptor'senderHosted <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.CapDescriptor'senderPromise val -> CapDescriptor'senderPromise <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.CapDescriptor'receiverHosted val -> CapDescriptor'receiverHosted <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.CapDescriptor'receiverAnswer val -> CapDescriptor'receiverAnswer <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.CapDescriptor'thirdPartyHosted val -> CapDescriptor'thirdPartyHosted <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.CapDescriptor'unknown' val -> CapDescriptor'unknown' <$> Codec.Capnp.decerialize val

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m CapDescriptor BS.ByteString where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Data.Capnp.ById.Xb312981b2552a250.CapDescriptor m BS.ByteString)

data Message
    = Message'unimplemented (Message)
    | Message'abort (Exception)
    | Message'call (Call)
    | Message'return (Return)
    | Message'finish (Finish)
    | Message'resolve (Resolve)
    | Message'release (Release)
    | Message'obsoleteSave (Maybe (Data.Capnp.Untyped.Pure.PtrType))
    | Message'bootstrap (Bootstrap)
    | Message'obsoleteDelete (Maybe (Data.Capnp.Untyped.Pure.PtrType))
    | Message'provide (Provide)
    | Message'accept (Accept)
    | Message'join (Join)
    | Message'disembargo (Disembargo)
    | Message'unknown' (Word16)
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Data.Capnp.ById.Xb312981b2552a250.Message m BS.ByteString) Message where
    decerialize raw = case raw of

        Data.Capnp.ById.Xb312981b2552a250.Message'unimplemented val -> Message'unimplemented <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.Message'abort val -> Message'abort <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.Message'call val -> Message'call <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.Message'return val -> Message'return <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.Message'finish val -> Message'finish <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.Message'resolve val -> Message'resolve <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.Message'release val -> Message'release <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.Message'obsoleteSave val -> Message'obsoleteSave <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.Message'bootstrap val -> Message'bootstrap <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.Message'obsoleteDelete val -> Message'obsoleteDelete <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.Message'provide val -> Message'provide <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.Message'accept val -> Message'accept <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.Message'join val -> Message'join <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.Message'disembargo val -> Message'disembargo <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.Message'unknown' val -> Message'unknown' <$> Codec.Capnp.decerialize val

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Message BS.ByteString where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Data.Capnp.ById.Xb312981b2552a250.Message m BS.ByteString)

data MessageTarget
    = MessageTarget'importedCap (Word32)
    | MessageTarget'promisedAnswer (PromisedAnswer)
    | MessageTarget'unknown' (Word16)
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Data.Capnp.ById.Xb312981b2552a250.MessageTarget m BS.ByteString) MessageTarget where
    decerialize raw = case raw of

        Data.Capnp.ById.Xb312981b2552a250.MessageTarget'importedCap val -> MessageTarget'importedCap <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.MessageTarget'promisedAnswer val -> MessageTarget'promisedAnswer <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.MessageTarget'unknown' val -> MessageTarget'unknown' <$> Codec.Capnp.decerialize val

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m MessageTarget BS.ByteString where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Data.Capnp.ById.Xb312981b2552a250.MessageTarget m BS.ByteString)

data Payload
    = Payload
        { content :: Maybe (Data.Capnp.Untyped.Pure.PtrType)
        , capTable :: List (CapDescriptor)
        }
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Data.Capnp.ById.Xb312981b2552a250.Payload m BS.ByteString) Payload where
    decerialize raw = Payload
            <$> (Data.Capnp.ById.Xb312981b2552a250.get_Payload'content raw >>= Codec.Capnp.decerialize)
            <*> (Data.Capnp.ById.Xb312981b2552a250.get_Payload'capTable raw >>= Codec.Capnp.decerialize)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Payload BS.ByteString where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Data.Capnp.ById.Xb312981b2552a250.Payload m BS.ByteString)

data Provide
    = Provide
        { questionId :: Word32
        , target :: MessageTarget
        , recipient :: Maybe (Data.Capnp.Untyped.Pure.PtrType)
        }
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Data.Capnp.ById.Xb312981b2552a250.Provide m BS.ByteString) Provide where
    decerialize raw = Provide
            <$> (Data.Capnp.ById.Xb312981b2552a250.get_Provide'questionId raw >>= Codec.Capnp.decerialize)
            <*> (Data.Capnp.ById.Xb312981b2552a250.get_Provide'target raw >>= Codec.Capnp.decerialize)
            <*> (Data.Capnp.ById.Xb312981b2552a250.get_Provide'recipient raw >>= Codec.Capnp.decerialize)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Provide BS.ByteString where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Data.Capnp.ById.Xb312981b2552a250.Provide m BS.ByteString)

data Return
    = Return'
        { answerId :: Word32
        , releaseParamCaps :: Bool
        , union' :: Return'
        }
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Data.Capnp.ById.Xb312981b2552a250.Return m BS.ByteString) Return where
    decerialize raw = Return'
            <$> (Data.Capnp.ById.Xb312981b2552a250.get_Return''answerId raw >>= Codec.Capnp.decerialize)
            <*> (Data.Capnp.ById.Xb312981b2552a250.get_Return''releaseParamCaps raw >>= Codec.Capnp.decerialize)
            <*> (Data.Capnp.ById.Xb312981b2552a250.get_Return''union' raw >>= Codec.Capnp.decerialize)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Return BS.ByteString where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Data.Capnp.ById.Xb312981b2552a250.Return m BS.ByteString)

data Return'
    = Return'results (Payload)
    | Return'exception (Exception)
    | Return'canceled
    | Return'resultsSentElsewhere
    | Return'takeFromOtherQuestion (Word32)
    | Return'acceptFromThirdParty (Maybe (Data.Capnp.Untyped.Pure.PtrType))
    | Return'unknown' (Word16)
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Data.Capnp.ById.Xb312981b2552a250.Return' m BS.ByteString) Return' where
    decerialize raw = case raw of

        Data.Capnp.ById.Xb312981b2552a250.Return'results val -> Return'results <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.Return'exception val -> Return'exception <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.Return'canceled -> pure Return'canceled
        Data.Capnp.ById.Xb312981b2552a250.Return'resultsSentElsewhere -> pure Return'resultsSentElsewhere
        Data.Capnp.ById.Xb312981b2552a250.Return'takeFromOtherQuestion val -> Return'takeFromOtherQuestion <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.Return'acceptFromThirdParty val -> Return'acceptFromThirdParty <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.Return'unknown' val -> Return'unknown' <$> Codec.Capnp.decerialize val

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Return' BS.ByteString where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Data.Capnp.ById.Xb312981b2552a250.Return' m BS.ByteString)

data Release
    = Release
        { id :: Word32
        , referenceCount :: Word32
        }
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Data.Capnp.ById.Xb312981b2552a250.Release m BS.ByteString) Release where
    decerialize raw = Release
            <$> (Data.Capnp.ById.Xb312981b2552a250.get_Release'id raw >>= Codec.Capnp.decerialize)
            <*> (Data.Capnp.ById.Xb312981b2552a250.get_Release'referenceCount raw >>= Codec.Capnp.decerialize)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Release BS.ByteString where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Data.Capnp.ById.Xb312981b2552a250.Release m BS.ByteString)

data Exception'Type
    = Exception'Type'failed
    | Exception'Type'overloaded
    | Exception'Type'disconnected
    | Exception'Type'unimplemented
    | Exception'Type'unknown' (Word16)
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Data.Capnp.ById.Xb312981b2552a250.Exception'Type m BS.ByteString) Exception'Type where
    decerialize raw = case raw of

        Data.Capnp.ById.Xb312981b2552a250.Exception'Type'failed -> pure Exception'Type'failed
        Data.Capnp.ById.Xb312981b2552a250.Exception'Type'overloaded -> pure Exception'Type'overloaded
        Data.Capnp.ById.Xb312981b2552a250.Exception'Type'disconnected -> pure Exception'Type'disconnected
        Data.Capnp.ById.Xb312981b2552a250.Exception'Type'unimplemented -> pure Exception'Type'unimplemented
        Data.Capnp.ById.Xb312981b2552a250.Exception'Type'unknown' val -> Exception'Type'unknown' <$> Codec.Capnp.decerialize val

data Resolve
    = Resolve'
        { promiseId :: Word32
        , union' :: Resolve'
        }
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Data.Capnp.ById.Xb312981b2552a250.Resolve m BS.ByteString) Resolve where
    decerialize raw = Resolve'
            <$> (Data.Capnp.ById.Xb312981b2552a250.get_Resolve''promiseId raw >>= Codec.Capnp.decerialize)
            <*> (Data.Capnp.ById.Xb312981b2552a250.get_Resolve''union' raw >>= Codec.Capnp.decerialize)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Resolve BS.ByteString where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Data.Capnp.ById.Xb312981b2552a250.Resolve m BS.ByteString)

data Resolve'
    = Resolve'cap (CapDescriptor)
    | Resolve'exception (Exception)
    | Resolve'unknown' (Word16)
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Data.Capnp.ById.Xb312981b2552a250.Resolve' m BS.ByteString) Resolve' where
    decerialize raw = case raw of

        Data.Capnp.ById.Xb312981b2552a250.Resolve'cap val -> Resolve'cap <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.Resolve'exception val -> Resolve'exception <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.Resolve'unknown' val -> Resolve'unknown' <$> Codec.Capnp.decerialize val

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Resolve' BS.ByteString where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Data.Capnp.ById.Xb312981b2552a250.Resolve' m BS.ByteString)

data ThirdPartyCapDescriptor
    = ThirdPartyCapDescriptor
        { id :: Maybe (Data.Capnp.Untyped.Pure.PtrType)
        , vineId :: Word32
        }
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Data.Capnp.ById.Xb312981b2552a250.ThirdPartyCapDescriptor m BS.ByteString) ThirdPartyCapDescriptor where
    decerialize raw = ThirdPartyCapDescriptor
            <$> (Data.Capnp.ById.Xb312981b2552a250.get_ThirdPartyCapDescriptor'id raw >>= Codec.Capnp.decerialize)
            <*> (Data.Capnp.ById.Xb312981b2552a250.get_ThirdPartyCapDescriptor'vineId raw >>= Codec.Capnp.decerialize)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m ThirdPartyCapDescriptor BS.ByteString where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Data.Capnp.ById.Xb312981b2552a250.ThirdPartyCapDescriptor m BS.ByteString)

data Finish
    = Finish
        { questionId :: Word32
        , releaseResultCaps :: Bool
        }
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Data.Capnp.ById.Xb312981b2552a250.Finish m BS.ByteString) Finish where
    decerialize raw = Finish
            <$> (Data.Capnp.ById.Xb312981b2552a250.get_Finish'questionId raw >>= Codec.Capnp.decerialize)
            <*> (Data.Capnp.ById.Xb312981b2552a250.get_Finish'releaseResultCaps raw >>= Codec.Capnp.decerialize)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Finish BS.ByteString where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Data.Capnp.ById.Xb312981b2552a250.Finish m BS.ByteString)

data Accept
    = Accept
        { questionId :: Word32
        , provision :: Maybe (Data.Capnp.Untyped.Pure.PtrType)
        , embargo :: Bool
        }
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Data.Capnp.ById.Xb312981b2552a250.Accept m BS.ByteString) Accept where
    decerialize raw = Accept
            <$> (Data.Capnp.ById.Xb312981b2552a250.get_Accept'questionId raw >>= Codec.Capnp.decerialize)
            <*> (Data.Capnp.ById.Xb312981b2552a250.get_Accept'provision raw >>= Codec.Capnp.decerialize)
            <*> (Data.Capnp.ById.Xb312981b2552a250.get_Accept'embargo raw >>= Codec.Capnp.decerialize)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Accept BS.ByteString where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Data.Capnp.ById.Xb312981b2552a250.Accept m BS.ByteString)

data Disembargo'context
    = Disembargo'context'senderLoopback (Word32)
    | Disembargo'context'receiverLoopback (Word32)
    | Disembargo'context'accept
    | Disembargo'context'provide (Word32)
    | Disembargo'context'unknown' (Word16)
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Data.Capnp.ById.Xb312981b2552a250.Disembargo'context m BS.ByteString) Disembargo'context where
    decerialize raw = case raw of

        Data.Capnp.ById.Xb312981b2552a250.Disembargo'context'senderLoopback val -> Disembargo'context'senderLoopback <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.Disembargo'context'receiverLoopback val -> Disembargo'context'receiverLoopback <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.Disembargo'context'accept -> pure Disembargo'context'accept
        Data.Capnp.ById.Xb312981b2552a250.Disembargo'context'provide val -> Disembargo'context'provide <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.Disembargo'context'unknown' val -> Disembargo'context'unknown' <$> Codec.Capnp.decerialize val

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Disembargo'context BS.ByteString where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Data.Capnp.ById.Xb312981b2552a250.Disembargo'context m BS.ByteString)

data Exception
    = Exception
        { reason :: Text
        , obsoleteIsCallersFault :: Bool
        , obsoleteDurability :: Word16
        , type_ :: Exception'Type
        }
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Data.Capnp.ById.Xb312981b2552a250.Exception m BS.ByteString) Exception where
    decerialize raw = Exception
            <$> (Data.Capnp.ById.Xb312981b2552a250.get_Exception'reason raw >>= Codec.Capnp.decerialize)
            <*> (Data.Capnp.ById.Xb312981b2552a250.get_Exception'obsoleteIsCallersFault raw >>= Codec.Capnp.decerialize)
            <*> (Data.Capnp.ById.Xb312981b2552a250.get_Exception'obsoleteDurability raw >>= Codec.Capnp.decerialize)
            <*> (Data.Capnp.ById.Xb312981b2552a250.get_Exception'type_ raw >>= Codec.Capnp.decerialize)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Exception BS.ByteString where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Data.Capnp.ById.Xb312981b2552a250.Exception m BS.ByteString)

data PromisedAnswer
    = PromisedAnswer
        { questionId :: Word32
        , transform :: List (PromisedAnswer'Op)
        }
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Data.Capnp.ById.Xb312981b2552a250.PromisedAnswer m BS.ByteString) PromisedAnswer where
    decerialize raw = PromisedAnswer
            <$> (Data.Capnp.ById.Xb312981b2552a250.get_PromisedAnswer'questionId raw >>= Codec.Capnp.decerialize)
            <*> (Data.Capnp.ById.Xb312981b2552a250.get_PromisedAnswer'transform raw >>= Codec.Capnp.decerialize)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m PromisedAnswer BS.ByteString where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Data.Capnp.ById.Xb312981b2552a250.PromisedAnswer m BS.ByteString)

data Call'sendResultsTo
    = Call'sendResultsTo'caller
    | Call'sendResultsTo'yourself
    | Call'sendResultsTo'thirdParty (Maybe (Data.Capnp.Untyped.Pure.PtrType))
    | Call'sendResultsTo'unknown' (Word16)
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Data.Capnp.ById.Xb312981b2552a250.Call'sendResultsTo m BS.ByteString) Call'sendResultsTo where
    decerialize raw = case raw of

        Data.Capnp.ById.Xb312981b2552a250.Call'sendResultsTo'caller -> pure Call'sendResultsTo'caller
        Data.Capnp.ById.Xb312981b2552a250.Call'sendResultsTo'yourself -> pure Call'sendResultsTo'yourself
        Data.Capnp.ById.Xb312981b2552a250.Call'sendResultsTo'thirdParty val -> Call'sendResultsTo'thirdParty <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.Call'sendResultsTo'unknown' val -> Call'sendResultsTo'unknown' <$> Codec.Capnp.decerialize val

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Call'sendResultsTo BS.ByteString where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Data.Capnp.ById.Xb312981b2552a250.Call'sendResultsTo m BS.ByteString)

data Bootstrap
    = Bootstrap
        { questionId :: Word32
        , deprecatedObjectId :: Maybe (Data.Capnp.Untyped.Pure.PtrType)
        }
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Data.Capnp.ById.Xb312981b2552a250.Bootstrap m BS.ByteString) Bootstrap where
    decerialize raw = Bootstrap
            <$> (Data.Capnp.ById.Xb312981b2552a250.get_Bootstrap'questionId raw >>= Codec.Capnp.decerialize)
            <*> (Data.Capnp.ById.Xb312981b2552a250.get_Bootstrap'deprecatedObjectId raw >>= Codec.Capnp.decerialize)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Bootstrap BS.ByteString where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Data.Capnp.ById.Xb312981b2552a250.Bootstrap m BS.ByteString)

data PromisedAnswer'Op
    = PromisedAnswer'Op'noop
    | PromisedAnswer'Op'getPointerField (Word16)
    | PromisedAnswer'Op'unknown' (Word16)
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Data.Capnp.ById.Xb312981b2552a250.PromisedAnswer'Op m BS.ByteString) PromisedAnswer'Op where
    decerialize raw = case raw of

        Data.Capnp.ById.Xb312981b2552a250.PromisedAnswer'Op'noop -> pure PromisedAnswer'Op'noop
        Data.Capnp.ById.Xb312981b2552a250.PromisedAnswer'Op'getPointerField val -> PromisedAnswer'Op'getPointerField <$> Codec.Capnp.decerialize val
        Data.Capnp.ById.Xb312981b2552a250.PromisedAnswer'Op'unknown' val -> PromisedAnswer'Op'unknown' <$> Codec.Capnp.decerialize val

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m PromisedAnswer'Op BS.ByteString where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Data.Capnp.ById.Xb312981b2552a250.PromisedAnswer'Op m BS.ByteString)

data Disembargo
    = Disembargo
        { target :: MessageTarget
        , context :: Disembargo'context
        }
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Data.Capnp.ById.Xb312981b2552a250.Disembargo m BS.ByteString) Disembargo where
    decerialize raw = Disembargo
            <$> (Data.Capnp.ById.Xb312981b2552a250.get_Disembargo'target raw >>= Codec.Capnp.decerialize)
            <*> (Data.Capnp.ById.Xb312981b2552a250.get_Disembargo'context raw >>= Codec.Capnp.decerialize)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Disembargo BS.ByteString where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Data.Capnp.ById.Xb312981b2552a250.Disembargo m BS.ByteString)

data Join
    = Join
        { questionId :: Word32
        , target :: MessageTarget
        , keyPart :: Maybe (Data.Capnp.Untyped.Pure.PtrType)
        }
    deriving(Show, Read, Eq)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.Decerialize m (Data.Capnp.ById.Xb312981b2552a250.Join m BS.ByteString) Join where
    decerialize raw = Join
            <$> (Data.Capnp.ById.Xb312981b2552a250.get_Join'questionId raw >>= Codec.Capnp.decerialize)
            <*> (Data.Capnp.ById.Xb312981b2552a250.get_Join'target raw >>= Codec.Capnp.decerialize)
            <*> (Data.Capnp.ById.Xb312981b2552a250.get_Join'keyPart raw >>= Codec.Capnp.decerialize)

instance (MonadThrow m, MonadLimit m) => Codec.Capnp.IsStruct m Join BS.ByteString where
    fromStruct struct = do
        raw <- Codec.Capnp.fromStruct struct
        Codec.Capnp.decerialize (raw :: Data.Capnp.ById.Xb312981b2552a250.Join m BS.ByteString)

